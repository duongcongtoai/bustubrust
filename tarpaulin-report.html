<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","var","www","rust","bustubrust","play","main.rs"],"content":"use std::cell::{Ref, RefCell};\nuse std::collections::HashMap;\nuse std::collections::VecDeque;\nuse std::io::copy;\nuse std::sync::Mutex;\nuse tinyvec::SliceVec;\n\n#[derive(Debug)]\nstruct Foo;\n\nfn main() {\n    let mut st = RefCell::new(HashMap::new());\n    let mut vd = VecDeque::new();\n    vd.push_back(1);\n    st.borrow_mut().insert(\"a\", vd);\n    let st2 = st.borrow_mut().get_mut(\"a\").unwrap().pop_front().unwrap();\n    println!(\"{}\", st2);\n    let st2 = st.borrow_mut().get_mut(\"a\").unwrap().pop_front().unwrap();\n    println!(\"{}\", st2);\n}\n","traces":[{"line":11,"address":[164672,165909],"length":1,"stats":{"Line":0},"fn_name":"main"},{"line":12,"address":[164679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[164729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[164736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[164804,164896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[165088],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[165351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[165485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[165736],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","var","www","rust","bustubrust","src","bpm.rs"],"content":"use core::cell::RefCell;\nuse libc::O_DIRECT;\nuse owning_ref::OwningHandle;\nuse parking_lot::{Mutex, MutexGuard};\nuse std::borrow::Borrow;\nuse std::collections::HashMap;\nuse std::collections::VecDeque;\nuse std::marker::PhantomData;\nuse std::os::unix::fs::OpenOptionsExt;\n// use std::fs::Metadata;\nuse std::sync::Arc;\nuse std::{\n    fs::{File, OpenOptions},\n    hash::Hasher,\n    io::{copy, empty, Error, Read, Seek, SeekFrom, Write},\n};\npub struct BufferPoolManager\u003cR: Replacer\u003e {\n    bp: Mutex\u003cBufferPool\u003cR\u003e\u003e,\n    pub dm: DiskManager,\n}\n/* struct AutoDropFrame\u003cF: Fn(BufferPoolManager\u003cR\u003e), R\u003e\nwhere\n    R: Replacer,\n{\n    arc: Arc\u003cMutex\u003cFrame\u003e\u003e,\n    drop_func: F,\n    r: PhantomData\u003cR\u003e,\n}\n\nimpl\u003cF, R\u003e Drop for AutoDropFrame\u003cF, R\u003e\nwhere\n    F: Fn(BufferPoolManager\u003cR\u003e),\n    R: Replacer,\n{\n    fn drop(\u0026mut self) {\n        todo!()\n    }\n} */\n\nimpl\u003cR\u003e BufferPoolManager\u003cR\u003e\nwhere\n    R: Replacer,\n{\n    pub fn new(max_size: usize, r: R, dm: DiskManager) -\u003e Self {\n        let bp = BufferPool::new(max_size, r);\n        BufferPoolManager {\n            bp: Mutex::new(bp),\n            dm,\n        }\n    }\n\n    pub fn new_page(\u0026self) -\u003e Result\u003cArc\u003cMutex\u003cFrame\u003e\u003e, StrErr\u003e {\n        let dm = \u0026self.dm;\n        BufferPool::new_page(\u0026self.bp, dm)\n    }\n\n    pub fn delete_page_locked\u003c'a\u003e(\n        \u0026self,\n        item: OwningHandle\u003cArc\u003cMutex\u003cFrame\u003e\u003e, MutexGuard\u003c'a, Frame\u003e\u003e,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        return BufferPool::delete_page_locked(\u0026self.bp, item);\n    }\n\n    pub fn fetch_page(\u0026self, page_id: PageID) -\u003e Result\u003cArc\u003cMutex\u003cFrame\u003e\u003e, StrErr\u003e {\n        BufferPool::fetch_page(\u0026self.bp, \u0026self.dm, page_id)\n    }\n\n    #[cfg(feature = \"testing\")]\n    pub fn assert_clean_frame(\u0026self, exceptions: \u0026[i64]) {\n        let mu = self.bp.lock();\n        let mut frames = mu.frames.borrow_mut();\n        'loop1: for f in frames.iter_mut() {\n            let locked_fr = f.lock();\n            let frame_id = locked_fr.id;\n            let page_id = locked_fr.page_id;\n            for item in exceptions.iter() {\n                if *item == page_id {\n                    continue 'loop1;\n                }\n            }\n            assert_eq!(\n                0, locked_fr.pin_count,\n                \"err at frame {} with page_id {}: want 0 pin count, has {}\",\n                frame_id, page_id, locked_fr.pin_count\n            );\n        }\n    }\n\n    // caller must previously acquire latches of frames, not\n    // it return the latches in batch\n    pub fn batch_unpin_flush\u003c'a\u003e(\n        \u0026self,\n        items: impl Iterator\u003cItem = OwningHandle\u003cArc\u003cMutex\u003cFrame\u003e\u003e, MutexGuard\u003c'a, Frame\u003e\u003e\u003e,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        for item in items {\n            BufferPool::unpin_flush_frame_locked(\u0026self.bp, item.page_id, item, \u0026self.dm)\n                .expect(\"failed to unpin and flush page\");\n        }\n        Ok(())\n    }\n    pub fn flush_locked\u003c'a\u003e(\u0026self, item: \u0026mut MutexGuard\u003c'a, Frame\u003e) -\u003e Result\u003c(), StrErr\u003e {\n        BufferPool::flush_frame_locked(\u0026self.bp, item.page_id, item, \u0026self.dm)\n            .expect(\"failed to flush page\");\n        Ok(())\n    }\n\n    pub fn unpin_locked\u003c'a\u003e(\n        \u0026self,\n        item: \u0026mut MutexGuard\u003c'a, Frame\u003e,\n        dirty: bool,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        BufferPool::unpin_frame_locked(\u0026self.bp, item.page_id, item, dirty)\n            .expect(\"failed to flush page\");\n        Ok(())\n    }\n\n    /* pub fn unpin_page(\u0026self, page_id: PageID, dirty: bool) -\u003e Result\u003cbool, StrErr\u003e {\n        BufferPool::unpin_page(\u0026self.bp, page_id, dirty)\n    } */\n    /* pub fn flush_page(\u0026self, page_id: PageID) -\u003e Result\u003c(), StrErr\u003e {\n        BufferPool::flush_page(\u0026self.bp, page_id, \u0026self.dm)\n    } */\n}\n\npub struct BufferPool\u003cR: Replacer\u003e {\n    frames: RefCell\u003cVec\u003cArc\u003cMutex\u003cFrame\u003e\u003e\u003e\u003e,\n    page_table: RefCell\u003cHashMap\u003ci64, FrameID\u003e\u003e,\n    size: usize,\n\n    meta: RefCell\u003cPoolMeta\u003e,\n    replacer: R,\n    free_list: RefCell\u003cVecDeque\u003cFrameID\u003e\u003e,\n}\nstruct PoolMeta {\n    next_new: i64,\n}\n\n#[allow(dead_code)]\nimpl\u003cR\u003e BufferPool\u003cR\u003e\nwhere\n    R: Replacer,\n{\n    fn new(max_size: usize, r: R) -\u003e Self {\n        let mut frames = Vec::new();\n        let mut free_list = VecDeque::new();\n        for i in 0..max_size {\n            frames.push(Arc::new(Mutex::new(Frame {\n                page_id: INVALID_PAGE_ID,\n                id: i,\n                dirty: false,\n                _1: [0; 7],\n                pin_count: 0,\n                raw_data: [0u8; PAGE_SIZE],\n                #[cfg(feature = \"testing\")]\n                last_borrower: String::new(),\n            })));\n            free_list.push_front(i);\n        }\n        BufferPool {\n            frames: RefCell::new(frames),\n            page_table: RefCell::new(HashMap::new()),\n            free_list: RefCell::new(free_list),\n            replacer: r,\n            size: max_size,\n            meta: RefCell::new(PoolMeta { next_new: 0 }),\n        }\n    }\n\n    fn _allocate_page_id_locked(b: \u0026MutexGuard\u003cSelf\u003e) -\u003e PageID {\n        let new_page = b.meta.borrow_mut().next_new;\n        b.meta.borrow_mut().next_new = new_page + 1;\n        return new_page;\n    }\n    fn _prepare_new_frame_meta(\n        b: \u0026MutexGuard\u003cBufferPool\u003cR\u003e\u003e,\n        locked_frame: \u0026MutexGuard\u003cFrame\u003e,\n        frame_id: FrameID,\n        new_page_id: PageID,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        let old_page_id = locked_frame.page_id;\n        if locked_frame.page_id != INVALID_PAGE_ID {\n            let some_frame = b.page_table.borrow_mut().remove(\u0026old_page_id);\n            match some_frame {\n                Some(deleted_frame_id) =\u003e {\n                    if deleted_frame_id != frame_id {\n                        return Err(StrErr::new(\n                            \"frame_id mismach between pointing frame_id and recorded frame_id\",\n                        ));\n                    }\n                }\n                None =\u003e {\n                    return Err(StrErr::new(\n                        \"page table does not have page received from current frame id\",\n                    ));\n                }\n            };\n        }\n        let maybe_old_frame = b\n            .page_table\n            .borrow_mut()\n            .insert(new_page_id, locked_frame.id);\n        match maybe_old_frame {\n            Some(_) =\u003e {\n                return Err(StrErr::new(\n                    \"inserting new page id but return unexpect item from map\",\n                ));\n            }\n            None =\u003e {}\n        };\n        Ok(())\n    }\n\n    fn fetch_frame\u003c'b\u003e(\n        b: \u0026MutexGuard\u003cBufferPool\u003cR\u003e\u003e,\n        free_frame: FrameID,\n    ) -\u003e Result\u003cArc\u003cMutex\u003cFrame\u003e\u003e, StrErr\u003e {\n        let chosen_frame_p: \u0026Arc\u003cMutex\u003cFrame\u003e\u003e;\n        unsafe {\n            // TODO: it this safe\n            chosen_frame_p =\n                \u0026mut *(\u0026mut b.frames.borrow_mut()[free_frame] as *mut Arc\u003cMutex\u003cFrame\u003e\u003e);\n        }\n        let chosen_frame = Arc::clone(chosen_frame_p);\n        Ok(chosen_frame)\n    }\n\n    fn new_page(mu: \u0026Mutex\u003cBufferPool\u003cR\u003e\u003e, dm: \u0026DiskManager) -\u003e Result\u003cArc\u003cMutex\u003cFrame\u003e\u003e, StrErr\u003e {\n        let b = mu.lock();\n\n        let (free_frame, victimed) = Self::_frame_from_freelist_or_replacer(\u0026b)?;\n        let chosen_frame = Self::fetch_frame(\u0026b, free_frame)?;\n        let mut locked_chosen_frame = chosen_frame.lock();\n        let new_page_id = Self::_allocate_page_id_locked(\u0026b);\n\n        Self::_prepare_new_frame_meta(\u0026b, \u0026locked_chosen_frame, free_frame, new_page_id)?;\n\n        drop(b);\n        if victimed \u0026\u0026 locked_chosen_frame.dirty {\n            dm.write_from_frame_to_file(\n                locked_chosen_frame.page_id,\n                \u0026mut locked_chosen_frame.raw_data[..],\n            )?;\n        }\n\n        locked_chosen_frame.assign_new(new_page_id)?;\n        locked_chosen_frame.pin();\n        drop(locked_chosen_frame);\n        Ok(chosen_frame)\n    }\n\n    fn _check_page_available_in_buffer(\n        b: \u0026MutexGuard\u003cBufferPool\u003cR\u003e\u003e,\n        page_id: PageID,\n    ) -\u003e Option\u003cFrameID\u003e {\n        let page_table = \u0026b.page_table.borrow();\n\n        let maybe_frame = page_table.get(\u0026page_id);\n        match maybe_frame {\n            Some(frame_id) =\u003e Some(*frame_id),\n            None =\u003e None,\n        }\n    }\n\n    fn _check_and_get_page_available_in_buffer(\n        b: \u0026MutexGuard\u003cBufferPool\u003cR\u003e\u003e,\n        page_id: PageID,\n    ) -\u003e Result\u003cOption\u003cArc\u003cMutex\u003cFrame\u003e\u003e\u003e, StrErr\u003e {\n        let page_table = \u0026b.page_table.borrow();\n\n        let maybe_frame = page_table.get(\u0026page_id);\n        match maybe_frame {\n            Some(frame_id) =\u003e {\n                let frame = Self::fetch_frame(\u0026b, *frame_id)?;\n                let mut locked_frame = frame.lock();\n                locked_frame.pin();\n                b.replacer.borrow().pin(*frame_id);\n                drop(locked_frame);\n                return Ok(Some(frame));\n            }\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn _frame_from_freelist_or_replacer(\n        b: \u0026MutexGuard\u003cBufferPool\u003cR\u003e\u003e,\n    ) -\u003e Result\u003c(FrameID, bool), StrErr\u003e {\n        if b.free_list.borrow().len() != 0 {\n            let maybe_frame = b.free_list.borrow_mut().pop_front();\n            match maybe_frame {\n                Some(popped) =\u003e return Ok((popped, false)),\n                None =\u003e {\n                    return Err(StrErr::new(\n                        \"free_list says it has len \u003e0, popping return 0 item\",\n                    ));\n                }\n            }\n        } else {\n            match b.replacer.victim() {\n                Some(frame_id) =\u003e return Ok((frame_id, true)),\n                None =\u003e {\n                    return Err(StrErr::new(\"oom\"));\n                }\n            };\n        }\n    }\n\n    fn fetch_page(\n        mu: \u0026Mutex\u003cBufferPool\u003cR\u003e\u003e,\n        dm: \u0026DiskManager,\n        page_id: PageID,\n    ) -\u003e Result\u003cArc\u003cMutex\u003cFrame\u003e\u003e, StrErr\u003e {\n        let b = mu.lock();\n\n        match Self::_check_and_get_page_available_in_buffer(\u0026b, page_id)? {\n            Some(frame) =\u003e return Ok(frame),\n            None =\u003e {}\n        };\n\n        // let mut victimed = false;\n        let (free_frame, victimed) = Self::_frame_from_freelist_or_replacer(\u0026b)?;\n\n        let chosen_frame = Self::fetch_frame(\u0026b, free_frame)?;\n        let mut locked_chosen_frame = chosen_frame.lock();\n\n        Self::_prepare_new_frame_meta(\u0026b, \u0026locked_chosen_frame, free_frame, page_id)?;\n\n        drop(b);\n        if victimed \u0026\u0026 locked_chosen_frame.dirty {\n            dm.write_from_frame_to_file(\n                locked_chosen_frame.page_id,\n                \u0026mut locked_chosen_frame.raw_data[..],\n            )?;\n        }\n        locked_chosen_frame.assign_new(page_id)?;\n        dm.read_into_frame(page_id, \u0026mut locked_chosen_frame.raw_data[..])?;\n\n        locked_chosen_frame.pin();\n        drop(locked_chosen_frame);\n        Ok(chosen_frame)\n    }\n\n    fn unpin_page(mu: \u0026Mutex\u003cBufferPool\u003cR\u003e\u003e, page_id: PageID, dirty: bool) -\u003e Result\u003cbool, StrErr\u003e {\n        let b = mu.lock();\n        match Self::_check_page_available_in_buffer(\u0026b, page_id) {\n            Some(frame_id) =\u003e {\n                let frame = Self::fetch_frame(\u0026b, frame_id)?;\n                let mut locked_frame = frame.lock();\n                locked_frame.pin_count -= 1;\n                locked_frame.dirty = dirty;\n                if locked_frame.pin_count == 0 {\n                    b.replacer.borrow().unpin(frame_id);\n                }\n                Ok(true)\n            }\n            None =\u003e Ok(false),\n        }\n    }\n    fn unpin_frame_locked\u003c'op\u003e(\n        mu: \u0026Mutex\u003cBufferPool\u003cR\u003e\u003e,\n        page_id: PageID,\n        locked: \u0026mut MutexGuard\u003c'op, Frame\u003e,\n        dirty: bool,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        let b = mu.lock();\n        locked.pin_count -= 1;\n        locked.dirty = dirty;\n        if locked.pin_count == 0 {\n            b.replacer.borrow().unpin(locked.id);\n        }\n        Ok(())\n    }\n\n    fn flush_frame_locked\u003c'op\u003e(\n        mu: \u0026Mutex\u003cBufferPool\u003cR\u003e\u003e,\n        page_id: PageID,\n        locked: \u0026mut MutexGuard\u003c'op, Frame\u003e,\n        dm: \u0026DiskManager,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        dm.write_from_frame_to_file(page_id, \u0026mut locked.raw_data[..])?;\n        Ok(())\n    }\n\n    // TODO: mark this page_id inside some reuseable page allocator\n    // + add deleted flag for future page fetch\n    fn delete_page_locked\u003c'op\u003e(\n        mu: \u0026Mutex\u003cBufferPool\u003cR\u003e\u003e,\n        mut locked: OwningHandle\u003cArc\u003cMutex\u003cFrame\u003e\u003e, MutexGuard\u003c'op, Frame\u003e\u003e,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        let b = mu.lock();\n        locked.pin_count -= 1;\n        locked.dirty = false;\n        if locked.pin_count == 0 {\n            b.replacer.borrow().unpin(locked.id);\n        } else {\n            panic!(\"Some other thread is hold an arc to a deleted page, need to handle this logic here\")\n        }\n        drop(b);\n        Ok(())\n    }\n\n    fn unpin_flush_frame_locked\u003c'op\u003e(\n        mu: \u0026Mutex\u003cBufferPool\u003cR\u003e\u003e,\n        page_id: PageID,\n        mut locked: OwningHandle\u003cArc\u003cMutex\u003cFrame\u003e\u003e, MutexGuard\u003c'op, Frame\u003e\u003e,\n        dm: \u0026DiskManager,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        let b = mu.lock();\n        locked.pin_count -= 1;\n        locked.dirty = false;\n        if locked.pin_count == 0 {\n            b.replacer.borrow().unpin(locked.id);\n        }\n        drop(b);\n        dm.write_from_frame_to_file(page_id, \u0026mut locked.raw_data[..])?;\n        Ok(())\n    }\n\n    fn flush_page(\n        mu: \u0026Mutex\u003cBufferPool\u003cR\u003e\u003e,\n        page_id: PageID,\n        dm: \u0026DiskManager,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        let b = mu.lock();\n        match Self::_check_page_available_in_buffer(\u0026b, page_id) {\n            Some(frame_id) =\u003e {\n                let frame = Self::fetch_frame(\u0026b, frame_id)?;\n                drop(b);\n                dm.write_from_frame_to_file(page_id, \u0026mut frame.lock().raw_data[..])?;\n            }\n            None =\u003e {}\n        }\n        Ok(())\n    }\n}\nconst EMPTY_PAGE: [u8; PAGE_SIZE] = [0u8; PAGE_SIZE];\n\nimpl Frame {\n    fn assign_new(\u0026mut self, new_page_id: PageID) -\u003e Result\u003c(), StrErr\u003e {\n        self.page_id = new_page_id;\n        self.dirty = false;\n\n        copy(\u0026mut \u0026EMPTY_PAGE[..], \u0026mut \u0026mut self.raw_data[..])?;\n        Ok(())\n    }\n\n    fn pin(\u0026mut self) {\n        self.pin_count += 1;\n    }\n}\n\npub type FrameID = usize;\npub type PageID = i64;\n\npub const INVALID_PAGE_ID: PageID = -1;\n\npub trait Replacer {\n    fn victim(\u0026self) -\u003e Option\u003cFrameID\u003e;\n\n    // frameID should not be victimized until unpin\n    fn pin(\u0026self, frame_id: FrameID);\n\n    // allow frame to be victimizedable\n    fn unpin(\u0026self, frame_id: FrameID);\n\n    // items that can be victimized\n    fn size(\u0026self) -\u003e i64;\n}\n\n#[repr(C)]\npub struct Frame {\n    id: FrameID,\n    page_id: PageID,\n    dirty: bool,\n    _1: [u8; 7],\n    raw_data: RawData,\n    pin_count: i64,\n    #[cfg(feature = \"testing\")]\n    last_borrower: String,\n}\nimpl Frame {\n    pub fn get_page_id(\u0026self) -\u003e i64 {\n        self.page_id\n    }\n    pub fn get_raw_data(\u0026mut self) -\u003e \u0026mut RawData {\n        \u0026mut self.raw_data\n    }\n\n    pub fn new_from_raw(raw_data: [u8; PAGE_SIZE]) -\u003e Frame {\n        Frame {\n            id: 0,\n            page_id: 0,\n            dirty: false,\n            _1: [0; 7],\n            pin_count: 0,\n            raw_data,\n            #[cfg(feature = \"testing\")]\n            last_borrower: String::new(),\n        }\n    }\n}\n\npub const PAGE_SIZE: usize = 4096;\npub type RawData = [u8; PAGE_SIZE];\n\npub struct DiskManager {\n    f: Mutex\u003cFile\u003e,\n    page_size: usize,\n}\n#[derive(Debug)]\npub struct StrErr {\n    root: String,\n}\nimpl StrErr {\n    pub fn new(st: \u0026str) -\u003e Self {\n        StrErr {\n            root: st.to_string(),\n        }\n    }\n}\n\nimpl std::convert::From\u003cError\u003e for StrErr {\n    fn from(e: Error) -\u003e Self {\n        StrErr {\n            root: e.to_string(),\n        }\n    }\n}\n\nimpl DiskManager {\n    pub fn new_from_file(f: File, page_size: u64) -\u003e Self {\n        return DiskManager {\n            f: Mutex::new(f),\n            page_size: (page_size as usize),\n        };\n    }\n    pub fn file_size(\u0026self) -\u003e Result\u003cu64, StrErr\u003e {\n        let f = self.f.lock();\n        let size = File::metadata(\u0026*f)\n            .expect(\"failed to get file metadata\")\n            .len();\n        return Ok(size);\n    }\n    pub fn new(filepath: String, page_size: u64) -\u003e Self {\n        File::create(filepath.clone()).expect(\"io error\");\n        let mut opts = OpenOptions::new();\n        opts.write(true).read(true).create(true).mode(0o666);\n        if cfg!(unix) {\n            opts.custom_flags(O_DIRECT);\n        }\n        let f = opts.open(filepath).unwrap();\n        return DiskManager {\n            f: Mutex::new(f),\n            page_size: (page_size as usize),\n        };\n    }\n\n    pub fn read_into_frame(\u0026self, page_id: PageID, buf: \u0026mut [u8]) -\u003e Result\u003c(), StrErr\u003e {\n        let mut f = self.f.lock();\n        f.seek(SeekFrom::Start(page_id as u64 * self.page_size as u64))?;\n        let read_bytes = f.read(\u0026mut buf[..self.page_size])?;\n        if read_bytes != self.page_size {\n            return Err(StrErr::new(\"not enough byte read\"));\n        }\n        Ok(())\n    }\n\n    pub fn write_from_frame_to_file(\u0026self, page_id: PageID, buf: \u0026mut [u8]) -\u003e Result\u003c(), StrErr\u003e {\n        if buf.len() != self.page_size {\n            return Err(StrErr::new(\"frame has invalid length\"));\n        }\n        let mut f = self.f.lock();\n        f.seek(SeekFrom::Start(page_id as u64 * self.page_size as u64))?;\n        let byte_written = f.write(buf)?;\n        if byte_written != self.page_size {\n            return Err(StrErr::new(\"invalid bytes written\"));\n        }\n        File::sync_all(\u0026mut f)?;\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::replacer::LRURepl;\n    use rand::{thread_rng, RngCore};\n    use std::io::{copy, Read};\n    use tempfile::tempfile;\n\n    #[test]\n    fn test_sample() {\n        let mut some_rng: Box\u003cdyn RngCore\u003e = Box::new(thread_rng());\n\n        let pool_size = 10;\n        let dm = DiskManager::new_from_file(tempfile().unwrap(), PAGE_SIZE as u64);\n        let repl = LRURepl::new(pool_size);\n        let bpm = BufferPool::new(10, repl);\n        let mu = Mutex::new(bpm);\n\n        let mut random_bin_data: [u8; PAGE_SIZE] = [0; PAGE_SIZE];\n        some_rng.read_exact(\u0026mut random_bin_data[..]).unwrap();\n\n        random_bin_data[PAGE_SIZE / 2] = '0' as u8;\n        random_bin_data[PAGE_SIZE - 1] = '0' as u8;\n        {\n            let page0 = BufferPool::new_page(\u0026mu, \u0026dm).unwrap();\n            assert_eq!(0, page0.lock().page_id);\n            let mut w = \u0026mut page0.lock().raw_data[..];\n            let mut r = \u0026random_bin_data[..];\n            copy(\u0026mut r, \u0026mut w).unwrap();\n        }\n\n        for _ in 1..pool_size {\n            match BufferPool::new_page(\u0026mu, \u0026dm) {\n                Ok(_) =\u003e {}\n                Err(some_err) =\u003e panic!(\"fetching page has err {:?}\", some_err),\n            };\n        }\n        for i in pool_size..pool_size * 2 {\n            match BufferPool::new_page(\u0026mu, \u0026dm) {\n                Ok(_) =\u003e {\n                    panic!(\"not expect this call to return success\")\n                }\n                Err(some_err) =\u003e assert_eq!(\"oom\", some_err.root),\n            };\n        }\n\n        for i in 0..5 {\n            assert_eq!(true, BufferPool::unpin_page(\u0026mu, i, true).unwrap());\n            BufferPool::flush_page(\u0026mu, i, \u0026dm).unwrap();\n        }\n\n        for i in 0..4 {\n            let some_page = BufferPool::new_page(\u0026mu, \u0026dm).unwrap();\n        }\n        let page0 = BufferPool::fetch_page(\u0026mu, \u0026dm, 0).unwrap();\n        assert_eq!(\u0026page0.lock().raw_data[..], \u0026random_bin_data[..]);\n        assert_eq!(true, BufferPool::unpin_page(\u0026mu, 0, false).unwrap());\n\n        match BufferPool::new_page(\u0026mu, \u0026dm) {\n            Ok(_) =\u003e {}\n            Err(some_err) =\u003e panic!(\"calling new page has err {:?}\", some_err),\n        }\n        match BufferPool::fetch_page(\u0026mu, \u0026dm, 0) {\n            Ok(_) =\u003e {\n                panic!(\"not expect this call to return success\")\n            }\n            Err(some_err) =\u003e assert_eq!(\"oom\", some_err.root),\n        }\n    }\n\n    #[test]\n    fn test_binary() {\n        let mut some_rng: Box\u003cdyn RngCore\u003e = Box::new(thread_rng());\n\n        let pool_size = 10;\n        let dm = DiskManager::new_from_file(tempfile().unwrap(), PAGE_SIZE as u64);\n        let repl = LRURepl::new(pool_size);\n        let bpm = BufferPool::new(10, repl);\n        let mu = Mutex::new(bpm);\n\n        let mut random_bin_data: [u8; PAGE_SIZE] = [0; PAGE_SIZE];\n        some_rng.read_exact(\u0026mut random_bin_data[..]).unwrap();\n\n        random_bin_data[PAGE_SIZE / 2] = '0' as u8;\n        random_bin_data[PAGE_SIZE - 1] = '0' as u8;\n        {\n            let page0 = BufferPool::new_page(\u0026mu, \u0026dm).unwrap();\n            assert_eq!(0, page0.lock().page_id);\n            let mut w = \u0026mut page0.lock().raw_data[..];\n            let mut r = \u0026random_bin_data[..];\n            copy(\u0026mut r, \u0026mut w).unwrap();\n        }\n\n        for _ in 1..pool_size {\n            match BufferPool::new_page(\u0026mu, \u0026dm) {\n                Ok(_) =\u003e {}\n                Err(some_err) =\u003e panic!(\"fetching page has err {:?}\", some_err),\n            };\n        }\n        for i in pool_size..pool_size * 2 {\n            match BufferPool::new_page(\u0026mu, \u0026dm) {\n                Ok(_) =\u003e {\n                    panic!(\"not expect this call to return success\")\n                }\n                Err(some_err) =\u003e assert_eq!(\"oom\", some_err.root),\n            };\n        }\n\n        for i in 0..5 {\n            assert_eq!(true, BufferPool::unpin_page(\u0026mu, i, true).unwrap());\n            BufferPool::flush_page(\u0026mu, i, \u0026dm).unwrap();\n        }\n\n        for i in 0..5 {\n            let some_page = BufferPool::new_page(\u0026mu, \u0026dm).unwrap();\n            // this is important, after this line, the lock of the page is drop, so\n            // that buffer pool can acquire the lock on the frame\n            let page_id = some_page.lock().page_id;\n            assert_eq!(true, BufferPool::unpin_page(\u0026mu, page_id, false).unwrap());\n        }\n        let page0 = BufferPool::fetch_page(\u0026mu, \u0026dm, 0).unwrap();\n        assert_eq!(\u0026page0.lock().raw_data[..], \u0026random_bin_data[..]);\n        assert_eq!(true, BufferPool::unpin_page(\u0026mu, 0, false).unwrap());\n    }\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[882160],"length":1,"stats":{"Line":1},"fn_name":"delete_page_locked\u003cbustubrust::replacer::LRURepl\u003e"},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[884832,883792,884302,884352],"length":1,"stats":{"Line":3},"fn_name":"batch_unpin_flush\u003cbustubrust::replacer::LRURepl, alloc::vec::into_iter::IntoIter\u003cowning_ref::OwningHandle\u003calloc::sync::Arc\u003clock_api::mutex::Mutex\u003cparking_lot::raw_mutex::RawMutex, bustubrust::bpm::Frame\u003e\u003e, lock_api::mutex::MutexGuard\u003cparking_lot::raw_mutex::RawMutex, bustubrust::bpm::Frame\u003e\u003e, alloc::alloc::Global\u003e\u003e"},{"line":95,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[885040],"length":1,"stats":{"Line":2},"fn_name":"unpin_locked\u003cbustubrust::replacer::LRURepl\u003e"},{"line":112,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[886896,887236],"length":1,"stats":{"Line":1},"fn_name":"_prepare_new_frame_meta\u003cbustubrust::replacer::LRURepl\u003e"},{"line":180,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[887744,887922],"length":1,"stats":{"Line":1},"fn_name":"fetch_frame\u003cbustubrust::replacer::LRURepl\u003e"},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[889949,889792],"length":1,"stats":{"Line":1},"fn_name":"_check_page_available_in_buffer\u003cbustubrust::replacer::LRURepl\u003e"},{"line":255,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[890032,890831],"length":1,"stats":{"Line":2},"fn_name":"_check_and_get_page_available_in_buffer\u003cbustubrust::replacer::LRURepl\u003e"},{"line":268,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[891042,890864],"length":1,"stats":{"Line":1},"fn_name":"_frame_from_freelist_or_replacer\u003cbustubrust::replacer::LRURepl\u003e"},{"line":287,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":307,"address":[891632,893942],"length":1,"stats":{"Line":2},"fn_name":"fetch_page\u003cbustubrust::replacer::LRURepl\u003e"},{"line":312,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[895251,894880],"length":1,"stats":{"Line":2},"fn_name":"unpin_frame_locked\u003cbustubrust::replacer::LRURepl\u003e"},{"line":364,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[895280],"length":1,"stats":{"Line":2},"fn_name":"flush_frame_locked\u003cbustubrust::replacer::LRURepl\u003e"},{"line":379,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":385,"address":[895584,896055],"length":1,"stats":{"Line":1},"fn_name":"delete_page_locked\u003cbustubrust::replacer::LRURepl\u003e"},{"line":389,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":401,"address":[896895,896096],"length":1,"stats":{"Line":2},"fn_name":"unpin_flush_frame_locked\u003cbustubrust::replacer::LRURepl\u003e"},{"line":407,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":418,"address":[896928,897871],"length":1,"stats":{"Line":1},"fn_name":"flush_page\u003cbustubrust::replacer::LRURepl\u003e"},{"line":423,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":438,"address":[506960],"length":1,"stats":{"Line":1},"fn_name":"assign_new"},{"line":439,"address":[506998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[507002],"length":1,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[507199,507006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":443,"address":[507185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[507264],"length":1,"stats":{"Line":1},"fn_name":"pin"},{"line":447,"address":[507277,507320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[507360],"length":1,"stats":{"Line":1},"fn_name":"get_page_id"},{"line":482,"address":[507365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[507376],"length":1,"stats":{"Line":2},"fn_name":"get_raw_data"},{"line":485,"address":[507384],"length":1,"stats":{"Line":2},"fn_name":null},{"line":488,"address":[507392],"length":1,"stats":{"Line":0},"fn_name":"new_from_raw"},{"line":493,"address":[507419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[507456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[507616],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":516,"address":[507639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[507696,507818],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":524,"address":[507739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[507840],"length":1,"stats":{"Line":1},"fn_name":"new_from_file"},{"line":531,"address":[507881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[507857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[507920,508146],"length":1,"stats":{"Line":1},"fn_name":"file_size"},{"line":537,"address":[507958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[508047,507977],"length":1,"stats":{"Line":2},"fn_name":null},{"line":541,"address":[508123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[508737,508176],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":544,"address":[508207,508303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[508362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[508425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[508527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[508556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[508701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[508655],"length":1,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[509566,508768],"length":1,"stats":{"Line":2},"fn_name":"read_into_frame"},{"line":558,"address":[508845],"length":1,"stats":{"Line":2},"fn_name":null},{"line":559,"address":[508864,508950,509106,509160],"length":1,"stats":{"Line":4},"fn_name":null},{"line":560,"address":[509089,509383,509443,509217],"length":1,"stats":{"Line":4},"fn_name":null},{"line":561,"address":[509371],"length":1,"stats":{"Line":2},"fn_name":null},{"line":562,"address":[509494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[509475],"length":1,"stats":{"Line":2},"fn_name":null},{"line":567,"address":[510730,509600],"length":1,"stats":{"Line":1},"fn_name":"write_from_frame_to_file"},{"line":568,"address":[509669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":569,"address":[509698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[509679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":572,"address":[509775,509864,510038,510095],"length":1,"stats":{"Line":2},"fn_name":null},{"line":573,"address":[510321,510261,510021,510155],"length":1,"stats":{"Line":2},"fn_name":null},{"line":574,"address":[510249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":575,"address":[510368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[510356,510703,510445,510643],"length":1,"stats":{"Line":2},"fn_name":null},{"line":578,"address":[510613],"length":1,"stats":{"Line":2},"fn_name":null},{"line":591,"address":[496656,501434],"length":1,"stats":{"Line":3},"fn_name":"test_sample"},{"line":592,"address":[496815,496669],"length":1,"stats":{"Line":2},"fn_name":null},{"line":594,"address":[496838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":595,"address":[496850,496950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":596,"address":[497034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":597,"address":[497041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":598,"address":[497241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":600,"address":[497296],"length":1,"stats":{"Line":1},"fn_name":null},{"line":601,"address":[497439,497306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":603,"address":[497501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":604,"address":[497509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":606,"address":[497541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":607,"address":[497602,497688],"length":1,"stats":{"Line":2},"fn_name":null},{"line":608,"address":[498119,497944],"length":1,"stats":{"Line":2},"fn_name":null},{"line":609,"address":[498135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":610,"address":[498229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":613,"address":[498288],"length":1,"stats":{"Line":1},"fn_name":null},{"line":614,"address":[498534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":616,"address":[498580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[499556,498473,499150,498870],"length":1,"stats":{"Line":4},"fn_name":null},{"line":620,"address":[499190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":622,"address":[499216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[499249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":628,"address":[499610,499772,499084],"length":1,"stats":{"Line":3},"fn_name":null},{"line":629,"address":[500017,499817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":630,"address":[500064,499994],"length":1,"stats":{"Line":2},"fn_name":null},{"line":633,"address":[499708,500105,500233],"length":1,"stats":{"Line":3},"fn_name":null},{"line":634,"address":[500271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":636,"address":[500226,500342],"length":1,"stats":{"Line":2},"fn_name":null},{"line":637,"address":[500482,500396],"length":1,"stats":{"Line":2},"fn_name":null},{"line":638,"address":[500855,501029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":640,"address":[501076,501012],"length":1,"stats":{"Line":2},"fn_name":null},{"line":642,"address":[501115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[501395,501417,501455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":646,"address":[501457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[501490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":653,"address":[506910,502048],"length":1,"stats":{"Line":3},"fn_name":"test_binary"},{"line":654,"address":[502207,502061],"length":1,"stats":{"Line":2},"fn_name":null},{"line":656,"address":[502230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":657,"address":[502342,502242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":658,"address":[502426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":659,"address":[502433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":660,"address":[502633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":662,"address":[502688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":663,"address":[502698,502831],"length":1,"stats":{"Line":2},"fn_name":null},{"line":665,"address":[502893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":666,"address":[502901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":668,"address":[502933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":669,"address":[502994,503080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":670,"address":[503336,503511],"length":1,"stats":{"Line":2},"fn_name":null},{"line":671,"address":[503527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":672,"address":[503621],"length":1,"stats":{"Line":1},"fn_name":null},{"line":675,"address":[503680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":676,"address":[503926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":678,"address":[503972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[504948,503865,504542,504262],"length":1,"stats":{"Line":4},"fn_name":null},{"line":682,"address":[504582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":684,"address":[504608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[504641],"length":1,"stats":{"Line":1},"fn_name":null},{"line":690,"address":[505002,504476,505164],"length":1,"stats":{"Line":3},"fn_name":null},{"line":691,"address":[505409,505209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":692,"address":[505456,505386],"length":1,"stats":{"Line":2},"fn_name":null},{"line":695,"address":[505628,505100,505497],"length":1,"stats":{"Line":3},"fn_name":null},{"line":696,"address":[505666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":699,"address":[505727,505813],"length":1,"stats":{"Line":2},"fn_name":null},{"line":700,"address":[505953,506120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":702,"address":[506167,505618],"length":1,"stats":{"Line":2},"fn_name":null},{"line":703,"address":[506215,506289],"length":1,"stats":{"Line":2},"fn_name":null},{"line":704,"address":[506818,506662],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":265,"coverable":315},{"path":["/","var","www","rust","bustubrust","src","btree.rs"],"content":"//TODO: manual lock/unlock is painful, try impl Drop that automatically returns the page latch to bpm\nuse crate::bpm::Frame;\nuse crate::bpm::INVALID_PAGE_ID;\nuse crate::bpm::PAGE_SIZE;\nuse crate::bpm::{BufferPoolManager, Replacer, StrErr};\nuse bytemuck::try_from_bytes_mut;\nuse bytemuck::{try_cast_slice_mut, Pod, Zeroable};\nuse iota::iota;\nuse owning_ref::OwningHandle;\nuse parking_lot::{Mutex, MutexGuard};\nuse std::fmt::Debug;\nuse std::marker::PhantomData;\nuse std::mem::size_of;\nuse std::sync::Arc;\nuse tinyvec::SliceVec;\n\ntrait DBType: Copy + Ord + Pod + Debug + Default {}\n\n#[allow(dead_code)]\nstruct Tree\u003c'a, R, K, V\u003e\nwhere\n    R: Replacer,\n    K: DBType,\n    V: DBType,\n{\n    h: \u0026'a mut HeaderPage,\n    h_lock: Arc\u003cMutex\u003cFrame\u003e\u003e,\n    bpm: \u0026'a BufferPoolManager\u003cR\u003e,\n    _1: PhantomData\u003c(K, V)\u003e,\n}\nstruct PageLatch\u003c'a, K: Pod, V: Pod\u003e {\n    // need this to handle lock/unlock\n    origin: OwningHandle\u003cArc\u003cMutex\u003cFrame\u003e\u003e, MutexGuard\u003c'a, Frame\u003e\u003e,\n    _mapped: NodePage\u003c'a, K, V\u003e,\n    ref_idx: usize,\n}\n\nstruct Access\u003c'a, K: DBType, V: DBType\u003e {\n    bread_crumbs: Vec\u003cPageLatch\u003c'a, K, V\u003e\u003e,\n    to_clean: Vec\u003cPageLatch\u003c'a, K, V\u003e\u003e,\n    flush_head: bool,\n    temp: Option\u003cPageLatch\u003c'a, K, V\u003e\u003e,\n    fetched_cousins: Vec\u003cPageLatch\u003c'a, K, V\u003e\u003e, // during borrowing, cousins\n                                               //may be prefetched and reuse for merge operations\n}\n\nimpl\u003c'a, K: DBType, V: DBType\u003e Access\u003c'a, K, V\u003e {\n    fn pop_next(\u0026mut self) -\u003e Option\u003cPageLatch\u003c'a, K, V\u003e\u003e {\n        let ret = self.bread_crumbs.pop()?;\n        return Some(ret);\n    }\n\n    fn add_flush(\u0026mut self, latch: PageLatch\u003c'a, K, V\u003e) {\n        self.to_clean.push(latch);\n    }\n\n    fn cache_fetched_cousins(\u0026mut self, cousin_latch: PageLatch\u003c'a, K, V\u003e) {\n        self.fetched_cousins.push(cousin_latch);\n    }\n\n    fn find_fetched_cousin(\u0026mut self, page_id: i64) -\u003e Option\u003cPageLatch\u003c'a, K, V\u003e\u003e {\n        let mut found_idx = -1;\n        for (idx, cousin) in self.fetched_cousins.iter().enumerate() {\n            if cousin.origin.get_page_id() == page_id {\n                found_idx = idx as i64;\n                break;\n            }\n        }\n        if found_idx == -1 {\n            panic!(\"not sure if this is reachable\");\n        }\n        let cousin = self.fetched_cousins.remove(found_idx as usize);\n        return Some(cousin);\n    }\n}\nimpl\u003cK: DBType, V: DBType\u003e Default for Access\u003c'_, K, V\u003e {\n    fn default() -\u003e Self {\n        Access {\n            bread_crumbs: vec![],\n            to_clean: vec![],\n            fetched_cousins: vec![],\n            temp: None,\n            flush_head: false,\n        }\n    }\n}\n\n#[allow(dead_code)]\nimpl\u003c'a, R: Replacer, K: DBType, V: DBType\u003e Tree\u003c'a, R, K, V\u003e {\n    fn _get_page\u003c'op\u003e(\u0026self, page_id: i64) -\u003e Result\u003cPageLatch\u003c'op, K, V\u003e, StrErr\u003e {\n        // let bpm = self.bpm;\n        let root_frame = self.bpm.fetch_page(page_id)?;\n\n        let mut guard = OwningHandle::new_with_fn(root_frame, |mutex: *const Mutex\u003cFrame\u003e| {\n            let mutex: \u0026Mutex\u003cFrame\u003e = unsafe { \u0026*mutex };\n            return mutex.lock();\n        });\n        let node: NodePage\u003c'op, K, V\u003e;\n        unsafe {\n            // this raw_data lives as long as the guard\n            let raw_data = \u0026mut *(guard.get_raw_data() as *mut [u8]);\n            node = NodePage::cast_generic(self.h.node_size, raw_data);\n        };\n\n        let b = PageLatch {\n            origin: guard,\n            _mapped: node,\n            ref_idx: 0,\n        };\n        Ok(b)\n    }\n\n    fn _get_root\u003c'op\u003e(\u0026mut self) -\u003e Result\u003cPageLatch\u003c'op, K, V\u003e, StrErr\u003e {\n        return self._get_page(self.h.root_id);\n    }\n\n    fn _search_leaf\u003c'op\u003e(\u0026mut self, search_key: \u0026K) -\u003e Result\u003cAccess\u003c'op, K, V\u003e, StrErr\u003e {\n        let mut acc = Access::default();\n        let root = self._get_root()?;\n\n        let mut cur_level = root._mapped.header.level;\n        let mut bread_crumb = root;\n        let mut idx_from_parent = 0;\n        while !bread_crumb._mapped.header.is_leaf {\n            assert!(\n                cur_level \u003e 0,\n                \"reached level 0 node but still have not found leaf node\"\n            );\n            if let PageData::B(ref branch) = bread_crumb._mapped.data {\n                idx_from_parent = branch.find_next_child(search_key);\n                bread_crumb.ref_idx = idx_from_parent;\n                let next = branch.children[idx_from_parent];\n                if next != INVALID_PAGE_ID {\n                    let next_node = self._get_page(next)?;\n                    cur_level -= 1;\n                    acc.bread_crumbs.push(bread_crumb);\n                    bread_crumb = next_node;\n                    continue;\n                }\n                panic!(\"cannot find correct node for key {:?}\", *search_key);\n            } else {\n                return Err(StrErr::new(\"page data is not branch page\"));\n            }\n        }\n        bread_crumb.ref_idx = idx_from_parent;\n        acc.bread_crumbs.push(bread_crumb);\n        return Ok(acc);\n    }\n    fn _new_empty_branch\u003c'op\u003e(\u0026self) -\u003e Result\u003cPageLatch\u003c'op, K, V\u003e, StrErr\u003e {\n        let frame_for_new_page = self.bpm.new_page().expect(\"unable to allocate new page\");\n        let mut guard =\n            OwningHandle::new_with_fn(frame_for_new_page, |mutex: *const Mutex\u003cFrame\u003e| {\n                let mutex: \u0026Mutex\u003cFrame\u003e = unsafe { \u0026*mutex };\n                return mutex.lock();\n            });\n        let node: NodePage\u003c'op, K, V\u003e;\n        unsafe {\n            // this raw_data lives as long as the guard\n            let raw_data = \u0026mut *(guard.get_raw_data() as *mut [u8]);\n\n            node = NodePage::cast_branch_from_blank(self.h.node_size, raw_data);\n        };\n\n        let b = PageLatch {\n            origin: guard,\n            _mapped: node,\n            ref_idx: 0,\n        };\n        Ok(b)\n    }\n\n    fn _new_empty_leaf\u003c'op\u003e(\u0026self) -\u003e Result\u003cPageLatch\u003c'op, K, V\u003e, StrErr\u003e {\n        let frame_for_new_page = self.bpm.new_page().expect(\"unable to allocate new page\");\n        let mut guard =\n            OwningHandle::new_with_fn(frame_for_new_page, |mutex: *const Mutex\u003cFrame\u003e| {\n                let mutex: \u0026Mutex\u003cFrame\u003e = unsafe { \u0026*mutex };\n                return mutex.lock();\n            });\n        let node: NodePage\u003c'op, K, V\u003e;\n        unsafe {\n            // this raw_data lives as long as the guard\n            let raw_data = \u0026mut *(guard.get_raw_data() as *mut [u8]);\n\n            node = NodePage::cast_leaf_from_blank(self.h.node_size, raw_data);\n        };\n\n        let b = PageLatch {\n            origin: guard,\n            _mapped: node,\n            ref_idx: 0,\n        };\n        Ok(b)\n    }\n    fn _split_branch_node\u003c'op\u003e(\n        \u0026self,\n        n: \u0026mut NodePage\u003c'op, K, V\u003e,\n    ) -\u003e Result\u003c(PageLatch\u003c'op, K, V\u003e, K), StrErr\u003e {\n        let mut new_right_node = self\n            ._new_empty_branch()\n            .expect(\"unable to create new blank branch\");\n        new_right_node._mapped.header.level = n.header.level;\n        let partition_idx = self.h.node_size as usize / 2;\n        let old_branch = n.data.branch();\n\n        let split_key = old_branch.keys[partition_idx];\n        let new_branch = \u0026mut new_right_node._mapped.data.branch();\n        new_branch\n            .keys\n            .extend_from_slice(\u0026old_branch.keys[partition_idx + 1..]);\n        new_branch\n            .children\n            .extend_from_slice(\u0026old_branch.children[partition_idx + 1..]);\n        for item in old_branch.keys[partition_idx..].iter_mut() {\n            *item = K::default()\n        }\n        for item in old_branch.children[partition_idx + 1..].iter_mut() {\n            *item = 0\n        }\n\n        old_branch.keys.truncate(partition_idx);\n        old_branch.children.truncate(partition_idx + 1);\n\n        // fix headers\n        new_right_node._mapped.header.size = n.header.size - partition_idx as i64 - 1;\n        n.header.size = partition_idx as i64;\n\n        Ok((new_right_node, split_key))\n    }\n\n    fn _split_leaf_node\u003c'op\u003e(\n        \u0026self,\n        n: \u0026mut NodePage\u003c'op, K, V\u003e,\n    ) -\u003e Result\u003c(PageLatch\u003c'op, K, V\u003e, K), StrErr\u003e {\n        let mut new_node = self\n            ._new_empty_leaf()\n            .expect(\"unable to create new blank leaf\");\n        let partition_idx = self.h.node_size as usize / 2;\n        let old_leaf = n.data.leaf();\n\n        let new_leaf = \u0026mut new_node._mapped.data.leaf();\n        new_leaf\n            .data\n            .extend_from_slice(\u0026old_leaf.data[partition_idx..]);\n        for item in old_leaf.data[partition_idx..].iter_mut() {\n            *item = Val::default()\n        }\n        old_leaf.data.truncate(partition_idx);\n\n        // fix headers\n        new_node._mapped.header.size = n.header.size - partition_idx as i64;\n        new_node._mapped.header.next = n.header.next;\n        n.header.size = partition_idx as i64;\n        n.header.next = new_node.origin.get_page_id();\n        let split_key = new_leaf.data[0].key;\n\n        Ok((new_node, split_key))\n    }\n\n    fn _insert_dirty\u003c'op\u003e(\u0026mut self, key: K, val: V) -\u003e Result\u003cAccess\u003c'op, K, V\u003e, StrErr\u003e {\n        let node_size = self.h.node_size;\n\n        // traverse the tree to find slot for this key\n        let mut acc = self._search_leaf(\u0026key)?;\n        let mut written_leaf_latch = acc.pop_next().expect(\"want at least one breadcrumb item\");\n        let mut leaf_header = \u0026mut written_leaf_latch._mapped.header;\n        let leaf_page = \u0026mut written_leaf_latch._mapped.data;\n\n        let leaf_data = leaf_page.leaf();\n        {\n            let comp = Val { key, val };\n            let idx = leaf_data.find_slot(\u0026comp)?;\n            leaf_data.data.insert(idx, comp);\n            leaf_header.size += 1;\n        }\n        // valid size\n        if leaf_header.size \u003c node_size {\n            acc.add_flush(written_leaf_latch);\n            return Ok(acc);\n        }\n        let (orphan, split_key) = self\n            ._split_leaf_node(\u0026mut written_leaf_latch._mapped)\n            .expect(\"unable to split node\");\n        let mut orphan_id = orphan.origin.get_page_id();\n        let mut split_key = split_key;\n        {\n            if acc.bread_crumbs.len() == 0 {\n                let mut new_root = self\n                    ._new_empty_branch()\n                    .expect(\"unable to create new blank branch\");\n                let new_level = orphan._mapped.header.level + 1;\n                new_root._mapped.header.level = new_level;\n                let new_root_branch = new_root._mapped.data.branch();\n                let current_root = self.h.root_id;\n                new_root._mapped.header.size += 1;\n                new_root_branch.children.push(current_root);\n                new_root_branch.children.push(orphan_id);\n                new_root_branch.keys.push(split_key);\n                self.h.root_id = new_root.origin.get_page_id();\n                acc.flush_head = true;\n\n                acc.add_flush(written_leaf_latch);\n                acc.add_flush(orphan);\n                acc.add_flush(new_root);\n                return Ok(acc);\n            }\n        }\n        acc.add_flush(written_leaf_latch);\n        acc.add_flush(orphan);\n\n        loop {\n            let mut current_parent_latch = acc.pop_next().expect(\"not expect return empty item\");\n            let current_parent = current_parent_latch._mapped.data.branch();\n            let idx = current_parent.find_slot(\u0026split_key)?;\n            current_parent.children.insert(idx + 1, orphan_id);\n            current_parent.keys.insert(idx, split_key);\n            current_parent_latch._mapped.header.size += 1;\n            if current_parent_latch._mapped.header.size \u003c node_size {\n                acc.add_flush(current_parent_latch);\n                return Ok(acc);\n            }\n\n            let (new_orphan, new_slit_key) = self\n                ._split_branch_node(\u0026mut current_parent_latch._mapped)\n                .expect(\"unable to split branch node\");\n            orphan_id = new_orphan.origin.get_page_id();\n\n            split_key = new_slit_key;\n            if acc.bread_crumbs.len() == 0 {\n                let mut new_root = self\n                    ._new_empty_branch()\n                    .expect(\"unable to create new blank branch\");\n                // acc.add_flush(new_root.origin.get_page_id());\n                let new_level = new_orphan._mapped.header.level + 1;\n                new_root._mapped.header.level = new_level;\n                new_root._mapped.header.size += 1;\n                let new_root_branch = new_root._mapped.data.branch();\n                let current_root = self.h.root_id;\n                new_root_branch.children.push(current_root);\n                new_root_branch.children.push(orphan_id);\n                new_root_branch.keys.push(split_key);\n                self.h.root_id = new_root.origin.get_page_id();\n                acc.flush_head = true;\n\n                acc.add_flush(new_root);\n                acc.add_flush(new_orphan);\n                acc.add_flush(current_parent_latch);\n                break;\n            }\n\n            acc.add_flush(new_orphan);\n            acc.add_flush(current_parent_latch);\n        }\n        return Ok(acc);\n    }\n    fn _return_access_to_bpm\u003c'op\u003e(\u0026self, mut acc: Access\u003c'op, K, V\u003e) -\u003e Result\u003c(), StrErr\u003e {\n        let bpm = self.bpm;\n        let h_lock = self.h_lock.clone();\n\n        let untouched = acc.bread_crumbs.into_iter().map(|x| x.origin);\n\n        if let Some(latch) = acc.temp {\n            acc.to_clean.push(latch);\n        }\n\n        let flush_unpins = acc.to_clean.into_iter().map(|x| x.origin);\n        let total_flushed = untouched\n            .chain(flush_unpins)\n            .chain(acc.fetched_cousins.into_iter().map(|x| x.origin));\n\n        bpm.batch_unpin_flush(total_flushed)\n            .expect(\"failed flushing in batch\");\n        if acc.flush_head {\n            let mut locked = h_lock.lock();\n            bpm.flush_locked(\u0026mut locked)\n                .expect(\"failed to flush header page\");\n        }\n\n        Ok(())\n    }\n\n    // Borrowing from cousins may cause deadlock, because there can be and scan leaf operation\n    // going on.\n    // TODO: make _get_page acquire a lock with retry mode\n    // Reference (Improved Latch Crabbing Protocol): https://15445.courses.cs.cmu.edu/fall2021/notes/08-indexconcurrency.pdf\n    fn _try_borrow_cousins_key\u003c'op\u003e(\n        \u0026self,\n        acc: \u0026mut Access\u003c'op, K, V\u003e,\n        parent: \u0026mut NodePage\u003c'op, K, V\u003e,\n        current_node: \u0026mut NodePage\u003c'op, K, V\u003e,\n        current_node_idx: usize,\n    ) -\u003e Result\u003cbool, StrErr\u003e {\n        let is_leaf = current_node.header.is_leaf;\n        let parent_branch = parent.data.branch();\n\n        // prefer borrowing for right cousin first, according to this\n        // https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html\n        if current_node_idx \u003c parent_branch.children.len() - 1 {\n            let right_cousin_id = parent_branch.children[current_node_idx + 1];\n            let mut right_cousin_latch = self._get_page(right_cousin_id)?;\n            if right_cousin_latch._mapped.header.size \u003e self.h.node_size / 2 {\n                //leaf\n                if is_leaf {\n                    let right_cousin = right_cousin_latch._mapped.data.leaf();\n                    let right_first = right_cousin.data[0];\n                    let current_leaf = current_node.data.leaf();\n\n                    current_leaf.data.push(right_first);\n                    current_node.header.size += 1;\n\n                    right_cousin.data.remove(0);\n                    right_cousin_latch._mapped.header.size -= 1;\n\n                    let new_key_for_parent = right_cousin.data[0].key;\n                    parent_branch.keys[current_node_idx] = new_key_for_parent;\n                    acc.cache_fetched_cousins(right_cousin_latch);\n                    return Ok(true);\n                }\n\n                //branch\n                let split_key = parent_branch.keys[current_node_idx];\n                let right_cousin = right_cousin_latch._mapped.data.branch();\n                let current_branch = current_node.data.branch();\n                current_branch.keys.push(split_key);\n                current_branch.children.push(right_cousin.children[0]);\n                current_node.header.size += 1;\n\n                let new_split_key = right_cousin.keys[0];\n                right_cousin.keys.remove(0);\n                right_cousin.children.remove(0);\n                right_cousin_latch._mapped.header.size -= 1;\n\n                parent_branch.keys[current_node_idx] = new_split_key;\n\n                acc.cache_fetched_cousins(right_cousin_latch);\n                return Ok(true);\n            }\n            acc.cache_fetched_cousins(right_cousin_latch);\n            return Ok(false);\n        }\n\n        // if current node has a right cousin\n        if current_node_idx \u003e 0 {\n            let left_cousin_id = parent_branch.children[current_node_idx - 1];\n            let mut left_cousin_latch = self._get_page(left_cousin_id)?;\n            if left_cousin_latch._mapped.header.size \u003e self.h.node_size / 2 {\n                //leaf\n                if is_leaf {\n                    let left_cousin = left_cousin_latch._mapped.data.leaf();\n                    let left_last_key = left_cousin.data.pop().unwrap();\n                    let current_leaf = current_node.data.leaf();\n                    current_leaf\n                        .data\n                        .resize(current_leaf.data.len() + 1, left_last_key);\n                    current_leaf.data.rotate_right(1);\n\n                    current_node.header.size += 1;\n                    left_cousin_latch._mapped.header.size -= 1;\n\n                    let new_key_for_parent = current_leaf.data[0].key;\n                    parent_branch.keys[current_node_idx - 1] = new_key_for_parent;\n                    acc.cache_fetched_cousins(left_cousin_latch);\n                    return Ok(true);\n                }\n\n                //branch\n                let split_key = parent_branch.keys[current_node_idx - 1];\n                let left_cousin = left_cousin_latch._mapped.data.branch();\n                let current_branch = current_node.data.branch();\n                current_branch\n                    .keys\n                    .resize(current_branch.keys.len() + 1, split_key);\n                current_branch.keys.rotate_right(1);\n                let left_cousin_last_child = left_cousin.children.pop().unwrap();\n                let left_cousin_last_key = left_cousin.keys.pop().unwrap();\n                current_branch\n                    .children\n                    .resize(current_branch.children.len(), left_cousin_last_child);\n\n                current_node.header.size += 1;\n                left_cousin_latch._mapped.header.size -= 1;\n\n                parent_branch.keys[current_node_idx - 1] = left_cousin_last_key;\n                acc.cache_fetched_cousins(left_cousin_latch);\n                return Ok(true);\n            }\n\n            acc.cache_fetched_cousins(left_cousin_latch);\n            return Ok(false);\n        }\n\n        panic!(\"not reach\");\n    }\n\n    // TODO: make this generic for leaf node and branch node\n    fn _merge_node_right_to_left\u003c'op\u003e(\n        \u0026self,\n        acc: \u0026mut Access\u003c'op, K, V\u003e,\n        parent: \u0026mut NodePage\u003c'op, K, V\u003e,\n        idx_of_left: usize,\n        left_node: \u0026mut NodePage\u003c'op, K, V\u003e,\n        right_node_latch: PageLatch\u003c'op, K, V\u003e,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        let is_leaf = left_node.header.is_leaf;\n        if !is_leaf {\n            let mut right_node = right_node_latch._mapped;\n            let parent_branch = parent.data.branch();\n            let left_branch = left_node.data.branch();\n            let right_branch = right_node.data.branch();\n            left_branch\n                .children\n                .extend_from_slice(\u0026right_branch.children[..]);\n            let old_split_key = parent_branch.keys[idx_of_left];\n            left_branch.keys.push(old_split_key);\n            left_branch.keys.extend_from_slice(\u0026right_branch.keys[..]);\n            left_node.header.size += right_branch.keys.len() as i64 + 1;\n\n            parent_branch.children.remove(idx_of_left + 1);\n            parent_branch.keys.remove(idx_of_left);\n            parent.header.size -= 1;\n            self.bpm.delete_page_locked(right_node_latch.origin)?;\n            return Ok(());\n        }\n        let mut right_node = right_node_latch._mapped;\n        let parent_branch = parent.data.branch();\n        let left_leaf = left_node.data.leaf();\n        let right_leaf = right_node.data.leaf();\n        left_leaf.data.extend_from_slice(\u0026right_leaf.data[..]);\n        left_node.header.size += right_leaf.data.len() as i64;\n        parent_branch.keys.remove(idx_of_left);\n        parent_branch.children.remove(idx_of_left + 1);\n        parent.header.size -= 1;\n\n        left_node.header.next = right_node.header.next;\n        self.bpm.delete_page_locked(right_node_latch.origin)?;\n        Ok(())\n    }\n\n    fn _delete_dirty\u003c'op\u003e(\u0026mut self, key: K) -\u003e Result\u003cAccess\u003c'op, K, V\u003e, StrErr\u003e {\n        let merge_threshold = self.h.node_size / 2;\n        let mut acc = self\n            ._search_leaf(\u0026key)\n            .expect(\"cannot find leaf node io insert to key\");\n        let mut node_page_latch = acc.pop_next().expect(\"not expect to return empty\");\n        let node_page = \u0026mut node_page_latch._mapped;\n        let leaf = node_page.data.leaf();\n        leaf.delete_with_key(\u0026key)?;\n        node_page.header.size -= 1;\n\n        let mut maybe_new_root = INVALID_PAGE_ID;\n        // let current_size = node_page.header.size;\n\n        // acc.add_flush(node_page_latch);\n        // while let Some(node_page_latch) = self._bubleup(\u0026mut acc,)\n        acc.temp = Some(node_page_latch);\n        while let Some(mut parent_latch) = acc.pop_next() {\n            let mut node_page_latch = acc.temp.take().unwrap();\n            let node_page = \u0026mut node_page_latch._mapped;\n            if node_page.header.size \u003e= merge_threshold {\n                acc.add_flush(node_page_latch);\n                acc.add_flush(parent_latch);\n                return Ok(acc);\n            }\n            let current_node_id = node_page_latch.origin.get_page_id();\n            let ref_idx = parent_latch.ref_idx;\n            if self._try_borrow_cousins_key(\n                \u0026mut acc,\n                \u0026mut parent_latch._mapped,\n                node_page,\n                ref_idx,\n            )? {\n                // CLEAN UP and return\n                acc.add_flush(node_page_latch);\n                acc.add_flush(parent_latch);\n                return Ok(acc);\n            }\n            let parent_branch = parent_latch._mapped.data.branch();\n            if ref_idx \u003e 0 {\n                let left_cousin_id = parent_branch.children[ref_idx - 1];\n\n                // let mut left_page_latch = self._get_page(left_cousin_id)?;\n                let mut left_page_latch = acc.find_fetched_cousin(left_cousin_id).unwrap();\n                self._merge_node_right_to_left(\n                    \u0026mut acc,\n                    \u0026mut parent_latch._mapped,\n                    ref_idx - 1,\n                    \u0026mut left_page_latch._mapped,\n                    node_page_latch,\n                )?;\n\n                maybe_new_root = left_cousin_id;\n                acc.temp = Some(parent_latch);\n                // acc.add_flush(left_page_latch);\n                acc.add_flush(left_page_latch);\n            } else if ref_idx \u003c parent_latch._mapped.header.size as usize {\n                let right_cousin_id = parent_branch.children[ref_idx + 1];\n\n                // this caching is to avoid deadlock (with current impl)\n                // because in previous step we always fetch cousin  (with raii lock) first to find if its keys are borrowable\n                let right_page_latch = acc.find_fetched_cousin(right_cousin_id).unwrap();\n                // let right_page_latch = self._get_page(right_cousin_id)?;\n                self._merge_node_right_to_left(\n                    \u0026mut acc,\n                    \u0026mut parent_latch._mapped,\n                    ref_idx,\n                    node_page,\n                    right_page_latch,\n                )?;\n\n                maybe_new_root = current_node_id;\n                acc.temp = Some(parent_latch);\n                // acc.add_flush(node_page_latch);\n                acc.add_flush(node_page_latch);\n            } else {\n                panic!(\n                    \"should not reach here, ref_idx {:?} and parent size: {:?}\",\n                    ref_idx, parent_latch._mapped.header.size\n                );\n            }\n        }\n        let previous_parent = acc.temp.take().unwrap();\n        // hard to imagine\n        // this is a case when a root node used to be a parent, but after merge, it has no key\n        // so the previous merged node is the new root node\n        if previous_parent._mapped.header.size == 0 {\n            if maybe_new_root != INVALID_PAGE_ID {\n                self.h.root_id = maybe_new_root;\n                acc.flush_head = true;\n\n                acc.add_flush(previous_parent);\n                return Ok(acc);\n            }\n        }\n        acc.add_flush(previous_parent);\n        Ok(acc)\n    }\n\n    fn insert(\u0026mut self, key: K, val: V) -\u003e Result\u003c(), StrErr\u003e {\n        let acc = self._insert_dirty(key, val).expect(\"failed to insert\");\n        let ret = self._return_access_to_bpm(acc);\n        #[cfg(feature = \"testing\")]\n        self.bpm.assert_clean_frame(\u0026[0]);\n        ret\n    }\n\n    fn delete(\u0026mut self, key: K) -\u003e Result\u003c(), StrErr\u003e {\n        let acc = self._delete_dirty(key).expect(\"failed to insert\");\n        let ret = self._return_access_to_bpm(acc);\n        #[cfg(feature = \"testing\")]\n        self.bpm.assert_clean_frame(\u0026[0]);\n        ret\n    }\n\n    fn new(bpm: \u0026'a BufferPoolManager\u003cR\u003e, node_size: i64) -\u003e Result\u003cTree\u003c'a, R, K, V\u003e, StrErr\u003e {\n        if bpm.dm.file_size()? \u003c PAGE_SIZE as u64 {\n            let header_frame = bpm.new_page().expect(\"failed to create new page\");\n            let mut locked_header = header_frame.lock();\n            if locked_header.get_page_id() != 0 {\n                return Err(StrErr::new(\"newly created header page has id not equal 0\"));\n            }\n            bpm.flush_locked(\u0026mut locked_header)?;\n        }\n        match bpm.fetch_page(0) {\n            Ok(header_frame) =\u003e {\n                // header_frame.into_inner().get_raw_data()\n                let mut locked_header = header_frame.lock();\n                // let raw = header_frame.get_raw_data();\n                let h = HeaderPage::cast(locked_header.get_raw_data());\n                let long_lived_header: \u0026'a mut HeaderPage;\n\n                // this is safe, as long as we make sure no other components can call\n                // unpin(page_0), which will make the frame containing header page\n                // be recycled to contains data from other data page\n                unsafe {\n                    long_lived_header = \u0026mut *(h as *mut HeaderPage);\n                }\n                if h.flags \u0026 HEADER_FLAG_LOCKED != 0 {\n                    return Err(StrErr::new(\"page file has been locked by other process\"));\n                }\n\n                h.flags ^= HEADER_FLAG_LOCKED;\n                if h.flags \u0026 HEADER_FLAG_INIT == 0 {\n                    h.flags ^= HEADER_FLAG_INIT;\n\n                    h.node_size = node_size;\n                    let root_page = bpm.new_page().expect(\"unable to allocate new page\");\n                    let mut locked_root_page = root_page.lock();\n                    let page_id = locked_root_page.get_page_id();\n                    // first time db is created, prepare an empty leaf-root node\n                    let _: NodePage\u003cK, V\u003e =\n                        NodePage::cast_leaf_from_blank(node_size, locked_root_page.get_raw_data());\n                    h.root_id = page_id;\n                    bpm.flush_locked(\u0026mut locked_header)\n                        .expect(\"can't flush page 0\"); // new root page\n                    bpm.flush_locked(\u0026mut locked_root_page)\n                        .expect(format!(\"cant flush page {:?}\", page_id).as_str());\n                    bpm.unpin_locked(\u0026mut locked_root_page, false)\n                        .expect(format!(\"cant unpin page {:?}\", page_id).as_str());\n                }\n\n                drop(locked_header);\n                Ok(Tree {\n                    h: long_lived_header,\n                    h_lock: header_frame,\n                    bpm,\n                    _1: PhantomData,\n                })\n            }\n            Err(some_err) =\u003e Err(StrErr::new(format!(\"todo: {:?}\", some_err).as_str())),\n        }\n    }\n}\n\n#[allow(dead_code)]\nimpl\u003c'a, K, V\u003e NodePage\u003c'a, K, V\u003e\nwhere\n    K: Pod + Sized,\n    V: Pod + Sized,\n{\n    fn cast_generic(node_size: i64, raw: \u0026'a mut [u8]) -\u003e NodePage\u003c'a, K, V\u003e {\n        let (raw_header, next) = raw.split_at_mut(size_of::\u003cPageHeader\u003e());\n        let header = try_from_bytes_mut::\u003cPageHeader\u003e(raw_header).unwrap();\n        let page_data: PageData\u003c'a, K, V\u003e;\n        match header.is_leaf {\n            true =\u003e {\n                let end = node_size as usize * size_of::\u003cVal\u003cK, V\u003e\u003e();\n                let (raw_data, _) = next.split_at_mut(end);\n                let leaf_data: \u0026mut [Val\u003cK, V\u003e] = try_cast_slice_mut(raw_data).unwrap();\n                let leaf_data = SliceVec::from_slice_len(leaf_data, header.size as usize);\n                page_data = PageData::L(LeafData { data: leaf_data });\n            }\n            false =\u003e {\n                let keys_end = node_size as usize * size_of::\u003cK\u003e();\n                let (raw_keys, next) = next.split_at_mut(keys_end);\n                let keys: \u0026mut [K] = try_cast_slice_mut(raw_keys).unwrap();\n                let keys = SliceVec::from_slice_len(keys, header.size as usize);\n\n                let children_end = (node_size + 1) as usize * size_of::\u003ci64\u003e();\n                let (raw_children, _) = next.split_at_mut(children_end);\n                let children: \u0026mut [i64] = try_cast_slice_mut(raw_children).unwrap();\n                let children = SliceVec::from_slice_len(children, header.size as usize + 1);\n                page_data = PageData::B(BranchData { keys, children });\n            }\n        }\n        let node = NodePage {\n            data: page_data,\n            header,\n        };\n        node\n    }\n\n    fn cast_leaf_from_blank(node_size: i64, raw: \u0026'a mut [u8]) -\u003e NodePage\u003c'a, K, V\u003e {\n        let (raw_header, next) = raw.split_at_mut(32);\n        let header = try_from_bytes_mut::\u003cPageHeader\u003e(raw_header).unwrap();\n        let page_data: PageData\u003c'a, K, V\u003e;\n        header.is_leaf = true;\n        header.next = INVALID_PAGE_ID;\n\n        let end = node_size as usize * size_of::\u003cVal\u003cK, V\u003e\u003e();\n        let (raw_data, _) = next.split_at_mut(end);\n        let leaf_data: \u0026mut [Val\u003cK, V\u003e] = try_cast_slice_mut(raw_data).unwrap();\n        let leaf_data = SliceVec::from_slice_len(leaf_data, 0);\n        page_data = PageData::L(LeafData { data: leaf_data });\n\n        let node = NodePage {\n            data: page_data,\n            header,\n        };\n        node\n    }\n\n    fn cast_branch_from_blank(node_size: i64, raw: \u0026'a mut [u8]) -\u003e NodePage\u003c'a, K, V\u003e {\n        let (raw_header, next) = raw.split_at_mut(32);\n        let header = try_from_bytes_mut::\u003cPageHeader\u003e(raw_header).unwrap();\n        let page_data: PageData\u003c'a, K, V\u003e;\n        header.is_leaf = false;\n\n        let keys_end = node_size as usize * size_of::\u003cK\u003e();\n        let (raw_keys, next) = next.split_at_mut(keys_end);\n        let keys: \u0026mut [K] = try_cast_slice_mut(raw_keys).unwrap();\n        let keys = SliceVec::from_slice_len(keys, 0);\n        let children_end = (node_size + 1) as usize * size_of::\u003ci64\u003e();\n        let (raw_children, _) = next.split_at_mut(children_end);\n        let children: \u0026mut [i64] = try_cast_slice_mut(raw_children).unwrap();\n        let children = SliceVec::from_slice_len(children, 0);\n        page_data = PageData::B(BranchData { keys, children });\n        let node = NodePage {\n            data: page_data,\n            header,\n        };\n        node\n    }\n}\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Default)]\nstruct Val\u003cK, V\u003e {\n    key: K,\n    val: V,\n}\n\n// unsafe impl Zeroable for PageHeader {}\nunsafe impl\u003cK: Pod, V: Pod\u003e Pod for Val\u003cK, V\u003e {}\nunsafe impl\u003cK: Pod, V: Pod\u003e Zeroable for Val\u003cK, V\u003e {}\n\nunsafe impl Pod for PageHeader {}\nunsafe impl Zeroable for PageHeader {}\n\nimpl\u003c'a, K: DBType, V: DBType\u003e LeafData\u003c'a, K, V\u003e {\n    fn delete_with_key(\u0026mut self, key: \u0026K) -\u003e Result\u003c(), StrErr\u003e {\n        let idx = self.data.binary_search_by(|\u0026x| x.key.cmp(key)).expect(\n            format!(\n                \"failed to binary search at index {:?} with key {:?}\",\n                self.data, key,\n            )\n            .as_str(),\n        );\n        self.data.remove(idx);\n        Ok(())\n    }\n\n    fn find_slot(\u0026self, data_key: \u0026Val\u003cK, V\u003e) -\u003e Result\u003cusize, StrErr\u003e {\n        let idx = self.data.partition_point(|\u0026x| x.key \u003c= data_key.key);\n        if idx \u003c self.data.len() \u0026\u0026 self.data[idx] == *data_key {\n            return Err(StrErr::new(\"duplicate key found\"));\n        }\n        return Ok(idx);\n    }\n}\n\nimpl\u003c'a, K: DBType\u003e BranchData\u003c'a, K\u003e {\n    fn find_next_child(\u0026self, search_key: \u0026K) -\u003e usize {\n        return self.keys.partition_point(|\u0026x| x \u003c= *search_key);\n    }\n    fn find_slot(\u0026self, data_key: \u0026K) -\u003e Result\u003cusize, StrErr\u003e {\n        let idx = self.keys.partition_point(|\u0026x| x \u003c= *data_key);\n        if idx \u003c self.keys.len() \u0026\u0026 self.keys[idx] == *data_key {\n            return Err(StrErr::new(\"duplicate key found\"));\n        }\n        return Ok(idx);\n    }\n}\n\nstruct NodePage\u003c'a, K, V\u003e\nwhere\n    K: Sized + Pod,\n    V: Sized + Pod,\n{\n    header: \u0026'a mut PageHeader,\n    data: PageData\u003c'a, K, V\u003e,\n}\nimpl\u003c'a, K: Sized + Pod, V: Sized + Pod\u003e PageData\u003c'a, K, V\u003e {\n    fn branch(\u0026mut self) -\u003e \u0026mut BranchData\u003c'a, K\u003e {\n        if let PageData::B(some_branch) = self {\n            some_branch\n        } else {\n            panic!(\"want branch data\")\n        }\n    }\n    fn leaf(\u0026mut self) -\u003e \u0026mut LeafData\u003c'a, K, V\u003e {\n        if let PageData::L(some_leaf) = self {\n            some_leaf\n        } else {\n            panic!(\"want leaf data\")\n        }\n    }\n}\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct PageHeader {\n    is_deleted: bool,\n    is_leaf: bool,\n    _padding2: [u8; 6],\n    level: i64,\n    size: i64, // size of keys(for branch) or data (for leaf)\n    next: i64,\n}\n\nenum PageData\u003c'a, K, V\u003e\nwhere\n    K: Sized + Pod,\n    V: Sized + Pod,\n{\n    B(BranchData\u003c'a, K\u003e),\n    L(LeafData\u003c'a, K, V\u003e),\n}\n\nunsafe impl Pod for HeaderPage {}\nunsafe impl Zeroable for HeaderPage {}\n\n#[repr(C)]\n#[derive(Copy, Clone, Debug, PartialEq)]\nstruct HeaderPage {\n    flags: i64,\n    root_id: i64,\n    node_size: i64,\n}\n/* unsafe impl Pod for HeaderPage {}\nunsafe impl Zeroable for HeaderPage {} */\n\nimpl HeaderPage {\n    fn cast(raw: \u0026mut [u8]) -\u003e \u0026mut HeaderPage {\n        try_from_bytes_mut::\u003cHeaderPage\u003e(\u0026mut raw[..size_of::\u003cHeaderPage\u003e()]).unwrap()\n    }\n}\n\nstruct BranchData\u003c'a, K\u003e\nwhere\n    K: Sized + Pod,\n{\n    // keys: \u0026'a mut [K],\n    keys: SliceVec\u003c'a, K\u003e,\n    children: SliceVec\u003c'a, i64\u003e,\n    // children: \u0026'a mut [i64],\n}\n\n#[derive(Debug)]\nstruct LeafData\u003c'a, K, V\u003e\nwhere\n    V: Sized + Clone + Pod,\n    K: Sized + Clone + Pod,\n{\n    // data: \u0026'a mut [Val\u003cK, V\u003e],\n    data: SliceVec\u003c'a, Val\u003cK, V\u003e\u003e,\n}\n\niota! {\n    const HEADER_FLAG_INIT: i64 = 1 \u003c\u003c iota;\n    , HEADER_FLAG_LOCKED\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use crate::bpm::PAGE_SIZE;\n    use crate::{bpm::DiskManager, replacer::LRURepl};\n    use bytemuck::Pod;\n    // use core::fmt::Formatter;\n    use rand::{seq, thread_rng, Rng, RngCore};\n    use std::fmt::Formatter;\n    use std::io::{Read, Seek, SeekFrom, Write};\n    use tempfile::tempfile;\n\n    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Default)]\n    struct KeyT {\n        main: i64,\n        sub: i64,\n    }\n    impl Debug for KeyT {\n        fn fmt(\u0026self, fmt: \u0026mut Formatter\u003c'_\u003e) -\u003e Result\u003c(), std::fmt::Error\u003e {\n            fmt.write_str(format!(\"{}-{}\", self.main, self.sub).as_str())\n        }\n    }\n    impl Into\u003cKeyT\u003e for i64 {\n        fn into(self) -\u003e KeyT {\n            KeyT { main: self, sub: 0 }\n        }\n    }\n    pub trait Into2\u003cT\u003e: Sized {\n        fn into2(self) -\u003e T;\n    }\n\n    impl\u003cT: Into\u003cKeyT\u003e\u003e Into2\u003cVec\u003cKeyT\u003e\u003e for Vec\u003cT\u003e {\n        fn into2(self) -\u003e Vec\u003cKeyT\u003e {\n            self.into_iter().map(|k| k.into()).collect()\n        }\n    }\n\n    unsafe impl Pod for KeyT {}\n    unsafe impl Zeroable for KeyT {}\n    impl DBType for KeyT {}\n    fn make_tree_key(input: \u0026[i64]) -\u003e Vec\u003cKeyT\u003e {\n        let mut ret = vec![];\n        for i in input {\n            ret.push(KeyT { main: *i, sub: 0 });\n        }\n        ret\n    }\n    fn make_tree_val(input: \u0026[i64]) -\u003e Vec\u003cVal\u003cKeyT, KeyT\u003e\u003e {\n        let mut ret = vec![];\n        for item in input {\n            let temp = KeyT {\n                main: *item,\n                sub: 0,\n            };\n            ret.push(Val {\n                key: temp,\n                val: temp,\n            });\n        }\n        ret\n    }\n    fn sequential_until(last: i64) -\u003e Vec\u003cKeyT\u003e {\n        let mut ret = vec![];\n        for i in 1..=last {\n            ret.push(KeyT { main: i, sub: 0 });\n        }\n        ret\n    }\n    fn inverted_sequential_until(last: i64) -\u003e Vec\u003cKeyT\u003e {\n        let mut ret = vec![];\n        for i in (1..=last).rev() {\n            ret.push(KeyT { main: i, sub: 0 });\n        }\n        ret\n    }\n\n    #[test]\n    fn test_delete() {\n        _check_deadlock();\n        let max_size = 10;\n        struct Testcase {\n            insertions: Vec\u003cKeyT\u003e,\n            deletions: Vec\u003cKeyT\u003e,\n            root_keys: Vec\u003cKeyT\u003e,\n            leaf_vals: Vec\u003c\u0026'static [i64]\u003e,\n            node_size: i64,\n        }\n        let tcases: Vec\u003cTestcase\u003e = vec![\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(5),\n                deletions: vec![2].into2(),\n                root_keys: make_tree_key(\u0026[3, 4]),\n                leaf_vals: vec![\u0026[1], \u0026[3], \u0026[4, 5]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(3),\n                deletions: vec![2, 1].into2(),\n                root_keys: vec![3].into2(),\n                leaf_vals: vec![\u0026[3]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(3),\n                deletions: vec![1].into2(),\n                root_keys: vec![3].into2(),\n                leaf_vals: vec![\u0026[2], \u0026[3]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: inverted_sequential_until(10),\n                deletions: vec![10, 9, 8].into2(),\n                root_keys: vec![5].into2(),\n                leaf_vals: vec![\u0026[1, 2], \u0026[3, 4], \u0026[5, 6], \u0026[7]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(8),\n                deletions: vec![4].into2(),\n                root_keys: vec![3, 6].into2(),\n                leaf_vals: vec![\u0026[1], \u0026[2], \u0026[3], \u0026[5], \u0026[6], \u0026[7, 8]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(6),\n                deletions: vec![2].into2(),\n                root_keys: vec![4].into2(),\n                leaf_vals: vec![\u0026[1], \u0026[3], \u0026[4], \u0026[5, 6]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(5),\n                deletions: vec![5, 4, 3].into2(),\n                root_keys: vec![2].into2(),\n                leaf_vals: vec![\u0026[1], \u0026[2]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(5),\n                deletions: vec![5, 4, 3, 2].into2(),\n                root_keys: vec![1].into2(),\n                leaf_vals: vec![\u0026[1]],\n            },\n        ];\n        for case in tcases {\n            let some_file = tempfile().unwrap();\n            let repl = LRURepl::new(max_size);\n            let dm = DiskManager::new_from_file(some_file, PAGE_SIZE as u64);\n            let bpm = BufferPoolManager::new(max_size, repl, dm);\n\n            let mut some_tree: Tree\u003c_, KeyT, KeyT\u003e =\n                Tree::new(\u0026bpm, case.node_size).expect(\"can't create new tree\");\n\n            for insertion in case.insertions {\n                some_tree\n                    .insert(insertion, insertion)\n                    .expect(format!(\"failed to insert item {:?}\", insertion).as_str());\n            }\n            for deletion in case.deletions {\n                some_tree\n                    .delete(deletion)\n                    .expect(format!(\"failed to delete key {:?}\", deletion).as_str());\n            }\n            #[cfg(feature = \"testing\")]\n            some_tree.bpm.assert_clean_frame(\u0026[0]);\n\n            let left_most = KeyT { main: -1, sub: 0 };\n            let mut acc = some_tree\n                ._search_leaf(\u0026left_most)\n                .expect(\"unable to search left most leaf\");\n            let left_most_node = acc.pop_next().expect(\"not expect returning none\");\n            let mut cur_page_id = left_most_node.origin.get_page_id();\n            acc.add_flush(left_most_node);\n            some_tree\n                ._return_access_to_bpm(acc)\n                .expect(\"err during flushing access obj\");\n\n            let mut root_latch = some_tree._get_root().expect(\"failed to get root\");\n            match root_latch._mapped.header.is_leaf {\n                true =\u003e {\n                    let root_leaf = root_latch._mapped.data.leaf();\n                    assert!(\n                        case.root_keys\n                            .iter()\n                            .zip(root_leaf.data.iter())\n                            .all(|(a, b)| *a == b.key),\n                        \"root keys not match: expect {:?}, has {:?}\",\n                        case.root_keys,\n                        root_leaf.data\n                    );\n                }\n                false =\u003e {\n                    let root_branch = root_latch._mapped.data.branch();\n                    assert!(\n                        case.root_keys\n                            .iter()\n                            .zip(root_branch.keys.iter())\n                            .all(|(a, b)| a == b),\n                        \"root keys not match: expect {:?}, has {:?}\",\n                        case.root_keys,\n                        root_branch.keys\n                    );\n                }\n            }\n\n            /* let root_branch = root_latch._mapped.data.branch();\n            assert!(\n                case.root_keys\n                    .iter()\n                    .zip(root_branch.keys.iter())\n                    .all(|(a, b)| a == b),\n                \"root keys not match: expect {:?}, has {:?}\",\n                case.root_keys,\n                root_branch.keys\n            ); */\n            let st: Vec\u003cOwningHandle\u003cArc\u003cMutex\u003cFrame\u003e\u003e, MutexGuard\u003cFrame\u003e\u003e\u003e =\n                vec![root_latch].into_iter().map(|l| l.origin).collect();\n            some_tree\n                .bpm\n                .batch_unpin_flush(st.into_iter())\n                .expect(\"failed to batch flush root page\");\n            // assert.Equal(t, tc.rootKeys, root.keys[:root.size])\n\n            for (idx, raw_node_val) in case.leaf_vals.iter().enumerate() {\n                let typed_node_val = make_tree_val(*raw_node_val);\n                let mut page_latch = some_tree\n                    ._get_page(cur_page_id)\n                    .expect(format!(\"failed to get page {:?}\", cur_page_id).as_str());\n                let real_node_val = \u0026page_latch._mapped.data.leaf().data;\n                assert!(\n                    typed_node_val\n                        .iter()\n                        .zip(real_node_val.iter())\n                        .all(|(a, b)| a == b),\n                    \"case {:?} failed keys slices are not equal expect {:?} vs real {:?}\",\n                    idx,\n                    typed_node_val,\n                    real_node_val,\n                );\n                cur_page_id = page_latch._mapped.header.next;\n            }\n        }\n    }\n\n    fn _check_deadlock() {\n        #[cfg(feature = \"testing\")]\n        {\n            // only for #[cfg]\n            use parking_lot::deadlock;\n            use std::thread;\n            use std::time::Duration;\n\n            // Create a background thread which checks for deadlocks every 10s\n            thread::spawn(move || loop {\n                thread::sleep(Duration::from_secs(2));\n                let deadlocks = deadlock::check_deadlock();\n                if deadlocks.is_empty() {\n                    continue;\n                }\n\n                println!(\"{} deadlocks detected\", deadlocks.len());\n                for (i, threads) in deadlocks.iter().enumerate() {\n                    println!(\"Deadlock #{}\", i);\n                    for t in threads {\n                        println!(\"Thread Id {:#?}\", t.thread_id());\n                        println!(\"{:#?}\", t.backtrace());\n                    }\n                }\n            });\n        }\n    }\n\n    #[test]\n    fn test_insert() {\n        let max_size = 10;\n        struct Testcase {\n            insertions: Vec\u003cKeyT\u003e,\n            root_keys: Vec\u003cKeyT\u003e,\n            leaf_vals: Vec\u003c\u0026'static [i64]\u003e,\n            node_size: i64,\n        }\n        let tcases: Vec\u003cTestcase\u003e = vec![\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(4),\n                root_keys: make_tree_key(\u0026[2, 3]),\n                leaf_vals: vec![\u0026[1], \u0026[2], \u0026[3, 4]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(3),\n                root_keys: make_tree_key(\u0026[2]),\n                leaf_vals: vec![\u0026[1], \u0026[2, 3]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: inverted_sequential_until(10),\n                root_keys: make_tree_key(\u0026[7]),\n                leaf_vals: vec![\u0026[1, 2], \u0026[3, 4], \u0026[5, 6], \u0026[7, 8], \u0026[9, 10]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(6),\n                root_keys: vec![3].into2(),\n                leaf_vals: vec![\u0026[1], \u0026[2], \u0026[3], \u0026[4], \u0026[5, 6]],\n            },\n            Testcase {\n                node_size: 4,\n                insertions: make_tree_key(\u0026[1, 3, 5, 9, 10]),\n                root_keys: vec![5].into2(),\n                leaf_vals: vec![\u0026[1, 3], \u0026[5, 9, 10]],\n            },\n            Testcase {\n                node_size: 7,\n                insertions: sequential_until(13),\n                root_keys: vec![4, 7, 10].into2(),\n                leaf_vals: vec![\u0026[1, 2, 3], \u0026[4, 5, 6], \u0026[7, 8, 9], \u0026[10, 11, 12, 13]],\n            },\n        ];\n        for case in tcases {\n            let some_file = tempfile().unwrap();\n            let repl = LRURepl::new(max_size);\n            let dm = DiskManager::new_from_file(some_file, PAGE_SIZE as u64);\n            let bpm = BufferPoolManager::new(max_size, repl, dm);\n\n            let mut some_tree: Tree\u003c_, KeyT, KeyT\u003e =\n                Tree::new(\u0026bpm, case.node_size).expect(\"can't create new tree\");\n\n            for insertion in case.insertions {\n                some_tree\n                    .insert(insertion, insertion)\n                    .expect(format!(\"failed to insert item {:?}\", insertion).as_str());\n            }\n\n            #[cfg(feature = \"testing\")]\n            some_tree.bpm.assert_clean_frame(\u0026[0]);\n\n            let left_most = KeyT { main: -1, sub: 0 };\n            let mut acc = some_tree\n                ._search_leaf(\u0026left_most)\n                .expect(\"unable to search left most leaf\");\n            let left_most_node = acc.pop_next().expect(\"not expect returning none\");\n            let mut cur_page_id = left_most_node.origin.get_page_id();\n            acc.add_flush(left_most_node);\n            some_tree\n                ._return_access_to_bpm(acc)\n                .expect(\"err during flushing access obj\");\n\n            let mut root_latch = some_tree._get_root().expect(\"failed to get root\");\n            let root_branch = root_latch._mapped.data.branch();\n            assert!(\n                case.root_keys\n                    .iter()\n                    .zip(root_branch.keys.iter())\n                    .all(|(a, b)| a == b),\n                \"root keys not match expect {:?} really {:?}\",\n                case.root_keys,\n                root_branch.keys\n            );\n            let st: Vec\u003cOwningHandle\u003cArc\u003cMutex\u003cFrame\u003e\u003e, MutexGuard\u003cFrame\u003e\u003e\u003e =\n                vec![root_latch].into_iter().map(|l| l.origin).collect();\n            some_tree\n                .bpm\n                .batch_unpin_flush(st.into_iter())\n                .expect(\"failed to batch flush root page\");\n            // assert.Equal(t, tc.rootKeys, root.keys[:root.size])\n\n            for (idx, raw_node_val) in case.leaf_vals.iter().enumerate() {\n                let typed_node_val = make_tree_val(*raw_node_val);\n                let mut page_latch = some_tree\n                    ._get_page(cur_page_id)\n                    .expect(format!(\"failed to get page {:?}\", cur_page_id).as_str());\n                let real_node_val = \u0026page_latch._mapped.data.leaf().data;\n                assert!(\n                    typed_node_val\n                        .iter()\n                        .zip(real_node_val.iter())\n                        .all(|(a, b)| a == b),\n                    \"case {:?} failed keys slices are not equal expect {:?} vs real {:?}\",\n                    idx,\n                    typed_node_val,\n                    real_node_val,\n                );\n                cur_page_id = page_latch._mapped.header.next;\n            }\n        }\n    }\n\n    #[test]\n    fn test_bin_search() {\n        let mut keys = vec![];\n        let mut children = vec![-1];\n        for i in 0..10 {\n            keys.push(KeyT { main: i, sub: 0 });\n            children.push(i);\n        }\n        #[derive(Debug)]\n        struct Suite {\n            key: Vec\u003cKeyT\u003e,\n            children: Vec\u003ci64\u003e,\n            search_key: i64,\n            expect_index: usize,\n        }\n        let mut test_case = vec![\n            Suite {\n                key: vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9].into2(),\n                children: vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n                search_key: 0,\n                expect_index: 1,\n            },\n            Suite {\n                key: vec![2].into2(),\n                children: vec![1, 2],\n                search_key: 4,\n                expect_index: 1,\n            },\n        ];\n\n        // vector from 0..9\n\n        // (size of slice, search key, expect index returned)\n        // let suites = vec![(9, 0, 1), (9, -1, 0), (9, 9, 9)];\n        for case in \u0026mut test_case {\n            let keys = \u0026mut case.key;\n            let length = keys.len();\n            let children = \u0026mut case.children;\n            let branch = BranchData {\n                keys: SliceVec::from_slice_len(\u0026mut keys[..], length),\n                children: SliceVec::from_slice_len(\u0026mut children[..], length + 1),\n            };\n            /* let header = PageHeader {\n                is_deleted: false,\n                is_leaf: false,\n                _padding2: [0; 6],\n                level: 0,\n                size: length as i64,\n                next: 0,\n            }; */\n\n            let ret = branch.find_next_child(\u0026KeyT {\n                main: case.search_key,\n                sub: 0,\n            });\n            assert_eq!(case.expect_index, ret, \"failed at item {:?}\", case);\n        }\n    }\n\n    #[test]\n    fn test_cast_header() {\n        let root_page_id = 7;\n        let flags = HEADER_FLAG_INIT;\n        let node_size = 9;\n\n        let mut some_file = tempfile().unwrap();\n        let mut fake_data: [u8; PAGE_SIZE] = [0; PAGE_SIZE];\n        let mut h = HeaderPage::cast(\u0026mut fake_data[..]);\n        h.node_size = node_size;\n        h.flags = flags;\n        h.root_id = root_page_id;\n        some_file.write_all(\u0026mut fake_data[..]).unwrap();\n        some_file.flush().unwrap();\n        some_file.seek(SeekFrom::Start(0)).unwrap();\n\n        let mut new_buf: [u8; PAGE_SIZE] = [0; PAGE_SIZE];\n        some_file.read_exact(\u0026mut new_buf[..]).unwrap();\n        let h2 = HeaderPage::cast(\u0026mut new_buf[..]);\n        assert_eq!(node_size, h2.node_size);\n        assert_eq!(flags, h2.flags);\n        assert_eq!(root_page_id, h2.root_id);\n    }\n\n    #[test]\n    fn test_cast_branch() {\n        let mut some_rng: Box\u003cdyn RngCore\u003e = Box::new(thread_rng());\n        let node_size = 7;\n        let size = 7;\n        let next = 7;\n        let level = 10;\n        let mut some_file = tempfile().unwrap();\n        let mut fake_data: [u8; PAGE_SIZE] = [0; PAGE_SIZE];\n        let mut some_page: NodePage\u003cKeyT, KeyT\u003e =\n            NodePage::cast_branch_from_blank(node_size, \u0026mut fake_data[..]);\n        some_page.header.size = size;\n        some_page.header.level = level;\n        let mut branch_data: BranchData\u003c_\u003e;\n        match some_page.data {\n            PageData::B(branch) =\u003e {\n                assert_eq!(node_size as usize + 1, branch.children.capacity());\n                assert_eq!(node_size as usize, branch.keys.capacity());\n                branch_data = branch;\n            }\n            PageData::L { .. } =\u003e panic!(\"not expect to return leaf variant\"),\n        };\n\n        let mut checked_data = Vec::new(); // clone for further check\n        for i in 0..node_size as usize {\n            let key = KeyT {\n                main: some_rng.gen(),\n                sub: some_rng.gen(),\n            };\n\n            branch_data.keys.push(key);\n            let node_id = some_rng.gen();\n            branch_data.children.push(node_id);\n            checked_data.push((key, node_id));\n        }\n        assert_eq!(PAGE_SIZE, some_file.write(\u0026mut fake_data[..]).unwrap());\n        let mut new_buf: [u8; PAGE_SIZE] = [0; PAGE_SIZE];\n        some_file.seek(SeekFrom::Start(0)).unwrap();\n\n        some_file.read_exact(\u0026mut new_buf[..]).unwrap();\n        let some_page2 = NodePage::\u003cKeyT, KeyT\u003e::cast_generic(node_size, \u0026mut new_buf[..]);\n        some_page2.header.size = size;\n        some_page2.header.next = next;\n        let branch_data2: BranchData\u003c_\u003e;\n        match some_page2.data {\n            PageData::B(branch) =\u003e {\n                assert_eq!(node_size as usize + 1, branch.children.len());\n                assert_eq!(node_size as usize, branch.keys.len());\n                branch_data2 = branch;\n            }\n            PageData::L(_) =\u003e panic!(\"not expect to return leaf variant\"),\n        };\n        assert_eq!(false, some_page2.header.is_leaf);\n        assert_eq!(level, some_page2.header.level);\n\n        assert!(\n            checked_data\n                .iter()\n                .zip(branch_data2.keys.iter())\n                .all(|(a, b)| a.0 == *b),\n            \"Keys slices are not equal\"\n        );\n        assert!(\n            checked_data\n                .iter()\n                .zip(branch_data2.children.iter())\n                .all(|(a, b)| a.1 == *b),\n            \"Children slices are not equal\"\n        );\n    }\n\n    #[test]\n    fn test_cast_leaf() {\n        let mut some_rng: Box\u003cdyn RngCore\u003e = Box::new(thread_rng());\n        let node_size = 7;\n        let size = 7;\n        let next = 7;\n        let level = 10;\n        let mut some_file = tempfile().unwrap();\n        let mut fake_data: [u8; PAGE_SIZE] = [0; PAGE_SIZE];\n        let mut some_page: NodePage\u003cKeyT, KeyT\u003e =\n            NodePage::cast_leaf_from_blank(node_size, \u0026mut fake_data[..]);\n        some_page.header.size = size;\n        some_page.header.next = next;\n        some_page.header.level = level;\n        let mut leaf_data: LeafData\u003c_, _\u003e;\n        match some_page.data {\n            PageData::L(leaf) =\u003e {\n                assert_eq!(node_size as usize, leaf.data.capacity());\n                leaf_data = leaf;\n            }\n            PageData::B { .. } =\u003e panic!(\"not expect to return branch variant\"),\n        };\n\n        let mut checked_data = Vec::new(); // clone for further check\n        for _ in 0..node_size as usize {\n            let key = KeyT {\n                main: some_rng.gen(),\n                sub: some_rng.gen(),\n            };\n            let val = Val { key, val: key };\n            leaf_data.data.push(val);\n            checked_data.push(val);\n        }\n        assert_eq!(PAGE_SIZE, some_file.write(\u0026mut fake_data[..]).unwrap());\n        some_file.flush().unwrap();\n        let mut new_buf: [u8; PAGE_SIZE] = [0; PAGE_SIZE];\n        some_file.seek(SeekFrom::Start(0)).unwrap();\n\n        some_file.read_exact(\u0026mut new_buf[..]).unwrap();\n        let some_page2 = NodePage::\u003cKeyT, KeyT\u003e::cast_generic(node_size, \u0026mut new_buf[..]);\n        some_page2.header.size = size;\n        some_page2.header.next = next;\n        let leaf_data2: LeafData\u003c_, _\u003e;\n        match some_page2.data {\n            PageData::L(leaf) =\u003e {\n                assert_eq!(node_size as usize, leaf.data.len());\n                leaf_data2 = leaf;\n            }\n            PageData::B { .. } =\u003e panic!(\"not expect to return branch variant\"),\n        };\n        assert_eq!(true, some_page2.header.is_leaf);\n        assert_eq!(level, some_page2.header.level);\n\n        assert!(\n            checked_data\n                .iter()\n                .zip(leaf_data2.data.iter())\n                .all(|(a, b)| *a == *b),\n            \"Arrays are not equal\"\n        );\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[688648,685680],"length":1,"stats":{"Line":1},"fn_name":"_split_branch_node\u003cbustubrust::replacer::LRURepl, bustubrust::btree::tests::KeyT, bustubrust::btree::tests::KeyT\u003e"},{"line":198,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[688672,690463],"length":1,"stats":{"Line":2},"fn_name":"_split_leaf_node\u003cbustubrust::replacer::LRURepl, bustubrust::btree::tests::KeyT, bustubrust::btree::tests::KeyT\u003e"},{"line":234,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":385,"address":[701120,706997],"length":1,"stats":{"Line":1},"fn_name":"_try_borrow_cousins_key\u003cbustubrust::replacer::LRURepl, bustubrust::btree::tests::KeyT, bustubrust::btree::tests::KeyT\u003e"},{"line":392,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[714456,711040],"length":1,"stats":{"Line":1},"fn_name":"_merge_node_right_to_left\u003cbustubrust::replacer::LRURepl, bustubrust::btree::tests::KeyT, bustubrust::btree::tests::KeyT\u003e"},{"line":503,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":662,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":674,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":677,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":751,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":752,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":755,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":756,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":768,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":771,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":772,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":775,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":780,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":781,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":782,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":785,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":809,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":810,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":811,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":812,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":820,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":822,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":830,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":831,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":835,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":836,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":838,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":852,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":858,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":859,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":860,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":862,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":901,"address":[478960],"length":1,"stats":{"Line":1},"fn_name":"cast"},{"line":902,"address":[478994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":949,"address":[906320,906690],"length":1,"stats":{"Line":2},"fn_name":"fmt"},{"line":950,"address":[906348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":954,"address":[906736],"length":1,"stats":{"Line":1},"fn_name":"into"},{"line":963,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":964,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":971,"address":[907023,906784],"length":1,"stats":{"Line":1},"fn_name":"make_tree_key"},{"line":972,"address":[906824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":973,"address":[906839,906914,906974],"length":1,"stats":{"Line":5},"fn_name":null},{"line":974,"address":[906987],"length":1,"stats":{"Line":2},"fn_name":null},{"line":978,"address":[907319,907040],"length":1,"stats":{"Line":1},"fn_name":"make_tree_val"},{"line":979,"address":[907086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":980,"address":[907182,907242,907101],"length":1,"stats":{"Line":3},"fn_name":null},{"line":982,"address":[907255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":985,"address":[907282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":986,"address":[907272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":992,"address":[907344,907631],"length":1,"stats":{"Line":1},"fn_name":"sequential_until"},{"line":993,"address":[907377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":994,"address":[907567,907397,907458],"length":1,"stats":{"Line":3},"fn_name":null},{"line":995,"address":[907583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":999,"address":[907648,907959],"length":1,"stats":{"Line":1},"fn_name":"inverted_sequential_until"},{"line":1000,"address":[907681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1001,"address":[907895,907701,907772],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1002,"address":[907911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1008,"address":[908736,913941],"length":1,"stats":{"Line":3},"fn_name":"test_delete"},{"line":1009,"address":[908749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1010,"address":[908834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1018,"address":[910590,911868,909461,913667,908846,910019,908936,911213,913064,912477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1019,"address":[909276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1021,"address":[908898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1022,"address":[909056,908910,908976],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1023,"address":[909063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1024,"address":[909160,909100],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1026,"address":[909836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1028,"address":[909429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1029,"address":[909509,909597,909446],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1030,"address":[909609,909718],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1031,"address":[909735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1033,"address":[910405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1035,"address":[909989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1036,"address":[910067,910001,910147],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1037,"address":[910159,910268],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1038,"address":[910285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1040,"address":[911030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1042,"address":[910558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1043,"address":[910575,910638,910734],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1044,"address":[910746,910855],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1045,"address":[910872],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1047,"address":[911685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1049,"address":[911183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1050,"address":[911261,911341,911195],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1051,"address":[911358,911472],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1052,"address":[911489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1054,"address":[912292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1056,"address":[911838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1057,"address":[911996,911916,911850],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1058,"address":[912008,912117],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1059,"address":[912134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1061,"address":[912879],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1063,"address":[912445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1064,"address":[912525,912621,912462],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1065,"address":[912633,912742],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1066,"address":[912759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1068,"address":[913463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1070,"address":[913032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1071,"address":[913216,913112,913049],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1072,"address":[913337,913228],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1073,"address":[913354],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1076,"address":[920719,913956,920642],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1077,"address":[914419,914323],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1078,"address":[914447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1079,"address":[914562,914462],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1080,"address":[914594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1082,"address":[914799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1085,"address":[915097,914912],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1086,"address":[915542,915242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1087,"address":[915210,915255],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1088,"address":[915572,915271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1090,"address":[915670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1091,"address":[916255,915961],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1092,"address":[915929,915968],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1093,"address":[915984,916285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1096,"address":[916383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1098,"address":[916410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1099,"address":[916458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1102,"address":[916621,916531],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1103,"address":[916721,916637],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1104,"address":[916729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1105,"address":[916926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1106,"address":[916856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1109,"address":[916983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1110,"address":[917040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1112,"address":[917080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1113,"address":[917450,917500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1114,"address":[917414,917119,917207],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1116,"address":[917351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1117,"address":[964880,964925],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":1119,"address":[917492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1124,"address":[917795,917054],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1125,"address":[918120,918093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1126,"address":[917803,918057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1128,"address":[917994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1129,"address":[964979,964960],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":1131,"address":[918112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1147,"address":[917466,918416],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1149,"address":[918680,918775],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1151,"address":[918696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1155,"address":[918816,919118],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1156,"address":[919150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1157,"address":[919196,919531],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1158,"address":[919203,919172],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1159,"address":[919333,919219,919569],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1160,"address":[919664,919735],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1161,"address":[919997,920049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1162,"address":[919967,919751],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1164,"address":[919839,919922],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1165,"address":[965040,965059],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}"},{"line":1171,"address":[920003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1176,"address":[907984],"length":1,"stats":{"Line":1},"fn_name":"_check_deadlock"},{"line":1185,"address":[907988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1186,"address":[963463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1187,"address":[963509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1188,"address":[963530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1192,"address":[963648,963606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1193,"address":[963822,964093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1194,"address":[964138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1195,"address":[964287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1196,"address":[964413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1197,"address":[964620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1205,"address":[920768,923687],"length":1,"stats":{"Line":3},"fn_name":"test_insert"},{"line":1206,"address":[920781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1213,"address":[922098,921324,922996,921683,923479,920951,920857,922578],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1214,"address":[921169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1216,"address":[920909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1217,"address":[920916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1218,"address":[920993,921053],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1220,"address":[921528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1222,"address":[921290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1223,"address":[921297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1224,"address":[921434,921374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1226,"address":[921947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1228,"address":[921649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1229,"address":[921656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1230,"address":[921793,921733],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1232,"address":[922420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1234,"address":[922068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1235,"address":[922226,922146,922080],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1236,"address":[922243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1238,"address":[922843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1240,"address":[922528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1241,"address":[922626,922706,922560],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1242,"address":[922723],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1244,"address":[923323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1246,"address":[922964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1247,"address":[923140,923044,922981],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1248,"address":[923157],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1251,"address":[928951,929020,923702],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1252,"address":[924029,924125],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1253,"address":[924153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1254,"address":[924168,924268],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1255,"address":[924300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1257,"address":[924505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1260,"address":[924618,924803],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1261,"address":[924948,925248],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1262,"address":[924916,924961],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1263,"address":[924977,925278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1267,"address":[925376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1269,"address":[925403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1270,"address":[925451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1273,"address":[925524,925614],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1274,"address":[925630,925714],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1275,"address":[925722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1276,"address":[925919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1277,"address":[925849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1280,"address":[925976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1281,"address":[926033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1282,"address":[926403,926453],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1283,"address":[926072,926367,926160],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1285,"address":[926304],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1286,"address":[965136,965155],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":1288,"address":[926445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1291,"address":[926748,926419],"length":1,"stats":{"Line":4},"fn_name":null},{"line":1293,"address":[927107,927012],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1295,"address":[927028],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1299,"address":[927450,927148],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1300,"address":[927482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1301,"address":[927863,927528],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1302,"address":[927504,927535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1303,"address":[927901,927551,927665],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1304,"address":[928067,927996],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1305,"address":[928335,928387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1306,"address":[928083,928305],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1308,"address":[928260,928171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1309,"address":[965216,965235],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":1315,"address":[928341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1321,"address":[931356,929056],"length":1,"stats":{"Line":3},"fn_name":"test_bin_search"},{"line":1322,"address":[929063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1323,"address":[929081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1324,"address":[929319,929418,929174],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1325,"address":[929442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1326,"address":[929509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1335,"address":[929403,930058,930325,929677],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1336,"address":[929912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1337,"address":[929547,929725],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1338,"address":[929742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1342,"address":[930237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1343,"address":[930005,930114],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1344,"address":[930131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1354,"address":[930547,930448,930615],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1355,"address":[930631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1356,"address":[930652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1357,"address":[930682],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1359,"address":[930707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1360,"address":[930766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1371,"address":[930949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1372,"address":[930937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1375,"address":[931010],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1380,"address":[933125,931792],"length":1,"stats":{"Line":3},"fn_name":"test_cast_header"},{"line":1381,"address":[931805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1382,"address":[931817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1383,"address":[931829],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1385,"address":[931841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1386,"address":[931912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1387,"address":[932032,931922],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1388,"address":[932040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1389,"address":[932052],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1390,"address":[932063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1391,"address":[932075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1392,"address":[932242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1393,"address":[932349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1395,"address":[932465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1396,"address":[932472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1397,"address":[932603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1398,"address":[932670,932857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1399,"address":[932760,933005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1400,"address":[933078,932908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1404,"address":[933152,938191],"length":1,"stats":{"Line":3},"fn_name":"test_cast_branch"},{"line":1405,"address":[933165,933311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1406,"address":[933334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1407,"address":[933346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1408,"address":[933358],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1409,"address":[933370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1410,"address":[933382,933477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1411,"address":[933514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1412,"address":[933524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1414,"address":[933631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1415,"address":[933647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1417,"address":[933667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1418,"address":[933686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1419,"address":[933786,934035,933832,933720],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1420,"address":[934094,934324,933973],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1421,"address":[934197],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1423,"address":[933746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1426,"address":[934301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1427,"address":[934375,934580,934707],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1429,"address":[934731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1430,"address":[934754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1433,"address":[934801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1434,"address":[935319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1435,"address":[935350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1436,"address":[935817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1438,"address":[935901,934666,936175],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1439,"address":[936090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1440,"address":[936226,936092],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1442,"address":[936248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1443,"address":[936411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1444,"address":[936485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1445,"address":[936501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1447,"address":[936517],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1448,"address":[936536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1449,"address":[936570,936637,936683,936889],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1450,"address":[936948,936827,937270],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1451,"address":[937055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1453,"address":[936596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1455,"address":[937151,937438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1456,"address":[937532,937321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1458,"address":[937827,937858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1459,"address":[937797,937493,937595],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1461,"address":[937749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1462,"address":[965376,965421],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":1465,"address":[938124,938103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1466,"address":[938073,937841,937901],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1468,"address":[938028,937938],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1469,"address":[965456,965474],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":1475,"address":[942059,938240],"length":1,"stats":{"Line":3},"fn_name":"test_cast_leaf"},{"line":1476,"address":[938399,938253],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1477,"address":[938422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1478,"address":[938434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1479,"address":[938446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1480,"address":[938458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1481,"address":[938565,938470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1482,"address":[938602],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1483,"address":[938612],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1485,"address":[938719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1486,"address":[938735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1487,"address":[938751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1489,"address":[938771],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1490,"address":[938823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1491,"address":[938871,938923,939121],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1492,"address":[939026],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1494,"address":[938790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1497,"address":[939098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1498,"address":[939344,939171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1500,"address":[939479],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1501,"address":[939502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1503,"address":[939549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1504,"address":[939613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1505,"address":[940227],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1507,"address":[940303,940521,939430],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1508,"address":[940470,940588],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1509,"address":[940672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1510,"address":[940674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1512,"address":[940763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1513,"address":[940926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1514,"address":[941000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1515,"address":[941016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1517,"address":[941032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1518,"address":[941084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1519,"address":[941184,941132,941468],"length":1,"stats":{"Line":2},"fn_name":null},{"line":1520,"address":[941291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1522,"address":[941051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1524,"address":[941355,941624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1525,"address":[941519,941706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1527,"address":[941965,941986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1528,"address":[941763,941935,941679],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1530,"address":[941890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1531,"address":[965552,965597],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"}],"covered":750,"coverable":818},{"path":["/","var","www","rust","bustubrust","src","cc.rs"],"content":"/* use crate::lazy::Lazy;\nuse parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};\n#[cfg(feature = \"testing\")]\nuse std::cell::RefCell;\nuse std::sync::atomic::{\n    AtomicBool, AtomicUsize,\n    Ordering::{Acquire, Release, SeqCst},\n};\n\nuse super::*;\n\n#[cfg(feature = \"testing\")]\nthread_local! {\n    pub static COUNT: RefCell\u003cu32\u003e = RefCell::new(0);\n}\n\nconst RW_REQUIRED_BIT: usize = 1 \u003c\u003c 31;\n\n#[derive(Default)]\npub(crate) struct ConcurrencyControl {\n    active: AtomicUsize,\n    upgrade_complete: AtomicBool,\n    rw: RwLock\u003c()\u003e,\n}\n\nstatic CONCURRENCY_CONTROL: Lazy\u003cConcurrencyControl, fn() -\u003e ConcurrencyControl\u003e =\n    Lazy::new(init_cc);\n\nfn init_cc() -\u003e ConcurrencyControl {\n    ConcurrencyControl::default()\n}\n\n#[derive(Debug)]\n#[must_use]\npub(crate) enum Protector\u003c'a\u003e {\n    Write(RwLockWriteGuard\u003c'a, ()\u003e),\n    Read(RwLockReadGuard\u003c'a, ()\u003e),\n    None(\u0026'a AtomicUsize),\n}\n\nimpl\u003c'a\u003e Drop for Protector\u003c'a\u003e {\n    fn drop(\u0026mut self) {\n        println!(\"dropping\");\n        if let Protector::None(active) = self {\n            active.fetch_sub(1, Release);\n        }\n        #[cfg(feature = \"testing\")]\n        COUNT.with(|c| {\n            let mut c = c.borrow_mut();\n            *c -= 1;\n            assert_eq!(*c, 0);\n        });\n    }\n}\n\npub(crate) fn read\u003c'a\u003e() -\u003e Protector\u003c'a\u003e {\n    CONCURRENCY_CONTROL.read()\n}\n\npub(crate) fn write\u003c'a\u003e() -\u003e Protector\u003c'a\u003e {\n    CONCURRENCY_CONTROL.write()\n}\n\nimpl ConcurrencyControl {\n    fn enable(\u0026self) {\n        if self.active.fetch_or(RW_REQUIRED_BIT, SeqCst) \u003c RW_REQUIRED_BIT {\n            // we are the first to set this bit\n            while self.active.load(Acquire) != RW_REQUIRED_BIT {\n                // `hint::spin_loop` requires Rust 1.49.\n                #[allow(deprecated)]\n                std::sync::atomic::spin_loop_hint()\n            }\n            self.upgrade_complete.store(true, Release);\n        }\n    }\n\n    fn read(\u0026self) -\u003e Protector\u003c'_\u003e {\n        #[cfg(feature = \"testing\")]\n        COUNT.with(|c| {\n            let mut c = c.borrow_mut();\n            *c += 1;\n            assert_eq!(*c, 1);\n        });\n\n        let active = self.active.fetch_add(1, Release);\n\n        if active \u003e= RW_REQUIRED_BIT {\n            self.active.fetch_sub(1, Release);\n            Protector::Read(self.rw.read())\n        } else {\n            Protector::None(\u0026self.active)\n        }\n    }\n\n    fn write(\u0026self) -\u003e Protector\u003c'_\u003e {\n        #[cfg(feature = \"testing\")]\n        COUNT.with(|c| {\n            let mut c = c.borrow_mut();\n            *c += 1;\n            assert_eq!(*c, 1);\n        });\n        self.enable();\n        while !self.upgrade_complete.load(Acquire) {\n            // `hint::spin_loop` requires Rust 1.49.\n            #[allow(deprecated)]\n            std::sync::atomic::spin_loop_hint()\n        }\n        Protector::Write(self.rw.write())\n    }\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use parking_lot::Mutex;\n\n    #[test]\n    fn test_something() {\n        println!(\"here\");\n        let _cc = read();\n        println!(\"here\");\n        let st = Mutex::new(1);\n    }\n} */\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","error.rs"],"content":"use serde_derive::{Deserialize, Serialize};\nuse std::fmt::{self, Display};\n\n/// Result returning Error\npub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n\n/// toyDB errors. All except Internal are considered user-facing.\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub enum Error {\n    Abort,\n    Config(String),\n    Internal(String),\n    Parse(String),\n    ReadOnly,\n    Serialization,\n    Value(String),\n}\n\nimpl std::error::Error for Error {}\n\nimpl Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            Error::Config(s) | Error::Internal(s) | Error::Parse(s) | Error::Value(s) =\u003e {\n                write!(f, \"{}\", s)\n            }\n            Error::Abort =\u003e write!(f, \"Operation aborted\"),\n            Error::Serialization =\u003e write!(f, \"Serialization failure, retry transaction\"),\n            Error::ReadOnly =\u003e write!(f, \"Read-only transaction\"),\n        }\n    }\n}\n\nimpl From\u003cstd::array::TryFromSliceError\u003e for Error {\n    fn from(err: std::array::TryFromSliceError) -\u003e Self {\n        Error::Internal(err.to_string())\n    }\n}\n\nimpl From\u003cstd::io::Error\u003e for Error {\n    fn from(err: std::io::Error) -\u003e Self {\n        Error::Internal(err.to_string())\n    }\n}\n\nimpl From\u003cstd::net::AddrParseError\u003e for Error {\n    fn from(err: std::net::AddrParseError) -\u003e Self {\n        Error::Internal(err.to_string())\n    }\n}\n\nimpl From\u003cstd::num::ParseFloatError\u003e for Error {\n    fn from(err: std::num::ParseFloatError) -\u003e Self {\n        Error::Parse(err.to_string())\n    }\n}\n\nimpl From\u003cstd::num::ParseIntError\u003e for Error {\n    fn from(err: std::num::ParseIntError) -\u003e Self {\n        Error::Parse(err.to_string())\n    }\n}\n\nimpl From\u003cstd::string::FromUtf8Error\u003e for Error {\n    fn from(err: std::string::FromUtf8Error) -\u003e Self {\n        Error::Internal(err.to_string())\n    }\n}\n\nimpl\u003cT\u003e From\u003cstd::sync::PoisonError\u003cT\u003e\u003e for Error {\n    fn from(err: std::sync::PoisonError\u003cT\u003e) -\u003e Self {\n        Error::Internal(err.to_string())\n    }\n}\n","traces":[{"line":22,"address":[465648],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":23,"address":[465681,465784,465800,465768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[465759,465791,465888,465775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[466029,465897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[465712,466099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[465955,465844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[465997,465802],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[466128],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":36,"address":[466142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[466338,466208],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":42,"address":[466251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[466368],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":48,"address":[466382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[466448],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":54,"address":[466471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[466544],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":60,"address":[466565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[466640,466750],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":66,"address":[466664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","var","www","rust","bustubrust","src","join","grace.rs"],"content":"#[allow(dead_code)]\nuse core::fmt::Formatter;\nuse std::collections::HashMap;\nuse std::fmt::Debug;\nuse std::rc::Rc;\nuse twox_hash::xxh3::hash64_with_seed;\n\nstruct HashJoiner {\n    outer_queue: Rc\u003cdyn PartitionedQueue\u003e,\n    inner_queue: Rc\u003cdyn PartitionedQueue\u003e,\n    p_index: usize,\n    batch_size: usize,\n    built: bool,\n    htable: HashMap\u003cVec\u003cu8\u003e, Vec\u003cRow\u003e\u003e,\n    left_key_offset: usize,\n    right_key_offset: usize,\n    // unfinished_batch: Option\u003cVec\u003cRow\u003e\u003e,\n}\nimpl HashJoiner {\n    pub fn new(\n        outer_queue: Rc\u003cdyn PartitionedQueue\u003e,\n        inner_queue: Rc\u003cdyn PartitionedQueue\u003e,\n        p_index: usize,\n        batch_size: usize,\n        left_key_offset: usize,\n        right_key_offset: usize,\n    ) -\u003e Self {\n        HashJoiner {\n            outer_queue,\n            inner_queue,\n            p_index,\n            batch_size,\n            left_key_offset,\n            right_key_offset,\n            built: false,\n            htable: HashMap::new(),\n        }\n    }\n}\n\n// TODO: add fallback to merge join, if partition contain duplicate joined rows count\n// that takes more than inmem partition\nstruct GraceHashJoiner\u003cF\u003e\nwhere\n    F: Fn() -\u003e Rc\u003cdyn PartitionedQueue\u003e,\n{\n    config: Config,\n    stack: Vec\u003cPartitionLevel\u003e,\n    undone_joining_partition: Option\u003cHashJoiner\u003e,\n    queue_allocator: F,\n}\nstruct PartitionLevel {\n    level: usize,\n    map: HashMap\u003cusize, PInfo\u003e,\n    outer_queue: Rc\u003cdyn PartitionedQueue\u003e,\n    inner_queue: Rc\u003cdyn PartitionedQueue\u003e,\n}\n\npub trait PartitionedQueue {\n    fn enqueue(\u0026self, partition_idx: usize, data: Vec\u003cRow\u003e);\n    fn dequeue(\u0026self, partition_idx: usize, size: usize) -\u003e Option\u003cBatch\u003e;\n    fn id(\u0026self) -\u003e usize;\n}\n\nstruct PInfo {\n    parent_size: usize,\n    memsize: usize,\n}\npub struct Batch {\n    inner: Vec\u003cRow\u003e,\n}\nimpl Debug for Batch {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result\u003c(), std::fmt::Error\u003e {\n        let st = self\n            .inner\n            .iter()\n            .map(|row| row.string_data(8))\n            .collect::\u003cVec\u003cString\u003e\u003e()\n            .join(\",\");\n\n        f.write_str(\"{\")?;\n        f.write_str(\u0026st)?;\n        f.write_str(\"}\")?;\n        Ok(())\n    }\n}\nimpl Debug for Row {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result\u003c(), std::fmt::Error\u003e {\n        f.write_str(\u0026self.string_data(8))\n    }\n}\nimpl Batch {\n    pub fn new(r: Vec\u003cRow\u003e) -\u003e Self {\n        Batch { inner: r }\n    }\n    pub fn data(\u0026self) -\u003e \u0026Vec\u003cRow\u003e {\n        \u0026self.inner\n    }\n}\n\n#[derive(Clone)]\npub struct Row {\n    pub inner: Vec\u003cu8\u003e,\n}\nimpl Row {\n    fn new(inner: Vec\u003cu8\u003e) -\u003e Self {\n        Row { inner }\n    }\n    pub fn string_data(\u0026self, key_offset: usize) -\u003e String {\n        String::from_utf8(self.inner[key_offset..].to_vec()).unwrap()\n    }\n}\n\nimpl HashJoiner {\n    /* fn left_joined_key\u003c'a\u003e(self, r: \u0026'a Row) -\u003e \u0026'a [u8] {\n        \u0026r.inner[..self.left_key_offset]\n    } */\n    fn joined_key\u003c'a\u003e(key_offset: usize, r: \u0026'a Row) -\u003e \u0026'a [u8] {\n        \u0026r.inner[..key_offset]\n    }\n    fn joined_data\u003c'a\u003e(key_offset: usize, r: \u0026'a Row) -\u003e \u0026'a [u8] {\n        \u0026r.inner[key_offset..]\n    }\n\n    fn _build(\u0026mut self) {\n        let htable = \u0026mut self.htable;\n\n        while let Some(batch) = self.inner_queue.dequeue(self.p_index, self.batch_size) {\n            for item in batch.inner {\n                let key = Self::joined_key(self.right_key_offset, \u0026item);\n                match htable.get_mut(key) {\n                    Some(datas) =\u003e {\n                        datas.push(item);\n                    }\n                    None =\u003e {\n                        htable.insert(key.to_vec(), vec![item]);\n                    }\n                }\n            }\n        }\n        self.built = true;\n    }\n\n    fn next(\u0026mut self) -\u003e Option\u003cBatch\u003e {\n        if !self.built {\n            self._build();\n        }\n\n        let mut ret = Vec::new();\n\n        while let Some(outer_batch) = self.outer_queue.dequeue(self.p_index, self.batch_size) {\n            for (idx, item) in outer_batch.inner.iter().enumerate() {\n                let joined_key = Self::joined_key(self.left_key_offset, \u0026item);\n                match self\n                    .htable\n                    .get(Self::joined_key(self.left_key_offset, \u0026item))\n                {\n                    None =\u003e {\n                        continue;\n                    }\n                    Some(inner_matches) =\u003e {\n                        for inner_match in inner_matches {\n                            let mut joined_row = item.clone();\n                            let inner_data = Self::joined_data(self.right_key_offset, \u0026inner_match);\n                            joined_row.inner.extend(inner_data);\n                            ret.push(joined_row);\n                        }\n                        // TODO need to check batch_size\n                        // return all here for now\n                        // if ret.len() == self.batch_size {\n                        // self.unfinished_batch = Some(ret);\n                        // return Some(Batch::new(ret));\n                        // }\n                    }\n                }\n            }\n        }\n        if ret.len() \u003e 0 {\n            return Some(Batch::new(ret));\n        }\n        return None;\n    }\n}\n\n#[derive(Copy, Clone)]\nstruct Config {\n    bucket_size: usize,\n    max_size_per_partition: usize,\n    batch_size: usize,\n    left_key_offset: usize,\n    right_key_offset: usize,\n}\n\nimpl\u003cF\u003e GraceHashJoiner\u003cF\u003e\nwhere\n    F: Fn() -\u003e Rc\u003cdyn PartitionedQueue\u003e,\n{\n    fn partition_batch(b: Batch, partition_infos: \u0026mut PartitionLevel, c: Config, is_inner: bool) {\n        let mut hash_result: Vec\u003cVec\u003cRow\u003e\u003e = Vec::new();\n        for _ in 0..c.bucket_size {\n            hash_result.push(Vec::new())\n        }\n        let queuer = match is_inner {\n            true =\u003e \u0026partition_infos.inner_queue,\n            false =\u003e \u0026partition_infos.outer_queue,\n        };\n\n        let key_offset = match is_inner {\n            true =\u003e c.right_key_offset,\n            false =\u003e c.left_key_offset,\n        };\n\n        let this_level = partition_infos.level;\n\n        for item in b.inner {\n            let h = Self::hash(\n                Self::get_key(key_offset, \u0026item),\n                c.bucket_size as u64,\n                this_level as u64,\n            );\n            hash_result[h].push(item);\n        }\n\n        for (partition_idx, same_buckets) in hash_result.into_iter().enumerate() {\n            let bucket_length = same_buckets.len();\n\n            queuer.enqueue(partition_idx, same_buckets);\n\n            // only care about inner input\n            if is_inner {\n                match partition_infos.map.get_mut(\u0026partition_idx) {\n                    None =\u003e {\n                        partition_infos.map.insert(\n                            partition_idx,\n                            PInfo {\n                                memsize: bucket_length,\n                                parent_size: 0,\n                            },\n                        );\n                    }\n                    Some(info) =\u003e {\n                        info.memsize += bucket_length;\n                    }\n                };\n            }\n        }\n    }\n\n    fn _find_next_inmem_sized_partition(\n        \u0026mut self,\n        max_size_per_partition: usize,\n    ) -\u003e Option\u003c(\n        usize,\n        PInfo,\n        Rc\u003cdyn PartitionedQueue\u003e,\n        Rc\u003cdyn PartitionedQueue\u003e,\n    )\u003e {\n        let mut found_index = None;\n        let partition_infos = self.stack.last_mut().unwrap();\n        for (index, item) in partition_infos.map.iter_mut() {\n            if item.memsize \u003c= max_size_per_partition {\n                found_index = Some(*index);\n                break;\n            }\n        }\n        match found_index {\n            None =\u003e None,\n            Some(index) =\u003e Some((\n                index,\n                partition_infos.map.remove(\u0026index).unwrap(),\n                partition_infos.outer_queue.clone(),\n                partition_infos.inner_queue.clone(),\n            )),\n        }\n    }\n\n    fn _new_hash_joiner(\n        \u0026self,\n        p_index: usize,\n        outer_queue: Rc\u003cdyn PartitionedQueue\u003e,\n        inner_queue: Rc\u003cdyn PartitionedQueue\u003e,\n    ) -\u003e HashJoiner {\n        let st = HashJoiner {\n            batch_size: self.config.batch_size,\n            htable: HashMap::new(),\n            outer_queue,\n            inner_queue,\n            built: false,\n            p_index,\n            left_key_offset: self.config.left_key_offset,\n            right_key_offset: self.config.right_key_offset,\n        };\n        return st;\n    }\n\n    fn next(\u0026mut self) -\u003e Option\u003cBatch\u003e {\n        if let Some(inmem_joiner) = \u0026mut self.undone_joining_partition {\n            match inmem_joiner.next() {\n                None =\u003e {\n                    self.undone_joining_partition = None;\n                }\n                Some(batch_result) =\u003e {\n                    return Some(batch_result);\n                }\n            };\n        };\n\n        'recursiveloop: while self.stack.len() \u003e 0 {\n            while let Some((p_index, _, outer_queue, inner_queue)) =\n                self._find_next_inmem_sized_partition(self.config.max_size_per_partition)\n            {\n                let mut inmem_joiner = self._new_hash_joiner(p_index, outer_queue, inner_queue);\n                match inmem_joiner.next() {\n                    None =\u003e {\n                        self.undone_joining_partition = None;\n                        continue;\n                    }\n                    Some(batch_result) =\u003e {\n                        self.undone_joining_partition = Some(inmem_joiner);\n                        return Some(batch_result);\n                    }\n                }\n            }\n\n            let cur_partitions = self.stack.last_mut().unwrap();\n\n            // recursive partition\n            if cur_partitions.map.len() \u003e 0 {\n                // let st = cur_partitions.last_mut();\n                if let Some(next_recursive_p) =\n                    Self::recursive_partition(\u0026self.queue_allocator, self.config, cur_partitions)\n                {\n                    self.stack.push(next_recursive_p);\n                    continue 'recursiveloop;\n                }\n            }\n            self.stack.pop();\n        }\n        None\n\n        // Find next partition that we can process without having to\n        // recursively repartition.\n    }\n    fn recursive_partition(\n        queue_allocator: \u0026F,\n        config: Config,\n        current_partition: \u0026mut PartitionLevel,\n    ) -\u003e Option\u003cPartitionLevel\u003e {\n        // let cur_partitions = self.stack.last_mut().unwrap();\n        let mut ret = None;\n        let mut item_remove = -1;\n        for (parent_p_index, _) in current_partition.map.iter_mut() {\n            let child_partitions = HashMap::new();\n\n            let new_outer_queue = queue_allocator();\n            let new_inner_queue = queue_allocator();\n            let mut new_level = PartitionLevel {\n                map: child_partitions,\n                inner_queue: new_inner_queue,\n                outer_queue: new_outer_queue,\n                level: current_partition.level + 1,\n            };\n            while let Some(batch) = current_partition\n                .outer_queue\n                .dequeue(*parent_p_index, config.batch_size)\n            {\n                Self::partition_batch(batch, \u0026mut new_level, config, false);\n            }\n            while let Some(batch) = current_partition\n                .inner_queue\n                .dequeue(*parent_p_index, config.batch_size)\n            {\n                Self::partition_batch(batch, \u0026mut new_level, config, true);\n            }\n\n            ret = Some(new_level);\n            item_remove = *parent_p_index as i64;\n        }\n        if item_remove != -1 {\n            current_partition.map.remove(\u0026(item_remove as usize));\n        }\n        ret\n    }\n    // we track if there exists a bucket with length \u003e max-size per partition\n    fn new(\n        c: Config,\n        mut left: impl Iterator\u003cItem = Batch\u003e,\n        mut right: impl Iterator\u003cItem = Batch\u003e,\n        queue_allocator: F,\n    ) -\u003e Self {\n        let outer_queue = queue_allocator();\n        let inner_queue = queue_allocator();\n        let mut joiner = GraceHashJoiner {\n            config: c,\n            stack: Vec::new(),\n            undone_joining_partition: None,\n            queue_allocator,\n        };\n\n        let mut map = HashMap::new();\n        let mut first_level_partitions = PartitionLevel {\n            map,\n            outer_queue,\n            inner_queue,\n            level: 0,\n        };\n        'until_drain_all: loop {\n            match left.next() {\n                Some(left_batch) =\u003e {\n                    Self::partition_batch(\n                        // \u0026outer_queue,\n                        left_batch,\n                        \u0026mut first_level_partitions,\n                        joiner.config,\n                        false,\n                    );\n                    match right.next() {\n                        Some(right_batch) =\u003e {\n                            Self::partition_batch(\n                                // \u0026inner_queue,\n                                right_batch,\n                                \u0026mut first_level_partitions,\n                                joiner.config,\n                                true,\n                            );\n                        }\n                        None =\u003e {}\n                    };\n                }\n                None =\u003e {\n                    match right.next() {\n                        Some(right_batch) =\u003e {\n                            Self::partition_batch(\n                                // \u0026inner_queue,\n                                right_batch,\n                                \u0026mut first_level_partitions,\n                                joiner.config,\n                                true,\n                            );\n                        }\n                        None =\u003e break 'until_drain_all,\n                    };\n                }\n            };\n        }\n\n        joiner.stack.push(first_level_partitions);\n        return joiner;\n    }\n\n    fn hash(bytes: \u0026[u8], bucket_size: u64, seed: u64) -\u003e usize {\n        let ret = hash64_with_seed(bytes, seed);\n        return (ret % bucket_size) as usize;\n    }\n    fn get_key\u003c'a\u003e(key_offset: usize, r: \u0026'a Row) -\u003e \u0026'a [u8] {\n        \u0026r.inner[..key_offset]\n    }\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::{Config, GraceHashJoiner, HashJoiner, PartitionedQueue, Row};\n    use crate::join::grace::Batch;\n    use crate::join::queue::{Inmem, MemoryAllocator};\n    use core::cell::RefCell;\n    use itertools::Itertools;\n    use std::cmp::Ordering::{self, Equal};\n    use std::rc::Rc;\n    use zerocopy::{AsBytes, FromBytes};\n\n    fn make_i64s_row(item: (i64, \u0026[u8])) -\u003e Row {\n        let mut vec = Vec::new();\n        vec.extend(item.0.to_le_bytes());\n        vec.extend(item.1);\n        Row::new(vec)\n    }\n\n    macro_rules! make_rows {\n        // Base case:\n        ($a:expr,$b:expr) =\u003e {{\n            vec![($a, $b)]\n        }};\n        ($a:expr,$b:expr,$($rest:expr),*) =\u003e {{\n            [vec![($a,$b)],make_rows!($($rest),*)].concat()\n        }};\n    }\n\n    struct RowType(i64, Vec\u003cu8\u003e);\n    #[test]\n    fn test_grace_h_joiner() {\n        struct TestCase {\n            outer: Vec\u003c(i64, \u0026'static str)\u003e,\n            inner: Vec\u003c(i64, \u0026'static str)\u003e,\n            expect: Vec\u003c(i64, \u0026'static str)\u003e,\n        }\n        // we expect the inner to be hashed, so we can't guarantee order of the rows returned\n        let tcases = vec![\n            TestCase {\n                outer: make_rows!(1, \"a1\", 2, \"b1\", 1, \"c1\"),\n                inner: make_rows!(1, \"a2\", 2, \"b2\"),\n                expect: make_rows!(1, \"a1a2\", 2, \"b1b2\", 1, \"c1a2\"),\n            },\n            TestCase {\n                outer: make_rows!(1, \"a1\", 2, \"b1\", 1, \"c1\"),\n                inner: make_rows!(1, \"a2\", 2, \"b2\", 1, \"a3\", 3, \"c2\"),\n                expect: make_rows!(1, \"a1a2\", 2, \"b1b2\", 1, \"c1a2\", 1, \"a1a3\", 1, \"c1a3\"),\n            },\n            TestCase {\n                outer: make_rows!(1, \"a1\", 2, \"b1\", 1, \"c1\"),\n                inner: make_rows!(1, \"a2\", 2, \"b2\", 1, \"a3\", 3, \"c2\", 3, \"c2\", 2, \"b2\"),\n                expect: make_rows!(\n                    1, \"a1a2\", 2, \"b1b2\", 1, \"c1a2\", 1, \"a1a3\", 1, \"c1a3\", 2, \"b1b2\"\n                ),\n            },\n        ];\n        for item in \u0026tcases {\n            let batch_size = 2;\n            let left_key_offset = 8; // first 8 bytes represents join key\n            let right_key_offset = 8;\n\n            let mut outer_batches = Vec::new();\n            for chunk in \u0026item.outer.iter().chunks(batch_size) {\n                let mut rows = Vec::new();\n                for item in chunk {\n                    rows.push(make_i64s_row((item.0, item.1.as_bytes())));\n                }\n                outer_batches.push(Batch::new(rows));\n            }\n            let mut inner_batches = Vec::new();\n            for chunk in \u0026item.inner.iter().chunks(batch_size) {\n                let mut rows = Vec::new();\n                for item in chunk {\n                    rows.push(make_i64s_row((item.0, item.1.as_bytes())));\n                }\n                inner_batches.push(Batch::new(rows));\n            }\n            let alloc = RefCell::new(MemoryAllocator::new());\n\n            let config = Config {\n                bucket_size: 2,\n                max_size_per_partition: 2,\n                batch_size: 2,\n                left_key_offset,\n                right_key_offset,\n            };\n            let mut joiner = GraceHashJoiner::new(\n                config,\n                outer_batches.into_iter(),\n                inner_batches.into_iter(),\n                || -\u003e Rc\u003cdyn PartitionedQueue\u003e { alloc.borrow_mut().alloc() },\n            );\n            let mut ret: Vec\u003c(i64, Vec\u003cu8\u003e)\u003e = Vec::new();\n            // joined result should be 1,1|1,1|1,1|1,1\n            while let Some(b) = joiner.next() {\n                for row in b.data() {\n                    let joined_key = FromBytes::read_from(\u0026row.inner[..8]).unwrap();\n                    let other_data = row.inner[8..].to_vec();\n                    // let other_data = FromBytes::read_from(\u0026row.inner[8..]).unwrap();\n                    ret.push((joined_key, other_data));\n                }\n            }\n            // let expect = [[1, 1], [1, 1], [1, 1], [1, 1]];\n            ret.sort_by(|a, b| cmp_row(a, b));\n            let mut expect: Vec\u003c(i64, Vec\u003cu8\u003e)\u003e = item\n                .expect\n                .iter()\n                .map(|item| (item.0, item.1.as_bytes().to_vec()))\n                .collect();\n            expect.sort_by(|a, b| cmp_row(a, b));\n\n            assert_eq!(expect.len(), ret.len(), \"wrong number of rows returned\");\n            let equal = expect.iter().zip(ret.iter()).all(|(expect, real)| {\n                compare_row(expect.1.as_bytes().iter(), real.1.as_bytes().iter())\n            });\n            assert!(equal);\n        }\n    }\n    fn cmp_row\u003cA\u003e(a: \u0026(A, Vec\u003cu8\u003e), b: \u0026(A, Vec\u003cu8\u003e)) -\u003e Ordering\n    where\n        A: Ord,\n    {\n        if a.0 != b.0 {\n            return a.0.cmp(\u0026b.0);\n        }\n        assert_eq!(a.1.len(), b.1.len());\n        for i in 0..a.1.len() {\n            if a.1[i] != b.1[i] {\n                return a.1[i].cmp(\u0026b.1[i]);\n            }\n        }\n        Equal\n    }\n\n    #[test]\n    fn test_inmem_joiner() {\n        struct TestCase {\n            outer: Vec\u003ci64\u003e,\n            inner: Vec\u003ci64\u003e,\n            expect: Vec\u003ci64\u003e,\n        }\n        let tcases = vec![\n            TestCase {\n                outer: vec![1, 1, 1, 1],\n                inner: vec![1, 2, 2, 2],\n                expect: vec![1, 1, 1, 1],\n            },\n            TestCase {\n                outer: vec![1, 2, 1, 2],\n                inner: vec![2, 1],\n                expect: vec![1, 2, 1, 2],\n            },\n        ];\n        for item in \u0026tcases {\n            let p_index = 1;\n            let batch_size = 2;\n            let left_key_offset = 8; // first 8 bytes represents join key\n            let right_key_offset = 8;\n\n            let mut outer_rows = Vec::new();\n            for i in \u0026item.outer {\n                outer_rows.push(make_i64s_row((*i, \u0026i.to_le_bytes()[..])));\n            }\n            let mut inner_rows = Vec::new();\n            for i in \u0026item.inner {\n                inner_rows.push(make_i64s_row((*i, \u0026i.to_le_bytes()[..])));\n            }\n\n            let in_queue = Inmem::new(1);\n            let out_queue = Inmem::new(2);\n            in_queue.enqueue(1, inner_rows);\n            out_queue.enqueue(1, outer_rows);\n            let mut joiner = HashJoiner::new(\n                Rc::new(out_queue),\n                Rc::new(in_queue),\n                p_index,\n                batch_size,\n                left_key_offset,\n                right_key_offset,\n            );\n            let mut ret: Vec\u003ci64\u003e = Vec::new();\n            // joined result should be 1,1|1,1|1,1|1,1\n            while let Some(b) = joiner.next() {\n                for row in b.data() {\n                    let joined_key = FromBytes::read_from(\u0026row.inner[..8]).unwrap();\n                    ret.push(joined_key);\n                    // ret.push((joined_key, row.inner[8..].to_vec()));\n                }\n            }\n            // let expect = [[1, 1], [1, 1], [1, 1], [1, 1]];\n\n            assert_eq!(\n                item.expect.len(),\n                ret.len(),\n                \"wrong number of rows returned\"\n            );\n            let equal = item\n                .expect\n                .iter()\n                .zip(ret.iter())\n                .all(|(real, expect)| real == expect);\n            assert!(equal);\n        }\n    }\n\n    fn compare_row\u003c'a\u003e(\n        left: impl Iterator\u003cItem = \u0026'a u8\u003e,\n        right: impl Iterator\u003cItem = \u0026'a u8\u003e,\n    ) -\u003e bool {\n        left.zip(right).all(|(a, b)| a == b)\n    }\n}\n","traces":[{"line":20,"address":[592420,592128],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":36,"address":[592253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[592681,592448],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":74,"address":[592476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[734672,734707],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":81,"address":[592841,592767,592701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[592897,592824,593000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[592973,593034,593104],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[593086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[593286,593152],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":89,"address":[593177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[593312],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":96,"address":[593376],"length":1,"stats":{"Line":1},"fn_name":"data"},{"line":106,"address":[593392],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":109,"address":[593456],"length":1,"stats":{"Line":0},"fn_name":"string_data"},{"line":110,"address":[593497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[594821,593776],"length":1,"stats":{"Line":1},"fn_name":"_build"},{"line":126,"address":[593796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[593834,593904,594035,594836],"length":1,"stats":{"Line":4},"fn_name":null},{"line":129,"address":[594062,594554,593973,594801],"length":1,"stats":{"Line":3},"fn_name":null},{"line":130,"address":[594277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[594411,594353],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[594473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[594489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[594559,594454],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[594050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[596340,594848],"length":1,"stats":{"Line":1},"fn_name":"next"},{"line":145,"address":[594887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[594943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[594912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[595235,596308,595070,595135],"length":1,"stats":{"Line":3},"fn_name":null},{"line":152,"address":[595467,595201,595542,595722],"length":1,"stats":{"Line":4},"fn_name":null},{"line":153,"address":[595754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[595817,595873],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[595829],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[595927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[596285,595943],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[596064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[596103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[596158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[596214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[595250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[595296],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[595287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[737418,736688],"length":1,"stats":{"Line":1},"fn_name":"_find_next_inmem_sized_partition\u003cbustubrust::join::grace::tests::test_grace_h_joiner::{closure#0}\u003e"},{"line":258,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[737730,737456],"length":1,"stats":{"Line":1},"fn_name":"_new_hash_joiner\u003cbustubrust::join::grace::tests::test_grace_h_joiner::{closure#0}\u003e"},{"line":284,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[741623,739504],"length":1,"stats":{"Line":1},"fn_name":"recursive_partition\u003cbustubrust::join::grace::tests::test_grace_h_joiner::{closure#0}\u003e"},{"line":350,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[743426,741648],"length":1,"stats":{"Line":1},"fn_name":"new\u003cbustubrust::join::grace::tests::test_grace_h_joiner::{closure#0}, alloc::vec::into_iter::IntoIter\u003cbustubrust::join::grace::Batch, alloc::alloc::Global\u003e, alloc::vec::into_iter::IntoIter\u003cbustubrust::join::grace::Batch, alloc::alloc::Global\u003e\u003e"},{"line":391,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[515440,515646],"length":1,"stats":{"Line":1},"fn_name":"make_i64s_row"},{"line":472,"address":[515459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[515485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[515565],"length":1,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[515594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[516345,515680],"length":1,"stats":{"Line":3},"fn_name":"test_grace_h_joiner"},{"line":497,"address":[519641,521417,517585,521632,525939,524126,526807,524325,521218,525698,516497,520778,515911,516553,521740,522187,521006,523458,526540,517973,518659,522339,526379,526167,523686,518728,519463,518073,517771,515693,523914,519827,522421,525444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":498,"address":[517794],"length":1,"stats":{"Line":1},"fn_name":null},{"line":499,"address":[515953,515798,516360],"length":1,"stats":{"Line":3},"fn_name":null},{"line":500,"address":[516593,516725,516530],"length":1,"stats":{"Line":3},"fn_name":null},{"line":501,"address":[517185,517608,516990,517053],"length":1,"stats":{"Line":4},"fn_name":null},{"line":503,"address":[521461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":504,"address":[518120,518530,517991,517900],"length":1,"stats":{"Line":4},"fn_name":null},{"line":505,"address":[518713,518908,519486,519685,518776],"length":1,"stats":{"Line":5},"fn_name":null},{"line":506,"address":[519881,519944,520822,520076,521050,521262],"length":1,"stats":{"Line":6},"fn_name":null},{"line":508,"address":[526444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[521567,521658,522210,521787],"length":1,"stats":{"Line":4},"fn_name":null},{"line":510,"address":[522406,523743,523971,522469,523502,522601,524183],"length":1,"stats":{"Line":7},"fn_name":null},{"line":511,"address":[526224,524392,525501,524587,525755,525996,524455],"length":1,"stats":{"Line":7},"fn_name":null},{"line":516,"address":[528227,532147,528386],"length":1,"stats":{"Line":3},"fn_name":null},{"line":517,"address":[528410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[528422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":519,"address":[528434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[528454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[529460,528469,529437,528609],"length":1,"stats":{"Line":3},"fn_name":null},{"line":523,"address":[528811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[528930,529026,528818],"length":1,"stats":{"Line":3},"fn_name":null},{"line":525,"address":[529153,529260],"length":1,"stats":{"Line":2},"fn_name":null},{"line":527,"address":[529335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":529,"address":[529488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[529503,529647,530475,530498],"length":1,"stats":{"Line":3},"fn_name":null},{"line":531,"address":[529849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[529968,530064,529856],"length":1,"stats":{"Line":3},"fn_name":null},{"line":533,"address":[530298,530191],"length":1,"stats":{"Line":2},"fn_name":null},{"line":535,"address":[530373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[530526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":547,"address":[530616],"length":1,"stats":{"Line":1},"fn_name":null},{"line":548,"address":[530664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":549,"address":[530735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":550,"address":[530846],"length":1,"stats":{"Line":3},"fn_name":null},{"line":552,"address":[530984,530959],"length":1,"stats":{"Line":2},"fn_name":null},{"line":554,"address":[531114,531042,532640,531180],"length":1,"stats":{"Line":3},"fn_name":null},{"line":555,"address":[532160,532319,531154,532227],"length":1,"stats":{"Line":4},"fn_name":null},{"line":556,"address":[532340],"length":1,"stats":{"Line":1},"fn_name":null},{"line":557,"address":[532458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":559,"address":[532540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":563,"address":[531195],"length":1,"stats":{"Line":3},"fn_name":null},{"line":564,"address":[531249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":567,"address":[900842,900752,900776],"length":1,"stats":{"Line":3},"fn_name":"{closure#2}"},{"line":569,"address":[531393],"length":1,"stats":{"Line":3},"fn_name":null},{"line":571,"address":[531487,531686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":572,"address":[531843,531660],"length":1,"stats":{"Line":4},"fn_name":null},{"line":573,"address":[901041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":575,"address":[532032,532053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":578,"address":[899680],"length":1,"stats":{"Line":1},"fn_name":"cmp_row\u003ci64\u003e"},{"line":582,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":595,"address":[533855,532720],"length":1,"stats":{"Line":3},"fn_name":"test_inmem_joiner"},{"line":601,"address":[532898,533779,532727,533358],"length":1,"stats":{"Line":2},"fn_name":null},{"line":602,"address":[533178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":603,"address":[532816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":604,"address":[532940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":605,"address":[533064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":607,"address":[533635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":608,"address":[533284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":609,"address":[533408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":610,"address":[533513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":613,"address":[534054,533878,533980,536475],"length":1,"stats":{"Line":4},"fn_name":null},{"line":614,"address":[534078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":615,"address":[534090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":616,"address":[534102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":617,"address":[534114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":619,"address":[534134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":620,"address":[534263,534337,534149],"length":1,"stats":{"Line":3},"fn_name":null},{"line":621,"address":[534353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":623,"address":[534327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":624,"address":[534560,534678,534757],"length":1,"stats":{"Line":3},"fn_name":null},{"line":625,"address":[534773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":628,"address":[534747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":629,"address":[534972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":630,"address":[535000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":631,"address":[535117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":633,"address":[535223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":634,"address":[535357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":640,"address":[535616,535591],"length":1,"stats":{"Line":2},"fn_name":null},{"line":642,"address":[535746,535674,536796,535812],"length":1,"stats":{"Line":3},"fn_name":null},{"line":643,"address":[535786,536488,536647,536555],"length":1,"stats":{"Line":4},"fn_name":null},{"line":644,"address":[536663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":645,"address":[536784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":651,"address":[536034,535901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":652,"address":[535827],"length":1,"stats":{"Line":1},"fn_name":null},{"line":653,"address":[535870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":656,"address":[536004,536332,536191],"length":1,"stats":{"Line":3},"fn_name":null},{"line":659,"address":[536248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":660,"address":[901299,901280],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":661,"address":[536374,536395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":665,"address":[900320,900402],"length":1,"stats":{"Line":1},"fn_name":"compare_row\u003ccore::slice::iter::Iter\u003cu8\u003e, core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":669,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":245,"coverable":278},{"path":["/","var","www","rust","bustubrust","src","join","mod.rs"],"content":"mod grace;\nmod queue;\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","join","queue.rs"],"content":"use crate::join::grace::Batch;\nuse crate::join::grace::PartitionedQueue;\nuse crate::join::grace::Row;\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::collections::VecDeque;\nuse std::rc::Rc;\n\npub struct Inmem {\n    inner: RefCell\u003cHashMap\u003cusize, VecDeque\u003cRow\u003e\u003e\u003e,\n    id: usize,\n}\npub struct MemoryAllocator {\n    queues: Vec\u003cInmem\u003e,\n    cur_id: usize,\n}\nimpl MemoryAllocator {\n    pub fn new() -\u003e Self {\n        MemoryAllocator {\n            queues: vec![],\n            cur_id: 0,\n        }\n    }\n\n    pub fn alloc(\u0026mut self) -\u003e Rc\u003cInmem\u003e {\n        let cur_id = self.cur_id;\n        self.cur_id += 1;\n        let new = Inmem::new(cur_id);\n        let rc = Rc::new(new);\n        return rc;\n    }\n}\nimpl Inmem {\n    pub fn new(id: usize) -\u003e Self {\n        Inmem {\n            inner: RefCell::new(HashMap::new()),\n            id,\n        }\n    }\n}\n\nimpl PartitionedQueue for Inmem {\n    fn id(\u0026self) -\u003e usize {\n        self.id\n    }\n    fn enqueue(\u0026self, partition_idx: usize, data: Vec\u003cRow\u003e) {\n        let mut inner = self.inner.borrow_mut();\n        match inner.get_mut(\u0026partition_idx) {\n            None =\u003e {\n                let mut new_dequeue = VecDeque::new();\n                new_dequeue.extend(data);\n                inner.insert(partition_idx, new_dequeue);\n            }\n            Some(exist) =\u003e {\n                exist.extend(data);\n            }\n        }\n    }\n\n    fn dequeue(\u0026self, partition_idx: usize, size: usize) -\u003e Option\u003cBatch\u003e {\n        let mut inner = self.inner.borrow_mut();\n        match inner.get_mut(\u0026partition_idx) {\n            None =\u003e {\n                inner.remove(\u0026partition_idx);\n                None\n            }\n            Some(exist) =\u003e {\n                let mut ret = Vec::new();\n                while let Some(row) = exist.pop_front() {\n                    ret.push(row);\n                    if ret.len() == size {\n                        break;\n                    }\n                }\n                if ret.len() \u003e 0 {\n                    Some(Batch::new(ret))\n                } else {\n                    inner.remove(\u0026partition_idx);\n                    None\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":18,"address":[642112],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":20,"address":[642125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[642192],"length":1,"stats":{"Line":1},"fn_name":"alloc"},{"line":26,"address":[642212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[642229,642280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[642268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[642310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[642368],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":36,"address":[642397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[642480],"length":1,"stats":{"Line":0},"fn_name":"id"},{"line":44,"address":[642485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[643056,642496],"length":1,"stats":{"Line":1},"fn_name":"enqueue"},{"line":47,"address":[642521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[642708,642594,642657],"length":1,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[642740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[642833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[642943,642891],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[642752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[642765],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[644008,643088],"length":1,"stats":{"Line":1},"fn_name":"dequeue"},{"line":61,"address":[643144],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[643263,643187],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[643972,643295],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[643999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[643310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[643336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[643343,643636,643451,643546,643594,643695],"length":1,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[643491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[643582,643631],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[643675,643707,643897],"length":1,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[643730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[643718,643863],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[643890],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":31,"coverable":33},{"path":["/","var","www","rust","bustubrust","src","lib.rs"],"content":"pub mod bpm;\npub mod btree;\npub mod cc;\npub mod error;\npub mod join;\npub mod replacer;\n// pub mod sql;\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","main.rs"],"content":"use bustubrust::bpm::DiskManager;\nuse std::cell::UnsafeCell;\nuse std::sync::atomic::AtomicUsize;\nuse std::sync::{Arc, Barrier};\nuse std::thread::{sleep, spawn};\nuse std::time;\nuse std::{\n    os::unix::thread,\n    sync::atomic::{AtomicBool, AtomicI64, Ordering},\n};\n\n// use cc::read;\n\nstatic my_num: i64 = 0;\nstatic has_data: AtomicBool = AtomicBool::new(false);\nstatic NTHREADS: usize = 8;\n\nfn main() {\n    main2();\n}\n\n#[derive(Default)]\nstruct UsizePair {\n    atomic: AtomicUsize,\n    normal: UnsafeCell\u003cusize\u003e,\n}\n\nstatic NITERS: usize = 1000000;\n/* struct SendPtr\u003cT\u003e(*const T);\nunsafe impl\u003cT\u003e Sync for SendPtr\u003cT\u003e {}\nunsafe impl\u003cT\u003e Send for SendPtr\u003cT\u003e {} */\n\nunsafe impl Sync for UsizePair {}\nimpl UsizePair {\n    fn get(\u0026self) -\u003e (usize, usize) {\n        let atom = self.atomic.load(Ordering::Relaxed); //Ordering::Acquire\n\n        let norm = unsafe { *self.normal.get() };\n        (atom, norm)\n    }\n    pub fn set(\u0026self, v: usize) {\n        unsafe { *self.normal.get() = v };\n\n        self.atomic.store(v, Ordering::Relaxed); //Ordering::Release\n    }\n}\n\nfn main2() {\n    /* let shared2 = shared.clone();\n    let shared3 = shared.clone(); */\n\n    loop {\n        let barrier = Arc::new(Barrier::new(NTHREADS + 1));\n        let shared = Arc::new(UsizePair::default());\n        let mut children = vec![];\n\n        for _ in 0..NTHREADS {\n            let shared = shared.clone();\n            let barrier = barrier.clone();\n            children.push(spawn(move || {\n                barrier.wait();\n                let mut v = 0;\n                while v \u003c NITERS - 1 {\n                    let (atom, norm) = shared.get();\n                    if atom \u003e norm {\n                        println!(\"reordered !!!! {} \u003e {}\", atom, norm)\n                    }\n                    v = atom;\n                }\n            }));\n        }\n        barrier.wait();\n        for v in 1..NITERS {\n            shared.set(v);\n        }\n        for child in children {\n            child.join().unwrap();\n        }\n\n        // has_data.store(false, Ordering::SeqCst);\n        sleep(time::Duration::from_millis(50));\n        println!(\"retying\");\n    }\n}\n\nfn do_something() -\u003e i32 {\n    let a = 1;\n    a + 2\n}\n","traces":[{"line":18,"address":[404160],"length":1,"stats":{"Line":0},"fn_name":"main"},{"line":19,"address":[404161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[404176],"length":1,"stats":{"Line":0},"fn_name":"get"},{"line":36,"address":[404190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[404220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[404252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[404288],"length":1,"stats":{"Line":0},"fn_name":"set"},{"line":42,"address":[404311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[404342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[404368,405893],"length":1,"stats":{"Line":0},"fn_name":"main2"},{"line":52,"address":[404375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[404391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[404581,404431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[404597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[404735,405093,404604,404791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[404896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[404937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[397099,396624],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":61,"address":[396646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[396711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[396720,396833],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[396746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[396808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[396840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[396823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[404873,405121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[405132,405356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[405385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[405419,405293,405703],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[405622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[405740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[405776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[405920],"length":1,"stats":{"Line":0},"fn_name":"do_something"},{"line":87,"address":[405924],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":34},{"path":["/","var","www","rust","bustubrust","src","replacer.rs"],"content":"use crate::bpm::FrameID;\nuse crate::bpm::Replacer;\nuse lru::LruCache;\nuse std::cell::RefCell;\n\npub struct LRURepl {\n    internal: RefCell\u003cLruCache\u003cFrameID, ()\u003e\u003e,\n}\n\nimpl LRURepl {\n    pub fn new(cap: usize) -\u003e Self {\n        LRURepl {\n            internal: RefCell::new(LruCache::new(cap)),\n        }\n    }\n}\n\nimpl Replacer for LRURepl {\n    fn victim(\u0026self) -\u003e Option\u003cFrameID\u003e {\n        match self.internal.borrow_mut().pop_lru() {\n            Some((frame_id, _)) =\u003e Some(frame_id),\n            None =\u003e None,\n        }\n    }\n    fn size(\u0026self) -\u003e i64 {\n        self.internal.borrow().len() as i64\n    }\n    fn unpin(\u0026self, frame_id: FrameID) {\n        if !self.internal.borrow().contains(\u0026frame_id) {\n            self.internal.borrow_mut().put(frame_id, ());\n        }\n    }\n    fn pin(\u0026self, frame_id: FrameID) {\n        self.internal.borrow_mut().pop(\u0026frame_id);\n    }\n}\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_replacer() {\n        let r = LRURepl::new(7);\n        r.unpin(1);\n        r.unpin(2);\n        r.unpin(3);\n        r.unpin(4);\n        r.unpin(5);\n        r.unpin(6);\n        r.unpin(1);\n        assert_eq!(6, r.size());\n        let ret = r.victim();\n        assert_eq!(ret, Some(1));\n        let ret = r.victim();\n        assert_eq!(ret, Some(2));\n        let ret = r.victim();\n        assert_eq!(ret, Some(3));\n        r.pin(3);\n        r.pin(4);\n\n        assert_eq!(2, r.size());\n\n        r.unpin(4);\n\n        let ret = r.victim();\n        assert_eq!(ret, Some(5));\n        let ret = r.victim();\n        assert_eq!(ret, Some(6));\n        let ret = r.victim();\n        assert_eq!(ret, Some(4));\n    }\n}\n","traces":[{"line":11,"address":[814112],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":13,"address":[814137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[814208,814338],"length":1,"stats":{"Line":1},"fn_name":"victim"},{"line":20,"address":[814350,814314,814217],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[814363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[814352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[814416,814520],"length":1,"stats":{"Line":1},"fn_name":"size"},{"line":26,"address":[814425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[814544,814673],"length":1,"stats":{"Line":1},"fn_name":"unpin"},{"line":29,"address":[814563,814689],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[814705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[814924,814816],"length":1,"stats":{"Line":1},"fn_name":"pin"},{"line":34,"address":[814830],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[544725,542704],"length":1,"stats":{"Line":3},"fn_name":"test_replacer"},{"line":43,"address":[542711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[542742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[542762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[542822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[542842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[542862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[542882],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[542902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[543089,542917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[543151,543050],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[543175,543324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[543391,543285],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[543415,543564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[543631,543525],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[543793,543655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[543770],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[543857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[543872,544033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[544010],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[544088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[544139,544264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[544237,544325],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[544474,544349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[544535,544447],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[544559,544674],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":39,"coverable":39},{"path":["/","var","www","rust","bustubrust","src","sql","executor.rs"],"content":"use super::plan::Node;\nuse crate::error::{Error, Result};\nuse crate::sql::join::HashInnerJoin;\nuse crate::sql::tx::Transaction;\nuse crate::sql::Nothing;\nuse crate::sql::ResultSet;\nuse crate::sql::Row;\nuse serde_derive::{Deserialize, Serialize};\nuse std::hash::{Hash, Hasher};\n\npub trait Executor\u003cT: Transaction\u003e {\n    fn next(self: Box\u003cSelf\u003e, txn: \u0026mut T) -\u003e Result\u003cResultSet\u003e;\n}\n\nimpl\u003cT: Transaction + 'static\u003e dyn Executor\u003cT\u003e {\n    /// Builds an executor for a plan node, consuming it\n    pub fn build(node: Node) -\u003e Box\u003cdyn Executor\u003cT\u003e\u003e {\n        match node {\n            Node::HashJoin {\n                left,\n                left_field,\n                right,\n                right_field,\n                outer,\n            } =\u003e HashInnerJoin::new(\n                Self::build(*left),\n                left_field.0,\n                Self::build(*right),\n                right_field.0,\n                outer,\n            ),\n            Node::Nothing =\u003e Nothing::new(),\n        }\n    }\n}\n\n/* pub struct Tuple\u003c'a\u003e {\n    data: \u0026'a [u8],\n}\npub struct Schema {}\n\npub struct Rid {}\n\nimpl\u003c'a\u003e Tuple\u003c'a\u003e {\n    fn get_rid() -\u003e Rid {\n        Rid {}\n    }\n\n    fn get_data(\u0026self) -\u003e \u0026'a [u8] {\n        return self.data;\n    }\n} */\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub enum Value {\n    Null,\n    Boolean(bool),\n    Integer(i64),\n    Float(f64),\n    String(String),\n}\n\nimpl std::cmp::Eq for Value {}\n\n#[allow(clippy::derive_hash_xor_eq)]\nimpl Hash for Value {\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.datatype().hash(state);\n        match self {\n            Value::Null =\u003e self.hash(state),\n            Value::Boolean(v) =\u003e v.hash(state),\n            Value::Integer(v) =\u003e v.hash(state),\n            Value::Float(v) =\u003e v.to_be_bytes().hash(state),\n            Value::String(v) =\u003e v.hash(state),\n        }\n    }\n}\n\nimpl Value {\n    /// Returns the value's datatype, or None for null values\n    pub fn datatype(\u0026self) -\u003e Option\u003cDataType\u003e {\n        match self {\n            Self::Null =\u003e None,\n            Self::Boolean(_) =\u003e Some(DataType::Boolean),\n            Self::Integer(_) =\u003e Some(DataType::Integer),\n            Self::Float(_) =\u003e Some(DataType::Float),\n            Self::String(_) =\u003e Some(DataType::String),\n        }\n    }\n\n    /// Returns the inner boolean, or an error if not a boolean\n    pub fn boolean(self) -\u003e Result\u003cbool\u003e {\n        match self {\n            Self::Boolean(b) =\u003e Ok(b),\n            v =\u003e Err(Error::Value(format!(\"Not a boolean: {:?}\", v))),\n        }\n    }\n\n    /// Returns the inner float, or an error if not a float\n    pub fn float(self) -\u003e Result\u003cf64\u003e {\n        match self {\n            Self::Float(f) =\u003e Ok(f),\n            v =\u003e Err(Error::Value(format!(\"Not a float: {:?}\", v))),\n        }\n    }\n\n    /// Returns the inner integer, or an error if not an integer\n    pub fn integer(self) -\u003e Result\u003ci64\u003e {\n        match self {\n            Self::Integer(i) =\u003e Ok(i),\n            v =\u003e Err(Error::Value(format!(\"Not an integer: {:?}\", v))),\n        }\n    }\n\n    /// Returns the inner string, or an error if not a string\n    pub fn string(self) -\u003e Result\u003cString\u003e {\n        match self {\n            Self::String(s) =\u003e Ok(s),\n            v =\u003e Err(Error::Value(format!(\"Not a string: {:?}\", v))),\n        }\n    }\n}\n\nimpl std::fmt::Display for Value {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        f.write_str(\n            match self {\n                Self::Null =\u003e \"NULL\".to_string(),\n                Self::Boolean(b) if *b =\u003e \"TRUE\".to_string(),\n                Self::Boolean(_) =\u003e \"FALSE\".to_string(),\n                Self::Integer(i) =\u003e i.to_string(),\n                Self::Float(f) =\u003e f.to_string(),\n                Self::String(s) =\u003e s.clone(),\n            }\n            .as_ref(),\n        )\n    }\n}\n\n#[derive(Clone, Debug, Hash, PartialEq, Serialize, Deserialize)]\npub enum DataType {\n    Boolean,\n    Integer,\n    Float,\n    String,\n}\n\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Nothing {\n    fn next(self: Box\u003cSelf\u003e, _: \u0026mut T) -\u003e Result\u003cResultSet\u003e {\n        Ok(ResultSet::Query {\n            columns: Vec::new(),\n            rows: Box::new(std::iter::once(Ok(Row::new()))),\n        })\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":26},{"path":["/","var","www","rust","bustubrust","src","sql","join.rs"],"content":"use crate::bpm::{BufferPoolManager, Frame, Replacer};\nuse crate::error::{Error, Result};\nuse crate::replacer::LRURepl;\nuse crate::sql::executor::Executor;\nuse crate::sql::tx::Transaction;\nuse crate::sql::Value;\nuse crate::sql::{ColumnedBatch, ResultSet};\nuse iota::iota;\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::marker::PhantomData;\n\n// TODO: BufferPoolManager should have generic over LRURepl, but this module should not not about\n// that type parameter, maybe using associated types????\npub struct GraceHashJoin\u003cT: Transaction\u003e {\n    bpm: RefCell\u003cBufferPoolManager\u003cLRURepl\u003e\u003e,\n    left: Box\u003cdyn Executor\u003cT\u003e\u003e,\n    left_field: usize,\n    right: Box\u003cdyn Executor\u003cT\u003e\u003e,\n    right_field: usize,\n    state: PartitionState,\n    // TODO: for each input, implement an in-memory input container that makes call to\n    // bpm for enqueuing/dequeing the batch data on demand\n    //\n}\ntype PartitionState = i64;\niota! {\n    const INITIAL_PARTITIONING: PartitionState = 0 \u003c\u003c iota;\n        ,PROCESS_NEW_PARTITION\n        ,PROCESSING\n        ,FINISHED\n}\n\nimpl\u003cT: Transaction, F: Fn(Frame, Frame) -\u003e Box\u003cdyn Executor\u003cT\u003e\u003e\u003e Executor\u003cT\u003e\n    for GraceHashJoin\u003cT, F\u003e\n{\n    /// When the tables do not fit on main memory, the DBMS has to swap tables in and out essentially at random,\n    /// which leads to poor performance. The Grace Hash Join is an extension of the basic hash join that also hashes\n    /// the inner table into partitions that are written out to disk.\n    ///\n    ///  Phase #1  Build: First, scan both the outer and inner tables and populate a hash table using the hash\n    /// function h1 on the join attributes. The hash tables buckets are written out to disk as needed. If a single\n    /// bucket does not fit in memory, the DBMS can use recursive partitioning with different hash function\n    /// h2 (where h1 6= h2) to further divide the bucket. This can continue recursively until the buckets fit\n    /// into memory.\n    ///\n    ///  Phase #2  Probe: For each bucket level, retrieve the corresponding pages for both outer and inner\n    /// tables. Then, perform a nested loop join on on the tuples in those two pages. The pages will fit in\n    /// memory, so this join operation will be fast.\n    /// Referenec: https://15445.courses.cs.cmu.edu/fall2021/notes/10-joins.pdf\n    /// CockcroachDB: https://github.com/cockroachdb/cockroach/issues/43790\n    fn next(self: Box\u003cSelf\u003e, txn: \u0026mut T) -\u003e Result\u003cResultSet\u003e {\n        loop {\n            match self.state {\n                INITIAL_PARTITIONING =\u003e self.initial_partition(txn),\n                PROCESS_NEW_PARTITION =\u003e self.process_new_partition(txn),\n                PROCESSING =\u003e self.processing(txn),\n                FINISHED =\u003e {\n                    self.finish(txn);\n                    break;\n                }\n            };\n        }\n        /* let bpm = self.bpm.borrow();\n        self.left.next(txn);\n        bpm.new_page(); */\n        Err(Error::Abort)\n    }\n}\nstruct FramedScanner {\n    f: Frame,\n}\nimpl FramedScanner {\n    fn new(f: Frame) -\u003e Self {\n        FramedScanner { f }\n    }\n}\n\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for FramedScanner {\n    fn next(self: Box\u003cSelf\u003e, txn: \u0026mut T) -\u003e Result\u003cResultSet\u003e {}\n}\n\nimpl\u003cT: 'static + Transaction\u003e GraceHashJoin\u003cT\u003e {\n    fn new(\n        bpm: BufferPoolManager\u003cLRURepl\u003e,\n        left: Box\u003cdyn Executor\u003cT\u003e\u003e, // original left source\n        left_field: usize,\n        right: Box\u003cdyn Executor\u003cT\u003e\u003e, // original right source\n        right_field: usize,\n    ) -\u003e Self {\n        GraceHashJoin {\n            bpm: RefCell::new(bpm),\n            left,\n            right,\n            left_field,\n            right_field,\n            state: INITIAL_PARTITIONING,\n        }\n    }\n    fn in_mem_op_constructor(f1: Frame, f2: Frame) -\u003e Box\u003cdyn Executor\u003cT\u003e\u003e {\n        HashInnerJoin::new(\n            Box::new(FramedScanner::new(f1)),\n            0,\n            Box::new(FramedScanner::new(f2)),\n            0,\n            false,\n        )\n    }\n\n    fn initial_partition(self: Box\u003cSelf\u003e, txn: \u0026mut T) {\n        let left_batch = self.left.next(txn);\n        let right_batch = self.right.next(txn);\n    }\n    fn process_new_partition(self: Box\u003cSelf\u003e, txn: \u0026mut T) {}\n    fn processing(self: Box\u003cSelf\u003e, txn: \u0026mut T) {}\n    fn finish(self: Box\u003cSelf\u003e, txn: \u0026mut T) {}\n\n    fn partition_batch(self: Box\u003cSelf\u003e, ret: ColumnedBatch, idx: usize, parent_mem_size: i64) {\n        if ret.len() == 0 {\n            return;\n        }\n    }\n\n    // result stores info about at which partition, which tuples in the input batch belongs to\n    fn _distribute_batch(self: Box\u003cSelf\u003e, b: ColumnedBatch) -\u003e Vec\u003cVec\u003ci64\u003e\u003e {\n        let total_tuple = b.len();\n    }\n\n    fn xxhash3(val: \u0026[u8]) -\u003e u64 {\n        xxhash_rust::xxh3::xxh3_64(val)\n    }\n}\n\npub struct HashInnerJoin\u003cT: Transaction\u003e {\n    left: Box\u003cdyn Executor\u003cT\u003e\u003e,\n    left_field: usize, // index of the joined field inside the tuple of left table\n    right: Box\u003cdyn Executor\u003cT\u003e\u003e,\n    right_field: usize, // index of the joined field inside the tuple of the right table\n    outer: bool,\n}\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for HashInnerJoin\u003cT\u003e {\n    fn next(self: Box\u003cSelf\u003e, txn: \u0026mut T) -\u003e Result\u003cResultSet\u003e {\n        if let ResultSet::Query {\n            rows: outer_rows,\n            columns: mut outer_columns,\n        } = self.left.next(txn)?\n        {\n            let (l, r) = (self.left_field, self.right_field);\n            if let ResultSet::Query {\n                rows: right_rows,\n                columns: right_columns,\n            } = self.right.next(txn)?\n            {\n                let inner_table: HashMap\u003cValue, Vec\u003cValue\u003e\u003e = right_rows\n                    .map(|r_tuple| match r_tuple {\n                        Ok(values) =\u003e {\n                            if values.len() \u003c= r {\n                                return Err(Error::Internal(\n                                    \"right index out of bound\".to_string(),\n                                ));\n                            }\n                            let joined_key = values[r].clone();\n                            return Ok((joined_key, values));\n                        }\n                        Err(err) =\u003e Err(err),\n                    })\n                    .collect::\u003cResult\u003c_\u003e\u003e()?;\n                outer_columns.extend(right_columns);\n                // iterate outer rows, probe inner table, if match omit, else do nothing\n                // this is like an inner join\n                let joined_rows = outer_rows.filter_map(move |tuple_result| match tuple_result {\n                    Ok(mut tuple) =\u003e {\n                        if tuple.len() \u003c= l {\n                            return Some(Err(Error::Value(\"left index out of bound\".to_string())));\n                        }\n\n                        let joined_field = tuple[l].clone();\n                        match inner_table.get(\u0026joined_field) {\n                            Some(hit) =\u003e {\n                                //TODO: consider late vs early materialization\n                                tuple.extend(hit.clone());\n                                return Some(Ok(tuple));\n                            }\n                            None =\u003e return None,\n                        };\n                    }\n                    Err(err) =\u003e Some(Err(err)),\n                });\n                return Ok(ResultSet::Query {\n                    columns: outer_columns,\n                    rows: Box::new(joined_rows),\n                });\n            }\n        };\n        Err(Error::Internal(\"unimplemented\".into()))\n    }\n}\n\nimpl\u003cT: Transaction\u003e HashInnerJoin\u003cT\u003e {\n    pub fn new(\n        left: Box\u003cdyn Executor\u003cT\u003e\u003e,\n        left_field: usize,\n        right: Box\u003cdyn Executor\u003cT\u003e\u003e,\n        right_field: usize,\n        outer: bool,\n    ) -\u003e Box\u003cSelf\u003e {\n        if outer {\n            panic!(\"unimplemented\");\n        }\n        Box::new(HashInnerJoin {\n            left,\n            left_field,\n            right,\n            right_field,\n            outer,\n        })\n    }\n}\n","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":67},{"path":["/","var","www","rust","bustubrust","src","sql","mod.rs"],"content":"mod executor;\nmod join;\nmod plan;\nmod tx;\n\nuse crate::error::Result;\nuse crate::sql::executor::Value;\nuse crate::sql::plan::Node;\nuse derivative::Derivative;\nuse serde_derive::{Deserialize, Serialize};\n\n#[derive(Derivative, Serialize, Deserialize)]\n#[derivative(Debug, PartialEq)]\npub enum ResultSet {\n    // Transaction started\n    /* Begin {\n        id: u64,\n        mode: Mode,\n    },\n    // Transaction committed\n    Commit {\n        id: u64,\n    },\n    // Transaction rolled back\n    Rollback {\n        id: u64,\n    },\n    // Rows created\n    Create {\n        count: u64,\n    },\n    // Rows deleted\n    Delete {\n        count: u64,\n    },\n    // Rows updated\n    Update {\n        count: u64,\n    },\n    // Table created\n    CreateTable {\n        name: String,\n    },\n    // Table dropped\n    DropTable {\n        name: String,\n    }, */\n    // Query result\n    Query {\n        columns: ColumnLabels,\n        #[derivative(Debug = \"ignore\")]\n        #[derivative(PartialEq = \"ignore\")]\n        #[serde(skip, default = \"ResultSet::empty_rows\")]\n        rows: Rows,\n    },\n    ColumnedBatch(ColumnedBatch),\n    // Explain result\n    Explain(Node),\n}\n\n/// Column oriented batch\n#[derive(Deserialize, Serialize, PartialEq, Debug)]\npub struct ColumnedBatch {\n    length: usize,\n    capacity: usize,\n    columns: Columns,\n}\nimpl ColumnedBatch {\n    fn empty(self) -\u003e bool {\n        self.length == 0\n    }\n\n    fn len(self) -\u003e usize {\n        self.length\n    }\n\n    fn capacity(self) -\u003e usize {\n        self.capacity\n    }\n\n    fn width(self) -\u003e usize {\n        self.columns.len()\n    }\n\n    fn get_column_ith_values(\u0026self, col_number: usize) -\u003e \u0026Column {\n        \u0026self.columns[col_number]\n    }\n}\n\n/// A row of values\npub type Column = Vec\u003cValue\u003e;\n\n/// A row iterator\npub type Columns = Vec\u003cColumn\u003e;\n\n/// A row of values\npub type Row = Vec\u003cValue\u003e;\n\n/// A row iterator\npub type Rows = Box\u003cdyn Iterator\u003cItem = Result\u003cRow\u003e\u003e + Send\u003e;\n\n/// A column (in a result set, see schema::Column for table columns)\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct ColumnLabel {\n    pub name: Option\u003cString\u003e,\n}\n\n/// A set of columns\npub type ColumnLabels = Vec\u003cColumnLabel\u003e;\n\nimpl ResultSet {\n    /// Creates an empty row iterator, for use by serde(default).\n    fn empty_rows() -\u003e Rows {\n        Box::new(std::iter::empty())\n    }\n}\n\npub struct Nothing;\n\nimpl Nothing {\n    pub fn new() -\u003e Box\u003cSelf\u003e {\n        Box::new(Self)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","sql","plan.rs"],"content":"use serde_derive::{Deserialize, Serialize};\n\n/// A plan node\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\npub enum Node {\n    HashJoin {\n        left: Box\u003cNode\u003e,\n        left_field: (usize, Option\u003c(Option\u003cString\u003e, String)\u003e),\n        right: Box\u003cNode\u003e,\n        right_field: (usize, Option\u003c(Option\u003cString\u003e, String)\u003e),\n        outer: bool,\n    },\n    Nothing,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","sql","tx.rs"],"content":"pub trait Transaction {}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","var","www","rust","bustubrust","play","main.rs"],"content":"use std::cell::{Ref, RefCell};\nuse std::collections::HashMap;\nuse std::collections::VecDeque;\nuse std::io::copy;\nuse std::sync::Mutex;\nuse tinyvec::SliceVec;\n\n#[derive(Debug)]\nstruct Foo;\n\nfn main() {\n    let mut st = RefCell::new(HashMap::new());\n    let mut vd = VecDeque::new();\n    vd.push_back(1);\n    st.borrow_mut().insert(\"a\", vd);\n    let st2 = st.borrow_mut().get_mut(\"a\").unwrap().pop_front().unwrap();\n    println!(\"{}\", st2);\n    let st2 = st.borrow_mut().get_mut(\"a\").unwrap().pop_front().unwrap();\n    println!(\"{}\", st2);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","bpm.rs"],"content":"use core::cell::RefCell;\nuse libc::O_DIRECT;\nuse owning_ref::OwningHandle;\nuse parking_lot::{Mutex, MutexGuard};\nuse std::borrow::Borrow;\nuse std::collections::HashMap;\nuse std::collections::VecDeque;\nuse std::marker::PhantomData;\nuse std::os::unix::fs::OpenOptionsExt;\n// use std::fs::Metadata;\nuse std::sync::Arc;\nuse std::{\n    fs::{File, OpenOptions},\n    hash::Hasher,\n    io::{copy, empty, Error, Read, Seek, SeekFrom, Write},\n};\npub struct BufferPoolManager\u003cR: Replacer\u003e {\n    bp: Mutex\u003cBufferPool\u003cR\u003e\u003e,\n    pub dm: DiskManager,\n}\n/* struct AutoDropFrame\u003cF: Fn(BufferPoolManager\u003cR\u003e), R\u003e\nwhere\n    R: Replacer,\n{\n    arc: Arc\u003cMutex\u003cFrame\u003e\u003e,\n    drop_func: F,\n    r: PhantomData\u003cR\u003e,\n}\n\nimpl\u003cF, R\u003e Drop for AutoDropFrame\u003cF, R\u003e\nwhere\n    F: Fn(BufferPoolManager\u003cR\u003e),\n    R: Replacer,\n{\n    fn drop(\u0026mut self) {\n        todo!()\n    }\n} */\n\nimpl\u003cR\u003e BufferPoolManager\u003cR\u003e\nwhere\n    R: Replacer,\n{\n    pub fn new(max_size: usize, r: R, dm: DiskManager) -\u003e Self {\n        let bp = BufferPool::new(max_size, r);\n        BufferPoolManager {\n            bp: Mutex::new(bp),\n            dm,\n        }\n    }\n\n    pub fn new_page(\u0026self) -\u003e Result\u003cArc\u003cMutex\u003cFrame\u003e\u003e, StrErr\u003e {\n        let dm = \u0026self.dm;\n        BufferPool::new_page(\u0026self.bp, dm)\n    }\n\n    pub fn delete_page_locked\u003c'a\u003e(\n        \u0026self,\n        item: OwningHandle\u003cArc\u003cMutex\u003cFrame\u003e\u003e, MutexGuard\u003c'a, Frame\u003e\u003e,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        return BufferPool::delete_page_locked(\u0026self.bp, item);\n    }\n\n    pub fn fetch_page(\u0026self, page_id: PageID) -\u003e Result\u003cArc\u003cMutex\u003cFrame\u003e\u003e, StrErr\u003e {\n        BufferPool::fetch_page(\u0026self.bp, \u0026self.dm, page_id)\n    }\n\n    #[cfg(feature = \"testing\")]\n    pub fn assert_clean_frame(\u0026self, exceptions: \u0026[i64]) {\n        let mu = self.bp.lock();\n        let mut frames = mu.frames.borrow_mut();\n        'loop1: for f in frames.iter_mut() {\n            let locked_fr = f.lock();\n            let frame_id = locked_fr.id;\n            let page_id = locked_fr.page_id;\n            for item in exceptions.iter() {\n                if *item == page_id {\n                    continue 'loop1;\n                }\n            }\n            assert_eq!(\n                0, locked_fr.pin_count,\n                \"err at frame {} with page_id {}: want 0 pin count, has {}\",\n                frame_id, page_id, locked_fr.pin_count\n            );\n        }\n    }\n\n    // caller must previously acquire latches of frames, not\n    // it return the latches in batch\n    pub fn batch_unpin_flush\u003c'a\u003e(\n        \u0026self,\n        items: impl Iterator\u003cItem = OwningHandle\u003cArc\u003cMutex\u003cFrame\u003e\u003e, MutexGuard\u003c'a, Frame\u003e\u003e\u003e,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        for item in items {\n            BufferPool::unpin_flush_frame_locked(\u0026self.bp, item.page_id, item, \u0026self.dm)\n                .expect(\"failed to unpin and flush page\");\n        }\n        Ok(())\n    }\n    pub fn flush_locked\u003c'a\u003e(\u0026self, item: \u0026mut MutexGuard\u003c'a, Frame\u003e) -\u003e Result\u003c(), StrErr\u003e {\n        BufferPool::flush_frame_locked(\u0026self.bp, item.page_id, item, \u0026self.dm)\n            .expect(\"failed to flush page\");\n        Ok(())\n    }\n\n    pub fn unpin_locked\u003c'a\u003e(\n        \u0026self,\n        item: \u0026mut MutexGuard\u003c'a, Frame\u003e,\n        dirty: bool,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        BufferPool::unpin_frame_locked(\u0026self.bp, item.page_id, item, dirty)\n            .expect(\"failed to flush page\");\n        Ok(())\n    }\n\n    /* pub fn unpin_page(\u0026self, page_id: PageID, dirty: bool) -\u003e Result\u003cbool, StrErr\u003e {\n        BufferPool::unpin_page(\u0026self.bp, page_id, dirty)\n    } */\n    /* pub fn flush_page(\u0026self, page_id: PageID) -\u003e Result\u003c(), StrErr\u003e {\n        BufferPool::flush_page(\u0026self.bp, page_id, \u0026self.dm)\n    } */\n}\n\npub struct BufferPool\u003cR: Replacer\u003e {\n    frames: RefCell\u003cVec\u003cArc\u003cMutex\u003cFrame\u003e\u003e\u003e\u003e,\n    page_table: RefCell\u003cHashMap\u003ci64, FrameID\u003e\u003e,\n    size: usize,\n\n    meta: RefCell\u003cPoolMeta\u003e,\n    replacer: R,\n    free_list: RefCell\u003cVecDeque\u003cFrameID\u003e\u003e,\n}\nstruct PoolMeta {\n    next_new: i64,\n}\n\n#[allow(dead_code)]\nimpl\u003cR\u003e BufferPool\u003cR\u003e\nwhere\n    R: Replacer,\n{\n    fn new(max_size: usize, r: R) -\u003e Self {\n        let mut frames = Vec::new();\n        let mut free_list = VecDeque::new();\n        for i in 0..max_size {\n            frames.push(Arc::new(Mutex::new(Frame {\n                page_id: INVALID_PAGE_ID,\n                id: i,\n                dirty: false,\n                _1: [0; 7],\n                pin_count: 0,\n                raw_data: [0u8; PAGE_SIZE],\n                #[cfg(feature = \"testing\")]\n                last_borrower: String::new(),\n            })));\n            free_list.push_front(i);\n        }\n        BufferPool {\n            frames: RefCell::new(frames),\n            page_table: RefCell::new(HashMap::new()),\n            free_list: RefCell::new(free_list),\n            replacer: r,\n            size: max_size,\n            meta: RefCell::new(PoolMeta { next_new: 0 }),\n        }\n    }\n\n    fn _allocate_page_id_locked(b: \u0026MutexGuard\u003cSelf\u003e) -\u003e PageID {\n        let new_page = b.meta.borrow_mut().next_new;\n        b.meta.borrow_mut().next_new = new_page + 1;\n        return new_page;\n    }\n    fn _prepare_new_frame_meta(\n        b: \u0026MutexGuard\u003cBufferPool\u003cR\u003e\u003e,\n        locked_frame: \u0026MutexGuard\u003cFrame\u003e,\n        frame_id: FrameID,\n        new_page_id: PageID,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        let old_page_id = locked_frame.page_id;\n        if locked_frame.page_id != INVALID_PAGE_ID {\n            let some_frame = b.page_table.borrow_mut().remove(\u0026old_page_id);\n            match some_frame {\n                Some(deleted_frame_id) =\u003e {\n                    if deleted_frame_id != frame_id {\n                        return Err(StrErr::new(\n                            \"frame_id mismach between pointing frame_id and recorded frame_id\",\n                        ));\n                    }\n                }\n                None =\u003e {\n                    return Err(StrErr::new(\n                        \"page table does not have page received from current frame id\",\n                    ));\n                }\n            };\n        }\n        let maybe_old_frame = b\n            .page_table\n            .borrow_mut()\n            .insert(new_page_id, locked_frame.id);\n        match maybe_old_frame {\n            Some(_) =\u003e {\n                return Err(StrErr::new(\n                    \"inserting new page id but return unexpect item from map\",\n                ));\n            }\n            None =\u003e {}\n        };\n        Ok(())\n    }\n\n    fn fetch_frame\u003c'b\u003e(\n        b: \u0026MutexGuard\u003cBufferPool\u003cR\u003e\u003e,\n        free_frame: FrameID,\n    ) -\u003e Result\u003cArc\u003cMutex\u003cFrame\u003e\u003e, StrErr\u003e {\n        let chosen_frame_p: \u0026Arc\u003cMutex\u003cFrame\u003e\u003e;\n        unsafe {\n            // TODO: it this safe\n            chosen_frame_p =\n                \u0026mut *(\u0026mut b.frames.borrow_mut()[free_frame] as *mut Arc\u003cMutex\u003cFrame\u003e\u003e);\n        }\n        let chosen_frame = Arc::clone(chosen_frame_p);\n        Ok(chosen_frame)\n    }\n\n    fn new_page(mu: \u0026Mutex\u003cBufferPool\u003cR\u003e\u003e, dm: \u0026DiskManager) -\u003e Result\u003cArc\u003cMutex\u003cFrame\u003e\u003e, StrErr\u003e {\n        let b = mu.lock();\n\n        let (free_frame, victimed) = Self::_frame_from_freelist_or_replacer(\u0026b)?;\n        let chosen_frame = Self::fetch_frame(\u0026b, free_frame)?;\n        let mut locked_chosen_frame = chosen_frame.lock();\n        let new_page_id = Self::_allocate_page_id_locked(\u0026b);\n\n        Self::_prepare_new_frame_meta(\u0026b, \u0026locked_chosen_frame, free_frame, new_page_id)?;\n\n        drop(b);\n        if victimed \u0026\u0026 locked_chosen_frame.dirty {\n            dm.write_from_frame_to_file(\n                locked_chosen_frame.page_id,\n                \u0026mut locked_chosen_frame.raw_data[..],\n            )?;\n        }\n\n        locked_chosen_frame.assign_new(new_page_id)?;\n        locked_chosen_frame.pin();\n        drop(locked_chosen_frame);\n        Ok(chosen_frame)\n    }\n\n    fn _check_page_available_in_buffer(\n        b: \u0026MutexGuard\u003cBufferPool\u003cR\u003e\u003e,\n        page_id: PageID,\n    ) -\u003e Option\u003cFrameID\u003e {\n        let page_table = \u0026b.page_table.borrow();\n\n        let maybe_frame = page_table.get(\u0026page_id);\n        match maybe_frame {\n            Some(frame_id) =\u003e Some(*frame_id),\n            None =\u003e None,\n        }\n    }\n\n    fn _check_and_get_page_available_in_buffer(\n        b: \u0026MutexGuard\u003cBufferPool\u003cR\u003e\u003e,\n        page_id: PageID,\n    ) -\u003e Result\u003cOption\u003cArc\u003cMutex\u003cFrame\u003e\u003e\u003e, StrErr\u003e {\n        let page_table = \u0026b.page_table.borrow();\n\n        let maybe_frame = page_table.get(\u0026page_id);\n        match maybe_frame {\n            Some(frame_id) =\u003e {\n                let frame = Self::fetch_frame(\u0026b, *frame_id)?;\n                let mut locked_frame = frame.lock();\n                locked_frame.pin();\n                b.replacer.borrow().pin(*frame_id);\n                drop(locked_frame);\n                return Ok(Some(frame));\n            }\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn _frame_from_freelist_or_replacer(\n        b: \u0026MutexGuard\u003cBufferPool\u003cR\u003e\u003e,\n    ) -\u003e Result\u003c(FrameID, bool), StrErr\u003e {\n        if b.free_list.borrow().len() != 0 {\n            let maybe_frame = b.free_list.borrow_mut().pop_front();\n            match maybe_frame {\n                Some(popped) =\u003e return Ok((popped, false)),\n                None =\u003e {\n                    return Err(StrErr::new(\n                        \"free_list says it has len \u003e0, popping return 0 item\",\n                    ));\n                }\n            }\n        } else {\n            match b.replacer.victim() {\n                Some(frame_id) =\u003e return Ok((frame_id, true)),\n                None =\u003e {\n                    return Err(StrErr::new(\"oom\"));\n                }\n            };\n        }\n    }\n\n    fn fetch_page(\n        mu: \u0026Mutex\u003cBufferPool\u003cR\u003e\u003e,\n        dm: \u0026DiskManager,\n        page_id: PageID,\n    ) -\u003e Result\u003cArc\u003cMutex\u003cFrame\u003e\u003e, StrErr\u003e {\n        let b = mu.lock();\n\n        match Self::_check_and_get_page_available_in_buffer(\u0026b, page_id)? {\n            Some(frame) =\u003e return Ok(frame),\n            None =\u003e {}\n        };\n\n        // let mut victimed = false;\n        let (free_frame, victimed) = Self::_frame_from_freelist_or_replacer(\u0026b)?;\n\n        let chosen_frame = Self::fetch_frame(\u0026b, free_frame)?;\n        let mut locked_chosen_frame = chosen_frame.lock();\n\n        Self::_prepare_new_frame_meta(\u0026b, \u0026locked_chosen_frame, free_frame, page_id)?;\n\n        drop(b);\n        if victimed \u0026\u0026 locked_chosen_frame.dirty {\n            dm.write_from_frame_to_file(\n                locked_chosen_frame.page_id,\n                \u0026mut locked_chosen_frame.raw_data[..],\n            )?;\n        }\n        locked_chosen_frame.assign_new(page_id)?;\n        dm.read_into_frame(page_id, \u0026mut locked_chosen_frame.raw_data[..])?;\n\n        locked_chosen_frame.pin();\n        drop(locked_chosen_frame);\n        Ok(chosen_frame)\n    }\n\n    fn unpin_page(mu: \u0026Mutex\u003cBufferPool\u003cR\u003e\u003e, page_id: PageID, dirty: bool) -\u003e Result\u003cbool, StrErr\u003e {\n        let b = mu.lock();\n        match Self::_check_page_available_in_buffer(\u0026b, page_id) {\n            Some(frame_id) =\u003e {\n                let frame = Self::fetch_frame(\u0026b, frame_id)?;\n                let mut locked_frame = frame.lock();\n                locked_frame.pin_count -= 1;\n                locked_frame.dirty = dirty;\n                if locked_frame.pin_count == 0 {\n                    b.replacer.borrow().unpin(frame_id);\n                }\n                Ok(true)\n            }\n            None =\u003e Ok(false),\n        }\n    }\n    fn unpin_frame_locked\u003c'op\u003e(\n        mu: \u0026Mutex\u003cBufferPool\u003cR\u003e\u003e,\n        page_id: PageID,\n        locked: \u0026mut MutexGuard\u003c'op, Frame\u003e,\n        dirty: bool,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        let b = mu.lock();\n        locked.pin_count -= 1;\n        locked.dirty = dirty;\n        if locked.pin_count == 0 {\n            b.replacer.borrow().unpin(locked.id);\n        }\n        Ok(())\n    }\n\n    fn flush_frame_locked\u003c'op\u003e(\n        mu: \u0026Mutex\u003cBufferPool\u003cR\u003e\u003e,\n        page_id: PageID,\n        locked: \u0026mut MutexGuard\u003c'op, Frame\u003e,\n        dm: \u0026DiskManager,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        dm.write_from_frame_to_file(page_id, \u0026mut locked.raw_data[..])?;\n        Ok(())\n    }\n\n    // TODO: mark this page_id inside some reuseable page allocator\n    // + add deleted flag for future page fetch\n    fn delete_page_locked\u003c'op\u003e(\n        mu: \u0026Mutex\u003cBufferPool\u003cR\u003e\u003e,\n        mut locked: OwningHandle\u003cArc\u003cMutex\u003cFrame\u003e\u003e, MutexGuard\u003c'op, Frame\u003e\u003e,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        let b = mu.lock();\n        locked.pin_count -= 1;\n        locked.dirty = false;\n        if locked.pin_count == 0 {\n            b.replacer.borrow().unpin(locked.id);\n        } else {\n            panic!(\"Some other thread is hold an arc to a deleted page, need to handle this logic here\")\n        }\n        drop(b);\n        Ok(())\n    }\n\n    fn unpin_flush_frame_locked\u003c'op\u003e(\n        mu: \u0026Mutex\u003cBufferPool\u003cR\u003e\u003e,\n        page_id: PageID,\n        mut locked: OwningHandle\u003cArc\u003cMutex\u003cFrame\u003e\u003e, MutexGuard\u003c'op, Frame\u003e\u003e,\n        dm: \u0026DiskManager,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        let b = mu.lock();\n        locked.pin_count -= 1;\n        locked.dirty = false;\n        if locked.pin_count == 0 {\n            b.replacer.borrow().unpin(locked.id);\n        }\n        drop(b);\n        dm.write_from_frame_to_file(page_id, \u0026mut locked.raw_data[..])?;\n        Ok(())\n    }\n\n    fn flush_page(\n        mu: \u0026Mutex\u003cBufferPool\u003cR\u003e\u003e,\n        page_id: PageID,\n        dm: \u0026DiskManager,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        let b = mu.lock();\n        match Self::_check_page_available_in_buffer(\u0026b, page_id) {\n            Some(frame_id) =\u003e {\n                let frame = Self::fetch_frame(\u0026b, frame_id)?;\n                drop(b);\n                dm.write_from_frame_to_file(page_id, \u0026mut frame.lock().raw_data[..])?;\n            }\n            None =\u003e {}\n        }\n        Ok(())\n    }\n}\nconst EMPTY_PAGE: [u8; PAGE_SIZE] = [0u8; PAGE_SIZE];\n\nimpl Frame {\n    fn assign_new(\u0026mut self, new_page_id: PageID) -\u003e Result\u003c(), StrErr\u003e {\n        self.page_id = new_page_id;\n        self.dirty = false;\n\n        copy(\u0026mut \u0026EMPTY_PAGE[..], \u0026mut \u0026mut self.raw_data[..])?;\n        Ok(())\n    }\n\n    fn pin(\u0026mut self) {\n        self.pin_count += 1;\n    }\n}\n\npub type FrameID = usize;\npub type PageID = i64;\n\npub const INVALID_PAGE_ID: PageID = -1;\n\npub trait Replacer {\n    fn victim(\u0026self) -\u003e Option\u003cFrameID\u003e;\n\n    // frameID should not be victimized until unpin\n    fn pin(\u0026self, frame_id: FrameID);\n\n    // allow frame to be victimizedable\n    fn unpin(\u0026self, frame_id: FrameID);\n\n    // items that can be victimized\n    fn size(\u0026self) -\u003e i64;\n}\n\n#[repr(C)]\npub struct Frame {\n    id: FrameID,\n    page_id: PageID,\n    dirty: bool,\n    _1: [u8; 7],\n    raw_data: RawData,\n    pin_count: i64,\n    #[cfg(feature = \"testing\")]\n    last_borrower: String,\n}\nimpl Frame {\n    pub fn get_page_id(\u0026self) -\u003e i64 {\n        self.page_id\n    }\n    pub fn get_raw_data(\u0026mut self) -\u003e \u0026mut RawData {\n        \u0026mut self.raw_data\n    }\n\n    pub fn new_from_raw(raw_data: [u8; PAGE_SIZE]) -\u003e Frame {\n        Frame {\n            id: 0,\n            page_id: 0,\n            dirty: false,\n            _1: [0; 7],\n            pin_count: 0,\n            raw_data,\n            #[cfg(feature = \"testing\")]\n            last_borrower: String::new(),\n        }\n    }\n}\n\npub const PAGE_SIZE: usize = 4096;\npub type RawData = [u8; PAGE_SIZE];\n\npub struct DiskManager {\n    f: Mutex\u003cFile\u003e,\n    page_size: usize,\n}\n#[derive(Debug)]\npub struct StrErr {\n    root: String,\n}\nimpl StrErr {\n    pub fn new(st: \u0026str) -\u003e Self {\n        StrErr {\n            root: st.to_string(),\n        }\n    }\n}\n\nimpl std::convert::From\u003cError\u003e for StrErr {\n    fn from(e: Error) -\u003e Self {\n        StrErr {\n            root: e.to_string(),\n        }\n    }\n}\n\nimpl DiskManager {\n    pub fn new_from_file(f: File, page_size: u64) -\u003e Self {\n        return DiskManager {\n            f: Mutex::new(f),\n            page_size: (page_size as usize),\n        };\n    }\n    pub fn file_size(\u0026self) -\u003e Result\u003cu64, StrErr\u003e {\n        let f = self.f.lock();\n        let size = File::metadata(\u0026*f)\n            .expect(\"failed to get file metadata\")\n            .len();\n        return Ok(size);\n    }\n    pub fn new(filepath: String, page_size: u64) -\u003e Self {\n        File::create(filepath.clone()).expect(\"io error\");\n        let mut opts = OpenOptions::new();\n        opts.write(true).read(true).create(true).mode(0o666);\n        if cfg!(unix) {\n            opts.custom_flags(O_DIRECT);\n        }\n        let f = opts.open(filepath).unwrap();\n        return DiskManager {\n            f: Mutex::new(f),\n            page_size: (page_size as usize),\n        };\n    }\n\n    pub fn read_into_frame(\u0026self, page_id: PageID, buf: \u0026mut [u8]) -\u003e Result\u003c(), StrErr\u003e {\n        let mut f = self.f.lock();\n        f.seek(SeekFrom::Start(page_id as u64 * self.page_size as u64))?;\n        let read_bytes = f.read(\u0026mut buf[..self.page_size])?;\n        if read_bytes != self.page_size {\n            return Err(StrErr::new(\"not enough byte read\"));\n        }\n        Ok(())\n    }\n\n    pub fn write_from_frame_to_file(\u0026self, page_id: PageID, buf: \u0026mut [u8]) -\u003e Result\u003c(), StrErr\u003e {\n        if buf.len() != self.page_size {\n            return Err(StrErr::new(\"frame has invalid length\"));\n        }\n        let mut f = self.f.lock();\n        f.seek(SeekFrom::Start(page_id as u64 * self.page_size as u64))?;\n        let byte_written = f.write(buf)?;\n        if byte_written != self.page_size {\n            return Err(StrErr::new(\"invalid bytes written\"));\n        }\n        File::sync_all(\u0026mut f)?;\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::replacer::LRURepl;\n    use rand::{thread_rng, RngCore};\n    use std::io::{copy, Read};\n    use tempfile::tempfile;\n\n    #[test]\n    fn test_sample() {\n        let mut some_rng: Box\u003cdyn RngCore\u003e = Box::new(thread_rng());\n\n        let pool_size = 10;\n        let dm = DiskManager::new_from_file(tempfile().unwrap(), PAGE_SIZE as u64);\n        let repl = LRURepl::new(pool_size);\n        let bpm = BufferPool::new(10, repl);\n        let mu = Mutex::new(bpm);\n\n        let mut random_bin_data: [u8; PAGE_SIZE] = [0; PAGE_SIZE];\n        some_rng.read_exact(\u0026mut random_bin_data[..]).unwrap();\n\n        random_bin_data[PAGE_SIZE / 2] = '0' as u8;\n        random_bin_data[PAGE_SIZE - 1] = '0' as u8;\n        {\n            let page0 = BufferPool::new_page(\u0026mu, \u0026dm).unwrap();\n            assert_eq!(0, page0.lock().page_id);\n            let mut w = \u0026mut page0.lock().raw_data[..];\n            let mut r = \u0026random_bin_data[..];\n            copy(\u0026mut r, \u0026mut w).unwrap();\n        }\n\n        for _ in 1..pool_size {\n            match BufferPool::new_page(\u0026mu, \u0026dm) {\n                Ok(_) =\u003e {}\n                Err(some_err) =\u003e panic!(\"fetching page has err {:?}\", some_err),\n            };\n        }\n        for i in pool_size..pool_size * 2 {\n            match BufferPool::new_page(\u0026mu, \u0026dm) {\n                Ok(_) =\u003e {\n                    panic!(\"not expect this call to return success\")\n                }\n                Err(some_err) =\u003e assert_eq!(\"oom\", some_err.root),\n            };\n        }\n\n        for i in 0..5 {\n            assert_eq!(true, BufferPool::unpin_page(\u0026mu, i, true).unwrap());\n            BufferPool::flush_page(\u0026mu, i, \u0026dm).unwrap();\n        }\n\n        for i in 0..4 {\n            let some_page = BufferPool::new_page(\u0026mu, \u0026dm).unwrap();\n        }\n        let page0 = BufferPool::fetch_page(\u0026mu, \u0026dm, 0).unwrap();\n        assert_eq!(\u0026page0.lock().raw_data[..], \u0026random_bin_data[..]);\n        assert_eq!(true, BufferPool::unpin_page(\u0026mu, 0, false).unwrap());\n\n        match BufferPool::new_page(\u0026mu, \u0026dm) {\n            Ok(_) =\u003e {}\n            Err(some_err) =\u003e panic!(\"calling new page has err {:?}\", some_err),\n        }\n        match BufferPool::fetch_page(\u0026mu, \u0026dm, 0) {\n            Ok(_) =\u003e {\n                panic!(\"not expect this call to return success\")\n            }\n            Err(some_err) =\u003e assert_eq!(\"oom\", some_err.root),\n        }\n    }\n\n    #[test]\n    fn test_binary() {\n        let mut some_rng: Box\u003cdyn RngCore\u003e = Box::new(thread_rng());\n\n        let pool_size = 10;\n        let dm = DiskManager::new_from_file(tempfile().unwrap(), PAGE_SIZE as u64);\n        let repl = LRURepl::new(pool_size);\n        let bpm = BufferPool::new(10, repl);\n        let mu = Mutex::new(bpm);\n\n        let mut random_bin_data: [u8; PAGE_SIZE] = [0; PAGE_SIZE];\n        some_rng.read_exact(\u0026mut random_bin_data[..]).unwrap();\n\n        random_bin_data[PAGE_SIZE / 2] = '0' as u8;\n        random_bin_data[PAGE_SIZE - 1] = '0' as u8;\n        {\n            let page0 = BufferPool::new_page(\u0026mu, \u0026dm).unwrap();\n            assert_eq!(0, page0.lock().page_id);\n            let mut w = \u0026mut page0.lock().raw_data[..];\n            let mut r = \u0026random_bin_data[..];\n            copy(\u0026mut r, \u0026mut w).unwrap();\n        }\n\n        for _ in 1..pool_size {\n            match BufferPool::new_page(\u0026mu, \u0026dm) {\n                Ok(_) =\u003e {}\n                Err(some_err) =\u003e panic!(\"fetching page has err {:?}\", some_err),\n            };\n        }\n        for i in pool_size..pool_size * 2 {\n            match BufferPool::new_page(\u0026mu, \u0026dm) {\n                Ok(_) =\u003e {\n                    panic!(\"not expect this call to return success\")\n                }\n                Err(some_err) =\u003e assert_eq!(\"oom\", some_err.root),\n            };\n        }\n\n        for i in 0..5 {\n            assert_eq!(true, BufferPool::unpin_page(\u0026mu, i, true).unwrap());\n            BufferPool::flush_page(\u0026mu, i, \u0026dm).unwrap();\n        }\n\n        for i in 0..5 {\n            let some_page = BufferPool::new_page(\u0026mu, \u0026dm).unwrap();\n            // this is important, after this line, the lock of the page is drop, so\n            // that buffer pool can acquire the lock on the frame\n            let page_id = some_page.lock().page_id;\n            assert_eq!(true, BufferPool::unpin_page(\u0026mu, page_id, false).unwrap());\n        }\n        let page0 = BufferPool::fetch_page(\u0026mu, \u0026dm, 0).unwrap();\n        assert_eq!(\u0026page0.lock().raw_data[..], \u0026random_bin_data[..]);\n        assert_eq!(true, BufferPool::unpin_page(\u0026mu, 0, false).unwrap());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","btree.rs"],"content":"//TODO: manual lock/unlock is painful, try impl Drop that automatically returns the page latch to bpm\nuse crate::bpm::Frame;\nuse crate::bpm::INVALID_PAGE_ID;\nuse crate::bpm::PAGE_SIZE;\nuse crate::bpm::{BufferPoolManager, Replacer, StrErr};\nuse bytemuck::try_from_bytes_mut;\nuse bytemuck::{try_cast_slice_mut, Pod, Zeroable};\nuse iota::iota;\nuse owning_ref::OwningHandle;\nuse parking_lot::{Mutex, MutexGuard};\nuse std::fmt::Debug;\nuse std::marker::PhantomData;\nuse std::mem::size_of;\nuse std::sync::Arc;\nuse tinyvec::SliceVec;\n\ntrait DBType: Copy + Ord + Pod + Debug + Default {}\n\n#[allow(dead_code)]\nstruct Tree\u003c'a, R, K, V\u003e\nwhere\n    R: Replacer,\n    K: DBType,\n    V: DBType,\n{\n    h: \u0026'a mut HeaderPage,\n    h_lock: Arc\u003cMutex\u003cFrame\u003e\u003e,\n    bpm: \u0026'a BufferPoolManager\u003cR\u003e,\n    _1: PhantomData\u003c(K, V)\u003e,\n}\nstruct PageLatch\u003c'a, K: Pod, V: Pod\u003e {\n    // need this to handle lock/unlock\n    origin: OwningHandle\u003cArc\u003cMutex\u003cFrame\u003e\u003e, MutexGuard\u003c'a, Frame\u003e\u003e,\n    _mapped: NodePage\u003c'a, K, V\u003e,\n    ref_idx: usize,\n}\n\nstruct Access\u003c'a, K: DBType, V: DBType\u003e {\n    bread_crumbs: Vec\u003cPageLatch\u003c'a, K, V\u003e\u003e,\n    to_clean: Vec\u003cPageLatch\u003c'a, K, V\u003e\u003e,\n    flush_head: bool,\n    temp: Option\u003cPageLatch\u003c'a, K, V\u003e\u003e,\n    fetched_cousins: Vec\u003cPageLatch\u003c'a, K, V\u003e\u003e, // during borrowing, cousins\n                                               //may be prefetched and reuse for merge operations\n}\n\nimpl\u003c'a, K: DBType, V: DBType\u003e Access\u003c'a, K, V\u003e {\n    fn pop_next(\u0026mut self) -\u003e Option\u003cPageLatch\u003c'a, K, V\u003e\u003e {\n        let ret = self.bread_crumbs.pop()?;\n        return Some(ret);\n    }\n\n    fn add_flush(\u0026mut self, latch: PageLatch\u003c'a, K, V\u003e) {\n        self.to_clean.push(latch);\n    }\n\n    fn cache_fetched_cousins(\u0026mut self, cousin_latch: PageLatch\u003c'a, K, V\u003e) {\n        self.fetched_cousins.push(cousin_latch);\n    }\n\n    fn find_fetched_cousin(\u0026mut self, page_id: i64) -\u003e Option\u003cPageLatch\u003c'a, K, V\u003e\u003e {\n        let mut found_idx = -1;\n        for (idx, cousin) in self.fetched_cousins.iter().enumerate() {\n            if cousin.origin.get_page_id() == page_id {\n                found_idx = idx as i64;\n                break;\n            }\n        }\n        if found_idx == -1 {\n            panic!(\"not sure if this is reachable\");\n        }\n        let cousin = self.fetched_cousins.remove(found_idx as usize);\n        return Some(cousin);\n    }\n}\nimpl\u003cK: DBType, V: DBType\u003e Default for Access\u003c'_, K, V\u003e {\n    fn default() -\u003e Self {\n        Access {\n            bread_crumbs: vec![],\n            to_clean: vec![],\n            fetched_cousins: vec![],\n            temp: None,\n            flush_head: false,\n        }\n    }\n}\n\n#[allow(dead_code)]\nimpl\u003c'a, R: Replacer, K: DBType, V: DBType\u003e Tree\u003c'a, R, K, V\u003e {\n    fn _get_page\u003c'op\u003e(\u0026self, page_id: i64) -\u003e Result\u003cPageLatch\u003c'op, K, V\u003e, StrErr\u003e {\n        // let bpm = self.bpm;\n        let root_frame = self.bpm.fetch_page(page_id)?;\n\n        let mut guard = OwningHandle::new_with_fn(root_frame, |mutex: *const Mutex\u003cFrame\u003e| {\n            let mutex: \u0026Mutex\u003cFrame\u003e = unsafe { \u0026*mutex };\n            return mutex.lock();\n        });\n        let node: NodePage\u003c'op, K, V\u003e;\n        unsafe {\n            // this raw_data lives as long as the guard\n            let raw_data = \u0026mut *(guard.get_raw_data() as *mut [u8]);\n            node = NodePage::cast_generic(self.h.node_size, raw_data);\n        };\n\n        let b = PageLatch {\n            origin: guard,\n            _mapped: node,\n            ref_idx: 0,\n        };\n        Ok(b)\n    }\n\n    fn _get_root\u003c'op\u003e(\u0026mut self) -\u003e Result\u003cPageLatch\u003c'op, K, V\u003e, StrErr\u003e {\n        return self._get_page(self.h.root_id);\n    }\n\n    fn _search_leaf\u003c'op\u003e(\u0026mut self, search_key: \u0026K) -\u003e Result\u003cAccess\u003c'op, K, V\u003e, StrErr\u003e {\n        let mut acc = Access::default();\n        let root = self._get_root()?;\n\n        let mut cur_level = root._mapped.header.level;\n        let mut bread_crumb = root;\n        let mut idx_from_parent = 0;\n        while !bread_crumb._mapped.header.is_leaf {\n            assert!(\n                cur_level \u003e 0,\n                \"reached level 0 node but still have not found leaf node\"\n            );\n            if let PageData::B(ref branch) = bread_crumb._mapped.data {\n                idx_from_parent = branch.find_next_child(search_key);\n                bread_crumb.ref_idx = idx_from_parent;\n                let next = branch.children[idx_from_parent];\n                if next != INVALID_PAGE_ID {\n                    let next_node = self._get_page(next)?;\n                    cur_level -= 1;\n                    acc.bread_crumbs.push(bread_crumb);\n                    bread_crumb = next_node;\n                    continue;\n                }\n                panic!(\"cannot find correct node for key {:?}\", *search_key);\n            } else {\n                return Err(StrErr::new(\"page data is not branch page\"));\n            }\n        }\n        bread_crumb.ref_idx = idx_from_parent;\n        acc.bread_crumbs.push(bread_crumb);\n        return Ok(acc);\n    }\n    fn _new_empty_branch\u003c'op\u003e(\u0026self) -\u003e Result\u003cPageLatch\u003c'op, K, V\u003e, StrErr\u003e {\n        let frame_for_new_page = self.bpm.new_page().expect(\"unable to allocate new page\");\n        let mut guard =\n            OwningHandle::new_with_fn(frame_for_new_page, |mutex: *const Mutex\u003cFrame\u003e| {\n                let mutex: \u0026Mutex\u003cFrame\u003e = unsafe { \u0026*mutex };\n                return mutex.lock();\n            });\n        let node: NodePage\u003c'op, K, V\u003e;\n        unsafe {\n            // this raw_data lives as long as the guard\n            let raw_data = \u0026mut *(guard.get_raw_data() as *mut [u8]);\n\n            node = NodePage::cast_branch_from_blank(self.h.node_size, raw_data);\n        };\n\n        let b = PageLatch {\n            origin: guard,\n            _mapped: node,\n            ref_idx: 0,\n        };\n        Ok(b)\n    }\n\n    fn _new_empty_leaf\u003c'op\u003e(\u0026self) -\u003e Result\u003cPageLatch\u003c'op, K, V\u003e, StrErr\u003e {\n        let frame_for_new_page = self.bpm.new_page().expect(\"unable to allocate new page\");\n        let mut guard =\n            OwningHandle::new_with_fn(frame_for_new_page, |mutex: *const Mutex\u003cFrame\u003e| {\n                let mutex: \u0026Mutex\u003cFrame\u003e = unsafe { \u0026*mutex };\n                return mutex.lock();\n            });\n        let node: NodePage\u003c'op, K, V\u003e;\n        unsafe {\n            // this raw_data lives as long as the guard\n            let raw_data = \u0026mut *(guard.get_raw_data() as *mut [u8]);\n\n            node = NodePage::cast_leaf_from_blank(self.h.node_size, raw_data);\n        };\n\n        let b = PageLatch {\n            origin: guard,\n            _mapped: node,\n            ref_idx: 0,\n        };\n        Ok(b)\n    }\n    fn _split_branch_node\u003c'op\u003e(\n        \u0026self,\n        n: \u0026mut NodePage\u003c'op, K, V\u003e,\n    ) -\u003e Result\u003c(PageLatch\u003c'op, K, V\u003e, K), StrErr\u003e {\n        let mut new_right_node = self\n            ._new_empty_branch()\n            .expect(\"unable to create new blank branch\");\n        new_right_node._mapped.header.level = n.header.level;\n        let partition_idx = self.h.node_size as usize / 2;\n        let old_branch = n.data.branch();\n\n        let split_key = old_branch.keys[partition_idx];\n        let new_branch = \u0026mut new_right_node._mapped.data.branch();\n        new_branch\n            .keys\n            .extend_from_slice(\u0026old_branch.keys[partition_idx + 1..]);\n        new_branch\n            .children\n            .extend_from_slice(\u0026old_branch.children[partition_idx + 1..]);\n        for item in old_branch.keys[partition_idx..].iter_mut() {\n            *item = K::default()\n        }\n        for item in old_branch.children[partition_idx + 1..].iter_mut() {\n            *item = 0\n        }\n\n        old_branch.keys.truncate(partition_idx);\n        old_branch.children.truncate(partition_idx + 1);\n\n        // fix headers\n        new_right_node._mapped.header.size = n.header.size - partition_idx as i64 - 1;\n        n.header.size = partition_idx as i64;\n\n        Ok((new_right_node, split_key))\n    }\n\n    fn _split_leaf_node\u003c'op\u003e(\n        \u0026self,\n        n: \u0026mut NodePage\u003c'op, K, V\u003e,\n    ) -\u003e Result\u003c(PageLatch\u003c'op, K, V\u003e, K), StrErr\u003e {\n        let mut new_node = self\n            ._new_empty_leaf()\n            .expect(\"unable to create new blank leaf\");\n        let partition_idx = self.h.node_size as usize / 2;\n        let old_leaf = n.data.leaf();\n\n        let new_leaf = \u0026mut new_node._mapped.data.leaf();\n        new_leaf\n            .data\n            .extend_from_slice(\u0026old_leaf.data[partition_idx..]);\n        for item in old_leaf.data[partition_idx..].iter_mut() {\n            *item = Val::default()\n        }\n        old_leaf.data.truncate(partition_idx);\n\n        // fix headers\n        new_node._mapped.header.size = n.header.size - partition_idx as i64;\n        new_node._mapped.header.next = n.header.next;\n        n.header.size = partition_idx as i64;\n        n.header.next = new_node.origin.get_page_id();\n        let split_key = new_leaf.data[0].key;\n\n        Ok((new_node, split_key))\n    }\n\n    fn _insert_dirty\u003c'op\u003e(\u0026mut self, key: K, val: V) -\u003e Result\u003cAccess\u003c'op, K, V\u003e, StrErr\u003e {\n        let node_size = self.h.node_size;\n\n        // traverse the tree to find slot for this key\n        let mut acc = self._search_leaf(\u0026key)?;\n        let mut written_leaf_latch = acc.pop_next().expect(\"want at least one breadcrumb item\");\n        let mut leaf_header = \u0026mut written_leaf_latch._mapped.header;\n        let leaf_page = \u0026mut written_leaf_latch._mapped.data;\n\n        let leaf_data = leaf_page.leaf();\n        {\n            let comp = Val { key, val };\n            let idx = leaf_data.find_slot(\u0026comp)?;\n            leaf_data.data.insert(idx, comp);\n            leaf_header.size += 1;\n        }\n        // valid size\n        if leaf_header.size \u003c node_size {\n            acc.add_flush(written_leaf_latch);\n            return Ok(acc);\n        }\n        let (orphan, split_key) = self\n            ._split_leaf_node(\u0026mut written_leaf_latch._mapped)\n            .expect(\"unable to split node\");\n        let mut orphan_id = orphan.origin.get_page_id();\n        let mut split_key = split_key;\n        {\n            if acc.bread_crumbs.len() == 0 {\n                let mut new_root = self\n                    ._new_empty_branch()\n                    .expect(\"unable to create new blank branch\");\n                let new_level = orphan._mapped.header.level + 1;\n                new_root._mapped.header.level = new_level;\n                let new_root_branch = new_root._mapped.data.branch();\n                let current_root = self.h.root_id;\n                new_root._mapped.header.size += 1;\n                new_root_branch.children.push(current_root);\n                new_root_branch.children.push(orphan_id);\n                new_root_branch.keys.push(split_key);\n                self.h.root_id = new_root.origin.get_page_id();\n                acc.flush_head = true;\n\n                acc.add_flush(written_leaf_latch);\n                acc.add_flush(orphan);\n                acc.add_flush(new_root);\n                return Ok(acc);\n            }\n        }\n        acc.add_flush(written_leaf_latch);\n        acc.add_flush(orphan);\n\n        loop {\n            let mut current_parent_latch = acc.pop_next().expect(\"not expect return empty item\");\n            let current_parent = current_parent_latch._mapped.data.branch();\n            let idx = current_parent.find_slot(\u0026split_key)?;\n            current_parent.children.insert(idx + 1, orphan_id);\n            current_parent.keys.insert(idx, split_key);\n            current_parent_latch._mapped.header.size += 1;\n            if current_parent_latch._mapped.header.size \u003c node_size {\n                acc.add_flush(current_parent_latch);\n                return Ok(acc);\n            }\n\n            let (new_orphan, new_slit_key) = self\n                ._split_branch_node(\u0026mut current_parent_latch._mapped)\n                .expect(\"unable to split branch node\");\n            orphan_id = new_orphan.origin.get_page_id();\n\n            split_key = new_slit_key;\n            if acc.bread_crumbs.len() == 0 {\n                let mut new_root = self\n                    ._new_empty_branch()\n                    .expect(\"unable to create new blank branch\");\n                // acc.add_flush(new_root.origin.get_page_id());\n                let new_level = new_orphan._mapped.header.level + 1;\n                new_root._mapped.header.level = new_level;\n                new_root._mapped.header.size += 1;\n                let new_root_branch = new_root._mapped.data.branch();\n                let current_root = self.h.root_id;\n                new_root_branch.children.push(current_root);\n                new_root_branch.children.push(orphan_id);\n                new_root_branch.keys.push(split_key);\n                self.h.root_id = new_root.origin.get_page_id();\n                acc.flush_head = true;\n\n                acc.add_flush(new_root);\n                acc.add_flush(new_orphan);\n                acc.add_flush(current_parent_latch);\n                break;\n            }\n\n            acc.add_flush(new_orphan);\n            acc.add_flush(current_parent_latch);\n        }\n        return Ok(acc);\n    }\n    fn _return_access_to_bpm\u003c'op\u003e(\u0026self, mut acc: Access\u003c'op, K, V\u003e) -\u003e Result\u003c(), StrErr\u003e {\n        let bpm = self.bpm;\n        let h_lock = self.h_lock.clone();\n\n        let untouched = acc.bread_crumbs.into_iter().map(|x| x.origin);\n\n        if let Some(latch) = acc.temp {\n            acc.to_clean.push(latch);\n        }\n\n        let flush_unpins = acc.to_clean.into_iter().map(|x| x.origin);\n        let total_flushed = untouched\n            .chain(flush_unpins)\n            .chain(acc.fetched_cousins.into_iter().map(|x| x.origin));\n\n        bpm.batch_unpin_flush(total_flushed)\n            .expect(\"failed flushing in batch\");\n        if acc.flush_head {\n            let mut locked = h_lock.lock();\n            bpm.flush_locked(\u0026mut locked)\n                .expect(\"failed to flush header page\");\n        }\n\n        Ok(())\n    }\n\n    // Borrowing from cousins may cause deadlock, because there can be and scan leaf operation\n    // going on.\n    // TODO: make _get_page acquire a lock with retry mode\n    // Reference (Improved Latch Crabbing Protocol): https://15445.courses.cs.cmu.edu/fall2021/notes/08-indexconcurrency.pdf\n    fn _try_borrow_cousins_key\u003c'op\u003e(\n        \u0026self,\n        acc: \u0026mut Access\u003c'op, K, V\u003e,\n        parent: \u0026mut NodePage\u003c'op, K, V\u003e,\n        current_node: \u0026mut NodePage\u003c'op, K, V\u003e,\n        current_node_idx: usize,\n    ) -\u003e Result\u003cbool, StrErr\u003e {\n        let is_leaf = current_node.header.is_leaf;\n        let parent_branch = parent.data.branch();\n\n        // prefer borrowing for right cousin first, according to this\n        // https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html\n        if current_node_idx \u003c parent_branch.children.len() - 1 {\n            let right_cousin_id = parent_branch.children[current_node_idx + 1];\n            let mut right_cousin_latch = self._get_page(right_cousin_id)?;\n            if right_cousin_latch._mapped.header.size \u003e self.h.node_size / 2 {\n                //leaf\n                if is_leaf {\n                    let right_cousin = right_cousin_latch._mapped.data.leaf();\n                    let right_first = right_cousin.data[0];\n                    let current_leaf = current_node.data.leaf();\n\n                    current_leaf.data.push(right_first);\n                    current_node.header.size += 1;\n\n                    right_cousin.data.remove(0);\n                    right_cousin_latch._mapped.header.size -= 1;\n\n                    let new_key_for_parent = right_cousin.data[0].key;\n                    parent_branch.keys[current_node_idx] = new_key_for_parent;\n                    acc.cache_fetched_cousins(right_cousin_latch);\n                    return Ok(true);\n                }\n\n                //branch\n                let split_key = parent_branch.keys[current_node_idx];\n                let right_cousin = right_cousin_latch._mapped.data.branch();\n                let current_branch = current_node.data.branch();\n                current_branch.keys.push(split_key);\n                current_branch.children.push(right_cousin.children[0]);\n                current_node.header.size += 1;\n\n                let new_split_key = right_cousin.keys[0];\n                right_cousin.keys.remove(0);\n                right_cousin.children.remove(0);\n                right_cousin_latch._mapped.header.size -= 1;\n\n                parent_branch.keys[current_node_idx] = new_split_key;\n\n                acc.cache_fetched_cousins(right_cousin_latch);\n                return Ok(true);\n            }\n            acc.cache_fetched_cousins(right_cousin_latch);\n            return Ok(false);\n        }\n\n        // if current node has a right cousin\n        if current_node_idx \u003e 0 {\n            let left_cousin_id = parent_branch.children[current_node_idx - 1];\n            let mut left_cousin_latch = self._get_page(left_cousin_id)?;\n            if left_cousin_latch._mapped.header.size \u003e self.h.node_size / 2 {\n                //leaf\n                if is_leaf {\n                    let left_cousin = left_cousin_latch._mapped.data.leaf();\n                    let left_last_key = left_cousin.data.pop().unwrap();\n                    let current_leaf = current_node.data.leaf();\n                    current_leaf\n                        .data\n                        .resize(current_leaf.data.len() + 1, left_last_key);\n                    current_leaf.data.rotate_right(1);\n\n                    current_node.header.size += 1;\n                    left_cousin_latch._mapped.header.size -= 1;\n\n                    let new_key_for_parent = current_leaf.data[0].key;\n                    parent_branch.keys[current_node_idx - 1] = new_key_for_parent;\n                    acc.cache_fetched_cousins(left_cousin_latch);\n                    return Ok(true);\n                }\n\n                //branch\n                let split_key = parent_branch.keys[current_node_idx - 1];\n                let left_cousin = left_cousin_latch._mapped.data.branch();\n                let current_branch = current_node.data.branch();\n                current_branch\n                    .keys\n                    .resize(current_branch.keys.len() + 1, split_key);\n                current_branch.keys.rotate_right(1);\n                let left_cousin_last_child = left_cousin.children.pop().unwrap();\n                let left_cousin_last_key = left_cousin.keys.pop().unwrap();\n                current_branch\n                    .children\n                    .resize(current_branch.children.len(), left_cousin_last_child);\n\n                current_node.header.size += 1;\n                left_cousin_latch._mapped.header.size -= 1;\n\n                parent_branch.keys[current_node_idx - 1] = left_cousin_last_key;\n                acc.cache_fetched_cousins(left_cousin_latch);\n                return Ok(true);\n            }\n\n            acc.cache_fetched_cousins(left_cousin_latch);\n            return Ok(false);\n        }\n\n        panic!(\"not reach\");\n    }\n\n    // TODO: make this generic for leaf node and branch node\n    fn _merge_node_right_to_left\u003c'op\u003e(\n        \u0026self,\n        acc: \u0026mut Access\u003c'op, K, V\u003e,\n        parent: \u0026mut NodePage\u003c'op, K, V\u003e,\n        idx_of_left: usize,\n        left_node: \u0026mut NodePage\u003c'op, K, V\u003e,\n        right_node_latch: PageLatch\u003c'op, K, V\u003e,\n    ) -\u003e Result\u003c(), StrErr\u003e {\n        let is_leaf = left_node.header.is_leaf;\n        if !is_leaf {\n            let mut right_node = right_node_latch._mapped;\n            let parent_branch = parent.data.branch();\n            let left_branch = left_node.data.branch();\n            let right_branch = right_node.data.branch();\n            left_branch\n                .children\n                .extend_from_slice(\u0026right_branch.children[..]);\n            let old_split_key = parent_branch.keys[idx_of_left];\n            left_branch.keys.push(old_split_key);\n            left_branch.keys.extend_from_slice(\u0026right_branch.keys[..]);\n            left_node.header.size += right_branch.keys.len() as i64 + 1;\n\n            parent_branch.children.remove(idx_of_left + 1);\n            parent_branch.keys.remove(idx_of_left);\n            parent.header.size -= 1;\n            self.bpm.delete_page_locked(right_node_latch.origin)?;\n            return Ok(());\n        }\n        let mut right_node = right_node_latch._mapped;\n        let parent_branch = parent.data.branch();\n        let left_leaf = left_node.data.leaf();\n        let right_leaf = right_node.data.leaf();\n        left_leaf.data.extend_from_slice(\u0026right_leaf.data[..]);\n        left_node.header.size += right_leaf.data.len() as i64;\n        parent_branch.keys.remove(idx_of_left);\n        parent_branch.children.remove(idx_of_left + 1);\n        parent.header.size -= 1;\n\n        left_node.header.next = right_node.header.next;\n        self.bpm.delete_page_locked(right_node_latch.origin)?;\n        Ok(())\n    }\n\n    fn _delete_dirty\u003c'op\u003e(\u0026mut self, key: K) -\u003e Result\u003cAccess\u003c'op, K, V\u003e, StrErr\u003e {\n        let merge_threshold = self.h.node_size / 2;\n        let mut acc = self\n            ._search_leaf(\u0026key)\n            .expect(\"cannot find leaf node io insert to key\");\n        let mut node_page_latch = acc.pop_next().expect(\"not expect to return empty\");\n        let node_page = \u0026mut node_page_latch._mapped;\n        let leaf = node_page.data.leaf();\n        leaf.delete_with_key(\u0026key)?;\n        node_page.header.size -= 1;\n\n        let mut maybe_new_root = INVALID_PAGE_ID;\n        // let current_size = node_page.header.size;\n\n        // acc.add_flush(node_page_latch);\n        // while let Some(node_page_latch) = self._bubleup(\u0026mut acc,)\n        acc.temp = Some(node_page_latch);\n        while let Some(mut parent_latch) = acc.pop_next() {\n            let mut node_page_latch = acc.temp.take().unwrap();\n            let node_page = \u0026mut node_page_latch._mapped;\n            if node_page.header.size \u003e= merge_threshold {\n                acc.add_flush(node_page_latch);\n                acc.add_flush(parent_latch);\n                return Ok(acc);\n            }\n            let current_node_id = node_page_latch.origin.get_page_id();\n            let ref_idx = parent_latch.ref_idx;\n            if self._try_borrow_cousins_key(\n                \u0026mut acc,\n                \u0026mut parent_latch._mapped,\n                node_page,\n                ref_idx,\n            )? {\n                // CLEAN UP and return\n                acc.add_flush(node_page_latch);\n                acc.add_flush(parent_latch);\n                return Ok(acc);\n            }\n            let parent_branch = parent_latch._mapped.data.branch();\n            if ref_idx \u003e 0 {\n                let left_cousin_id = parent_branch.children[ref_idx - 1];\n\n                // let mut left_page_latch = self._get_page(left_cousin_id)?;\n                let mut left_page_latch = acc.find_fetched_cousin(left_cousin_id).unwrap();\n                self._merge_node_right_to_left(\n                    \u0026mut acc,\n                    \u0026mut parent_latch._mapped,\n                    ref_idx - 1,\n                    \u0026mut left_page_latch._mapped,\n                    node_page_latch,\n                )?;\n\n                maybe_new_root = left_cousin_id;\n                acc.temp = Some(parent_latch);\n                // acc.add_flush(left_page_latch);\n                acc.add_flush(left_page_latch);\n            } else if ref_idx \u003c parent_latch._mapped.header.size as usize {\n                let right_cousin_id = parent_branch.children[ref_idx + 1];\n\n                // this caching is to avoid deadlock (with current impl)\n                // because in previous step we always fetch cousin  (with raii lock) first to find if its keys are borrowable\n                let right_page_latch = acc.find_fetched_cousin(right_cousin_id).unwrap();\n                // let right_page_latch = self._get_page(right_cousin_id)?;\n                self._merge_node_right_to_left(\n                    \u0026mut acc,\n                    \u0026mut parent_latch._mapped,\n                    ref_idx,\n                    node_page,\n                    right_page_latch,\n                )?;\n\n                maybe_new_root = current_node_id;\n                acc.temp = Some(parent_latch);\n                // acc.add_flush(node_page_latch);\n                acc.add_flush(node_page_latch);\n            } else {\n                panic!(\n                    \"should not reach here, ref_idx {:?} and parent size: {:?}\",\n                    ref_idx, parent_latch._mapped.header.size\n                );\n            }\n        }\n        let previous_parent = acc.temp.take().unwrap();\n        // hard to imagine\n        // this is a case when a root node used to be a parent, but after merge, it has no key\n        // so the previous merged node is the new root node\n        if previous_parent._mapped.header.size == 0 {\n            if maybe_new_root != INVALID_PAGE_ID {\n                self.h.root_id = maybe_new_root;\n                acc.flush_head = true;\n\n                acc.add_flush(previous_parent);\n                return Ok(acc);\n            }\n        }\n        acc.add_flush(previous_parent);\n        Ok(acc)\n    }\n\n    fn insert(\u0026mut self, key: K, val: V) -\u003e Result\u003c(), StrErr\u003e {\n        let acc = self._insert_dirty(key, val).expect(\"failed to insert\");\n        let ret = self._return_access_to_bpm(acc);\n        #[cfg(feature = \"testing\")]\n        self.bpm.assert_clean_frame(\u0026[0]);\n        ret\n    }\n\n    fn delete(\u0026mut self, key: K) -\u003e Result\u003c(), StrErr\u003e {\n        let acc = self._delete_dirty(key).expect(\"failed to insert\");\n        let ret = self._return_access_to_bpm(acc);\n        #[cfg(feature = \"testing\")]\n        self.bpm.assert_clean_frame(\u0026[0]);\n        ret\n    }\n\n    fn new(bpm: \u0026'a BufferPoolManager\u003cR\u003e, node_size: i64) -\u003e Result\u003cTree\u003c'a, R, K, V\u003e, StrErr\u003e {\n        if bpm.dm.file_size()? \u003c PAGE_SIZE as u64 {\n            let header_frame = bpm.new_page().expect(\"failed to create new page\");\n            let mut locked_header = header_frame.lock();\n            if locked_header.get_page_id() != 0 {\n                return Err(StrErr::new(\"newly created header page has id not equal 0\"));\n            }\n            bpm.flush_locked(\u0026mut locked_header)?;\n        }\n        match bpm.fetch_page(0) {\n            Ok(header_frame) =\u003e {\n                // header_frame.into_inner().get_raw_data()\n                let mut locked_header = header_frame.lock();\n                // let raw = header_frame.get_raw_data();\n                let h = HeaderPage::cast(locked_header.get_raw_data());\n                let long_lived_header: \u0026'a mut HeaderPage;\n\n                // this is safe, as long as we make sure no other components can call\n                // unpin(page_0), which will make the frame containing header page\n                // be recycled to contains data from other data page\n                unsafe {\n                    long_lived_header = \u0026mut *(h as *mut HeaderPage);\n                }\n                if h.flags \u0026 HEADER_FLAG_LOCKED != 0 {\n                    return Err(StrErr::new(\"page file has been locked by other process\"));\n                }\n\n                h.flags ^= HEADER_FLAG_LOCKED;\n                if h.flags \u0026 HEADER_FLAG_INIT == 0 {\n                    h.flags ^= HEADER_FLAG_INIT;\n\n                    h.node_size = node_size;\n                    let root_page = bpm.new_page().expect(\"unable to allocate new page\");\n                    let mut locked_root_page = root_page.lock();\n                    let page_id = locked_root_page.get_page_id();\n                    // first time db is created, prepare an empty leaf-root node\n                    let _: NodePage\u003cK, V\u003e =\n                        NodePage::cast_leaf_from_blank(node_size, locked_root_page.get_raw_data());\n                    h.root_id = page_id;\n                    bpm.flush_locked(\u0026mut locked_header)\n                        .expect(\"can't flush page 0\"); // new root page\n                    bpm.flush_locked(\u0026mut locked_root_page)\n                        .expect(format!(\"cant flush page {:?}\", page_id).as_str());\n                    bpm.unpin_locked(\u0026mut locked_root_page, false)\n                        .expect(format!(\"cant unpin page {:?}\", page_id).as_str());\n                }\n\n                drop(locked_header);\n                Ok(Tree {\n                    h: long_lived_header,\n                    h_lock: header_frame,\n                    bpm,\n                    _1: PhantomData,\n                })\n            }\n            Err(some_err) =\u003e Err(StrErr::new(format!(\"todo: {:?}\", some_err).as_str())),\n        }\n    }\n}\n\n#[allow(dead_code)]\nimpl\u003c'a, K, V\u003e NodePage\u003c'a, K, V\u003e\nwhere\n    K: Pod + Sized,\n    V: Pod + Sized,\n{\n    fn cast_generic(node_size: i64, raw: \u0026'a mut [u8]) -\u003e NodePage\u003c'a, K, V\u003e {\n        let (raw_header, next) = raw.split_at_mut(size_of::\u003cPageHeader\u003e());\n        let header = try_from_bytes_mut::\u003cPageHeader\u003e(raw_header).unwrap();\n        let page_data: PageData\u003c'a, K, V\u003e;\n        match header.is_leaf {\n            true =\u003e {\n                let end = node_size as usize * size_of::\u003cVal\u003cK, V\u003e\u003e();\n                let (raw_data, _) = next.split_at_mut(end);\n                let leaf_data: \u0026mut [Val\u003cK, V\u003e] = try_cast_slice_mut(raw_data).unwrap();\n                let leaf_data = SliceVec::from_slice_len(leaf_data, header.size as usize);\n                page_data = PageData::L(LeafData { data: leaf_data });\n            }\n            false =\u003e {\n                let keys_end = node_size as usize * size_of::\u003cK\u003e();\n                let (raw_keys, next) = next.split_at_mut(keys_end);\n                let keys: \u0026mut [K] = try_cast_slice_mut(raw_keys).unwrap();\n                let keys = SliceVec::from_slice_len(keys, header.size as usize);\n\n                let children_end = (node_size + 1) as usize * size_of::\u003ci64\u003e();\n                let (raw_children, _) = next.split_at_mut(children_end);\n                let children: \u0026mut [i64] = try_cast_slice_mut(raw_children).unwrap();\n                let children = SliceVec::from_slice_len(children, header.size as usize + 1);\n                page_data = PageData::B(BranchData { keys, children });\n            }\n        }\n        let node = NodePage {\n            data: page_data,\n            header,\n        };\n        node\n    }\n\n    fn cast_leaf_from_blank(node_size: i64, raw: \u0026'a mut [u8]) -\u003e NodePage\u003c'a, K, V\u003e {\n        let (raw_header, next) = raw.split_at_mut(32);\n        let header = try_from_bytes_mut::\u003cPageHeader\u003e(raw_header).unwrap();\n        let page_data: PageData\u003c'a, K, V\u003e;\n        header.is_leaf = true;\n        header.next = INVALID_PAGE_ID;\n\n        let end = node_size as usize * size_of::\u003cVal\u003cK, V\u003e\u003e();\n        let (raw_data, _) = next.split_at_mut(end);\n        let leaf_data: \u0026mut [Val\u003cK, V\u003e] = try_cast_slice_mut(raw_data).unwrap();\n        let leaf_data = SliceVec::from_slice_len(leaf_data, 0);\n        page_data = PageData::L(LeafData { data: leaf_data });\n\n        let node = NodePage {\n            data: page_data,\n            header,\n        };\n        node\n    }\n\n    fn cast_branch_from_blank(node_size: i64, raw: \u0026'a mut [u8]) -\u003e NodePage\u003c'a, K, V\u003e {\n        let (raw_header, next) = raw.split_at_mut(32);\n        let header = try_from_bytes_mut::\u003cPageHeader\u003e(raw_header).unwrap();\n        let page_data: PageData\u003c'a, K, V\u003e;\n        header.is_leaf = false;\n\n        let keys_end = node_size as usize * size_of::\u003cK\u003e();\n        let (raw_keys, next) = next.split_at_mut(keys_end);\n        let keys: \u0026mut [K] = try_cast_slice_mut(raw_keys).unwrap();\n        let keys = SliceVec::from_slice_len(keys, 0);\n        let children_end = (node_size + 1) as usize * size_of::\u003ci64\u003e();\n        let (raw_children, _) = next.split_at_mut(children_end);\n        let children: \u0026mut [i64] = try_cast_slice_mut(raw_children).unwrap();\n        let children = SliceVec::from_slice_len(children, 0);\n        page_data = PageData::B(BranchData { keys, children });\n        let node = NodePage {\n            data: page_data,\n            header,\n        };\n        node\n    }\n}\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Default)]\nstruct Val\u003cK, V\u003e {\n    key: K,\n    val: V,\n}\n\n// unsafe impl Zeroable for PageHeader {}\nunsafe impl\u003cK: Pod, V: Pod\u003e Pod for Val\u003cK, V\u003e {}\nunsafe impl\u003cK: Pod, V: Pod\u003e Zeroable for Val\u003cK, V\u003e {}\n\nunsafe impl Pod for PageHeader {}\nunsafe impl Zeroable for PageHeader {}\n\nimpl\u003c'a, K: DBType, V: DBType\u003e LeafData\u003c'a, K, V\u003e {\n    fn delete_with_key(\u0026mut self, key: \u0026K) -\u003e Result\u003c(), StrErr\u003e {\n        let idx = self.data.binary_search_by(|\u0026x| x.key.cmp(key)).expect(\n            format!(\n                \"failed to binary search at index {:?} with key {:?}\",\n                self.data, key,\n            )\n            .as_str(),\n        );\n        self.data.remove(idx);\n        Ok(())\n    }\n\n    fn find_slot(\u0026self, data_key: \u0026Val\u003cK, V\u003e) -\u003e Result\u003cusize, StrErr\u003e {\n        let idx = self.data.partition_point(|\u0026x| x.key \u003c= data_key.key);\n        if idx \u003c self.data.len() \u0026\u0026 self.data[idx] == *data_key {\n            return Err(StrErr::new(\"duplicate key found\"));\n        }\n        return Ok(idx);\n    }\n}\n\nimpl\u003c'a, K: DBType\u003e BranchData\u003c'a, K\u003e {\n    fn find_next_child(\u0026self, search_key: \u0026K) -\u003e usize {\n        return self.keys.partition_point(|\u0026x| x \u003c= *search_key);\n    }\n    fn find_slot(\u0026self, data_key: \u0026K) -\u003e Result\u003cusize, StrErr\u003e {\n        let idx = self.keys.partition_point(|\u0026x| x \u003c= *data_key);\n        if idx \u003c self.keys.len() \u0026\u0026 self.keys[idx] == *data_key {\n            return Err(StrErr::new(\"duplicate key found\"));\n        }\n        return Ok(idx);\n    }\n}\n\nstruct NodePage\u003c'a, K, V\u003e\nwhere\n    K: Sized + Pod,\n    V: Sized + Pod,\n{\n    header: \u0026'a mut PageHeader,\n    data: PageData\u003c'a, K, V\u003e,\n}\nimpl\u003c'a, K: Sized + Pod, V: Sized + Pod\u003e PageData\u003c'a, K, V\u003e {\n    fn branch(\u0026mut self) -\u003e \u0026mut BranchData\u003c'a, K\u003e {\n        if let PageData::B(some_branch) = self {\n            some_branch\n        } else {\n            panic!(\"want branch data\")\n        }\n    }\n    fn leaf(\u0026mut self) -\u003e \u0026mut LeafData\u003c'a, K, V\u003e {\n        if let PageData::L(some_leaf) = self {\n            some_leaf\n        } else {\n            panic!(\"want leaf data\")\n        }\n    }\n}\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct PageHeader {\n    is_deleted: bool,\n    is_leaf: bool,\n    _padding2: [u8; 6],\n    level: i64,\n    size: i64, // size of keys(for branch) or data (for leaf)\n    next: i64,\n}\n\nenum PageData\u003c'a, K, V\u003e\nwhere\n    K: Sized + Pod,\n    V: Sized + Pod,\n{\n    B(BranchData\u003c'a, K\u003e),\n    L(LeafData\u003c'a, K, V\u003e),\n}\n\nunsafe impl Pod for HeaderPage {}\nunsafe impl Zeroable for HeaderPage {}\n\n#[repr(C)]\n#[derive(Copy, Clone, Debug, PartialEq)]\nstruct HeaderPage {\n    flags: i64,\n    root_id: i64,\n    node_size: i64,\n}\n/* unsafe impl Pod for HeaderPage {}\nunsafe impl Zeroable for HeaderPage {} */\n\nimpl HeaderPage {\n    fn cast(raw: \u0026mut [u8]) -\u003e \u0026mut HeaderPage {\n        try_from_bytes_mut::\u003cHeaderPage\u003e(\u0026mut raw[..size_of::\u003cHeaderPage\u003e()]).unwrap()\n    }\n}\n\nstruct BranchData\u003c'a, K\u003e\nwhere\n    K: Sized + Pod,\n{\n    // keys: \u0026'a mut [K],\n    keys: SliceVec\u003c'a, K\u003e,\n    children: SliceVec\u003c'a, i64\u003e,\n    // children: \u0026'a mut [i64],\n}\n\n#[derive(Debug)]\nstruct LeafData\u003c'a, K, V\u003e\nwhere\n    V: Sized + Clone + Pod,\n    K: Sized + Clone + Pod,\n{\n    // data: \u0026'a mut [Val\u003cK, V\u003e],\n    data: SliceVec\u003c'a, Val\u003cK, V\u003e\u003e,\n}\n\niota! {\n    const HEADER_FLAG_INIT: i64 = 1 \u003c\u003c iota;\n    , HEADER_FLAG_LOCKED\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use crate::bpm::PAGE_SIZE;\n    use crate::{bpm::DiskManager, replacer::LRURepl};\n    use bytemuck::Pod;\n    // use core::fmt::Formatter;\n    use rand::{seq, thread_rng, Rng, RngCore};\n    use std::fmt::Formatter;\n    use std::io::{Read, Seek, SeekFrom, Write};\n    use tempfile::tempfile;\n\n    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Default)]\n    struct KeyT {\n        main: i64,\n        sub: i64,\n    }\n    impl Debug for KeyT {\n        fn fmt(\u0026self, fmt: \u0026mut Formatter\u003c'_\u003e) -\u003e Result\u003c(), std::fmt::Error\u003e {\n            fmt.write_str(format!(\"{}-{}\", self.main, self.sub).as_str())\n        }\n    }\n    impl Into\u003cKeyT\u003e for i64 {\n        fn into(self) -\u003e KeyT {\n            KeyT { main: self, sub: 0 }\n        }\n    }\n    pub trait Into2\u003cT\u003e: Sized {\n        fn into2(self) -\u003e T;\n    }\n\n    impl\u003cT: Into\u003cKeyT\u003e\u003e Into2\u003cVec\u003cKeyT\u003e\u003e for Vec\u003cT\u003e {\n        fn into2(self) -\u003e Vec\u003cKeyT\u003e {\n            self.into_iter().map(|k| k.into()).collect()\n        }\n    }\n\n    unsafe impl Pod for KeyT {}\n    unsafe impl Zeroable for KeyT {}\n    impl DBType for KeyT {}\n    fn make_tree_key(input: \u0026[i64]) -\u003e Vec\u003cKeyT\u003e {\n        let mut ret = vec![];\n        for i in input {\n            ret.push(KeyT { main: *i, sub: 0 });\n        }\n        ret\n    }\n    fn make_tree_val(input: \u0026[i64]) -\u003e Vec\u003cVal\u003cKeyT, KeyT\u003e\u003e {\n        let mut ret = vec![];\n        for item in input {\n            let temp = KeyT {\n                main: *item,\n                sub: 0,\n            };\n            ret.push(Val {\n                key: temp,\n                val: temp,\n            });\n        }\n        ret\n    }\n    fn sequential_until(last: i64) -\u003e Vec\u003cKeyT\u003e {\n        let mut ret = vec![];\n        for i in 1..=last {\n            ret.push(KeyT { main: i, sub: 0 });\n        }\n        ret\n    }\n    fn inverted_sequential_until(last: i64) -\u003e Vec\u003cKeyT\u003e {\n        let mut ret = vec![];\n        for i in (1..=last).rev() {\n            ret.push(KeyT { main: i, sub: 0 });\n        }\n        ret\n    }\n\n    #[test]\n    fn test_delete() {\n        _check_deadlock();\n        let max_size = 10;\n        struct Testcase {\n            insertions: Vec\u003cKeyT\u003e,\n            deletions: Vec\u003cKeyT\u003e,\n            root_keys: Vec\u003cKeyT\u003e,\n            leaf_vals: Vec\u003c\u0026'static [i64]\u003e,\n            node_size: i64,\n        }\n        let tcases: Vec\u003cTestcase\u003e = vec![\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(5),\n                deletions: vec![2].into2(),\n                root_keys: make_tree_key(\u0026[3, 4]),\n                leaf_vals: vec![\u0026[1], \u0026[3], \u0026[4, 5]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(3),\n                deletions: vec![2, 1].into2(),\n                root_keys: vec![3].into2(),\n                leaf_vals: vec![\u0026[3]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(3),\n                deletions: vec![1].into2(),\n                root_keys: vec![3].into2(),\n                leaf_vals: vec![\u0026[2], \u0026[3]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: inverted_sequential_until(10),\n                deletions: vec![10, 9, 8].into2(),\n                root_keys: vec![5].into2(),\n                leaf_vals: vec![\u0026[1, 2], \u0026[3, 4], \u0026[5, 6], \u0026[7]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(8),\n                deletions: vec![4].into2(),\n                root_keys: vec![3, 6].into2(),\n                leaf_vals: vec![\u0026[1], \u0026[2], \u0026[3], \u0026[5], \u0026[6], \u0026[7, 8]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(6),\n                deletions: vec![2].into2(),\n                root_keys: vec![4].into2(),\n                leaf_vals: vec![\u0026[1], \u0026[3], \u0026[4], \u0026[5, 6]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(5),\n                deletions: vec![5, 4, 3].into2(),\n                root_keys: vec![2].into2(),\n                leaf_vals: vec![\u0026[1], \u0026[2]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(5),\n                deletions: vec![5, 4, 3, 2].into2(),\n                root_keys: vec![1].into2(),\n                leaf_vals: vec![\u0026[1]],\n            },\n        ];\n        for case in tcases {\n            let some_file = tempfile().unwrap();\n            let repl = LRURepl::new(max_size);\n            let dm = DiskManager::new_from_file(some_file, PAGE_SIZE as u64);\n            let bpm = BufferPoolManager::new(max_size, repl, dm);\n\n            let mut some_tree: Tree\u003c_, KeyT, KeyT\u003e =\n                Tree::new(\u0026bpm, case.node_size).expect(\"can't create new tree\");\n\n            for insertion in case.insertions {\n                some_tree\n                    .insert(insertion, insertion)\n                    .expect(format!(\"failed to insert item {:?}\", insertion).as_str());\n            }\n            for deletion in case.deletions {\n                some_tree\n                    .delete(deletion)\n                    .expect(format!(\"failed to delete key {:?}\", deletion).as_str());\n            }\n            #[cfg(feature = \"testing\")]\n            some_tree.bpm.assert_clean_frame(\u0026[0]);\n\n            let left_most = KeyT { main: -1, sub: 0 };\n            let mut acc = some_tree\n                ._search_leaf(\u0026left_most)\n                .expect(\"unable to search left most leaf\");\n            let left_most_node = acc.pop_next().expect(\"not expect returning none\");\n            let mut cur_page_id = left_most_node.origin.get_page_id();\n            acc.add_flush(left_most_node);\n            some_tree\n                ._return_access_to_bpm(acc)\n                .expect(\"err during flushing access obj\");\n\n            let mut root_latch = some_tree._get_root().expect(\"failed to get root\");\n            match root_latch._mapped.header.is_leaf {\n                true =\u003e {\n                    let root_leaf = root_latch._mapped.data.leaf();\n                    assert!(\n                        case.root_keys\n                            .iter()\n                            .zip(root_leaf.data.iter())\n                            .all(|(a, b)| *a == b.key),\n                        \"root keys not match: expect {:?}, has {:?}\",\n                        case.root_keys,\n                        root_leaf.data\n                    );\n                }\n                false =\u003e {\n                    let root_branch = root_latch._mapped.data.branch();\n                    assert!(\n                        case.root_keys\n                            .iter()\n                            .zip(root_branch.keys.iter())\n                            .all(|(a, b)| a == b),\n                        \"root keys not match: expect {:?}, has {:?}\",\n                        case.root_keys,\n                        root_branch.keys\n                    );\n                }\n            }\n\n            /* let root_branch = root_latch._mapped.data.branch();\n            assert!(\n                case.root_keys\n                    .iter()\n                    .zip(root_branch.keys.iter())\n                    .all(|(a, b)| a == b),\n                \"root keys not match: expect {:?}, has {:?}\",\n                case.root_keys,\n                root_branch.keys\n            ); */\n            let st: Vec\u003cOwningHandle\u003cArc\u003cMutex\u003cFrame\u003e\u003e, MutexGuard\u003cFrame\u003e\u003e\u003e =\n                vec![root_latch].into_iter().map(|l| l.origin).collect();\n            some_tree\n                .bpm\n                .batch_unpin_flush(st.into_iter())\n                .expect(\"failed to batch flush root page\");\n            // assert.Equal(t, tc.rootKeys, root.keys[:root.size])\n\n            for (idx, raw_node_val) in case.leaf_vals.iter().enumerate() {\n                let typed_node_val = make_tree_val(*raw_node_val);\n                let mut page_latch = some_tree\n                    ._get_page(cur_page_id)\n                    .expect(format!(\"failed to get page {:?}\", cur_page_id).as_str());\n                let real_node_val = \u0026page_latch._mapped.data.leaf().data;\n                assert!(\n                    typed_node_val\n                        .iter()\n                        .zip(real_node_val.iter())\n                        .all(|(a, b)| a == b),\n                    \"case {:?} failed keys slices are not equal expect {:?} vs real {:?}\",\n                    idx,\n                    typed_node_val,\n                    real_node_val,\n                );\n                cur_page_id = page_latch._mapped.header.next;\n            }\n        }\n    }\n\n    fn _check_deadlock() {\n        #[cfg(feature = \"testing\")]\n        {\n            // only for #[cfg]\n            use parking_lot::deadlock;\n            use std::thread;\n            use std::time::Duration;\n\n            // Create a background thread which checks for deadlocks every 10s\n            thread::spawn(move || loop {\n                thread::sleep(Duration::from_secs(2));\n                let deadlocks = deadlock::check_deadlock();\n                if deadlocks.is_empty() {\n                    continue;\n                }\n\n                println!(\"{} deadlocks detected\", deadlocks.len());\n                for (i, threads) in deadlocks.iter().enumerate() {\n                    println!(\"Deadlock #{}\", i);\n                    for t in threads {\n                        println!(\"Thread Id {:#?}\", t.thread_id());\n                        println!(\"{:#?}\", t.backtrace());\n                    }\n                }\n            });\n        }\n    }\n\n    #[test]\n    fn test_insert() {\n        let max_size = 10;\n        struct Testcase {\n            insertions: Vec\u003cKeyT\u003e,\n            root_keys: Vec\u003cKeyT\u003e,\n            leaf_vals: Vec\u003c\u0026'static [i64]\u003e,\n            node_size: i64,\n        }\n        let tcases: Vec\u003cTestcase\u003e = vec![\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(4),\n                root_keys: make_tree_key(\u0026[2, 3]),\n                leaf_vals: vec![\u0026[1], \u0026[2], \u0026[3, 4]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(3),\n                root_keys: make_tree_key(\u0026[2]),\n                leaf_vals: vec![\u0026[1], \u0026[2, 3]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: inverted_sequential_until(10),\n                root_keys: make_tree_key(\u0026[7]),\n                leaf_vals: vec![\u0026[1, 2], \u0026[3, 4], \u0026[5, 6], \u0026[7, 8], \u0026[9, 10]],\n            },\n            Testcase {\n                node_size: 3,\n                insertions: sequential_until(6),\n                root_keys: vec![3].into2(),\n                leaf_vals: vec![\u0026[1], \u0026[2], \u0026[3], \u0026[4], \u0026[5, 6]],\n            },\n            Testcase {\n                node_size: 4,\n                insertions: make_tree_key(\u0026[1, 3, 5, 9, 10]),\n                root_keys: vec![5].into2(),\n                leaf_vals: vec![\u0026[1, 3], \u0026[5, 9, 10]],\n            },\n            Testcase {\n                node_size: 7,\n                insertions: sequential_until(13),\n                root_keys: vec![4, 7, 10].into2(),\n                leaf_vals: vec![\u0026[1, 2, 3], \u0026[4, 5, 6], \u0026[7, 8, 9], \u0026[10, 11, 12, 13]],\n            },\n        ];\n        for case in tcases {\n            let some_file = tempfile().unwrap();\n            let repl = LRURepl::new(max_size);\n            let dm = DiskManager::new_from_file(some_file, PAGE_SIZE as u64);\n            let bpm = BufferPoolManager::new(max_size, repl, dm);\n\n            let mut some_tree: Tree\u003c_, KeyT, KeyT\u003e =\n                Tree::new(\u0026bpm, case.node_size).expect(\"can't create new tree\");\n\n            for insertion in case.insertions {\n                some_tree\n                    .insert(insertion, insertion)\n                    .expect(format!(\"failed to insert item {:?}\", insertion).as_str());\n            }\n\n            #[cfg(feature = \"testing\")]\n            some_tree.bpm.assert_clean_frame(\u0026[0]);\n\n            let left_most = KeyT { main: -1, sub: 0 };\n            let mut acc = some_tree\n                ._search_leaf(\u0026left_most)\n                .expect(\"unable to search left most leaf\");\n            let left_most_node = acc.pop_next().expect(\"not expect returning none\");\n            let mut cur_page_id = left_most_node.origin.get_page_id();\n            acc.add_flush(left_most_node);\n            some_tree\n                ._return_access_to_bpm(acc)\n                .expect(\"err during flushing access obj\");\n\n            let mut root_latch = some_tree._get_root().expect(\"failed to get root\");\n            let root_branch = root_latch._mapped.data.branch();\n            assert!(\n                case.root_keys\n                    .iter()\n                    .zip(root_branch.keys.iter())\n                    .all(|(a, b)| a == b),\n                \"root keys not match expect {:?} really {:?}\",\n                case.root_keys,\n                root_branch.keys\n            );\n            let st: Vec\u003cOwningHandle\u003cArc\u003cMutex\u003cFrame\u003e\u003e, MutexGuard\u003cFrame\u003e\u003e\u003e =\n                vec![root_latch].into_iter().map(|l| l.origin).collect();\n            some_tree\n                .bpm\n                .batch_unpin_flush(st.into_iter())\n                .expect(\"failed to batch flush root page\");\n            // assert.Equal(t, tc.rootKeys, root.keys[:root.size])\n\n            for (idx, raw_node_val) in case.leaf_vals.iter().enumerate() {\n                let typed_node_val = make_tree_val(*raw_node_val);\n                let mut page_latch = some_tree\n                    ._get_page(cur_page_id)\n                    .expect(format!(\"failed to get page {:?}\", cur_page_id).as_str());\n                let real_node_val = \u0026page_latch._mapped.data.leaf().data;\n                assert!(\n                    typed_node_val\n                        .iter()\n                        .zip(real_node_val.iter())\n                        .all(|(a, b)| a == b),\n                    \"case {:?} failed keys slices are not equal expect {:?} vs real {:?}\",\n                    idx,\n                    typed_node_val,\n                    real_node_val,\n                );\n                cur_page_id = page_latch._mapped.header.next;\n            }\n        }\n    }\n\n    #[test]\n    fn test_bin_search() {\n        let mut keys = vec![];\n        let mut children = vec![-1];\n        for i in 0..10 {\n            keys.push(KeyT { main: i, sub: 0 });\n            children.push(i);\n        }\n        #[derive(Debug)]\n        struct Suite {\n            key: Vec\u003cKeyT\u003e,\n            children: Vec\u003ci64\u003e,\n            search_key: i64,\n            expect_index: usize,\n        }\n        let mut test_case = vec![\n            Suite {\n                key: vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9].into2(),\n                children: vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n                search_key: 0,\n                expect_index: 1,\n            },\n            Suite {\n                key: vec![2].into2(),\n                children: vec![1, 2],\n                search_key: 4,\n                expect_index: 1,\n            },\n        ];\n\n        // vector from 0..9\n\n        // (size of slice, search key, expect index returned)\n        // let suites = vec![(9, 0, 1), (9, -1, 0), (9, 9, 9)];\n        for case in \u0026mut test_case {\n            let keys = \u0026mut case.key;\n            let length = keys.len();\n            let children = \u0026mut case.children;\n            let branch = BranchData {\n                keys: SliceVec::from_slice_len(\u0026mut keys[..], length),\n                children: SliceVec::from_slice_len(\u0026mut children[..], length + 1),\n            };\n            /* let header = PageHeader {\n                is_deleted: false,\n                is_leaf: false,\n                _padding2: [0; 6],\n                level: 0,\n                size: length as i64,\n                next: 0,\n            }; */\n\n            let ret = branch.find_next_child(\u0026KeyT {\n                main: case.search_key,\n                sub: 0,\n            });\n            assert_eq!(case.expect_index, ret, \"failed at item {:?}\", case);\n        }\n    }\n\n    #[test]\n    fn test_cast_header() {\n        let root_page_id = 7;\n        let flags = HEADER_FLAG_INIT;\n        let node_size = 9;\n\n        let mut some_file = tempfile().unwrap();\n        let mut fake_data: [u8; PAGE_SIZE] = [0; PAGE_SIZE];\n        let mut h = HeaderPage::cast(\u0026mut fake_data[..]);\n        h.node_size = node_size;\n        h.flags = flags;\n        h.root_id = root_page_id;\n        some_file.write_all(\u0026mut fake_data[..]).unwrap();\n        some_file.flush().unwrap();\n        some_file.seek(SeekFrom::Start(0)).unwrap();\n\n        let mut new_buf: [u8; PAGE_SIZE] = [0; PAGE_SIZE];\n        some_file.read_exact(\u0026mut new_buf[..]).unwrap();\n        let h2 = HeaderPage::cast(\u0026mut new_buf[..]);\n        assert_eq!(node_size, h2.node_size);\n        assert_eq!(flags, h2.flags);\n        assert_eq!(root_page_id, h2.root_id);\n    }\n\n    #[test]\n    fn test_cast_branch() {\n        let mut some_rng: Box\u003cdyn RngCore\u003e = Box::new(thread_rng());\n        let node_size = 7;\n        let size = 7;\n        let next = 7;\n        let level = 10;\n        let mut some_file = tempfile().unwrap();\n        let mut fake_data: [u8; PAGE_SIZE] = [0; PAGE_SIZE];\n        let mut some_page: NodePage\u003cKeyT, KeyT\u003e =\n            NodePage::cast_branch_from_blank(node_size, \u0026mut fake_data[..]);\n        some_page.header.size = size;\n        some_page.header.level = level;\n        let mut branch_data: BranchData\u003c_\u003e;\n        match some_page.data {\n            PageData::B(branch) =\u003e {\n                assert_eq!(node_size as usize + 1, branch.children.capacity());\n                assert_eq!(node_size as usize, branch.keys.capacity());\n                branch_data = branch;\n            }\n            PageData::L { .. } =\u003e panic!(\"not expect to return leaf variant\"),\n        };\n\n        let mut checked_data = Vec::new(); // clone for further check\n        for i in 0..node_size as usize {\n            let key = KeyT {\n                main: some_rng.gen(),\n                sub: some_rng.gen(),\n            };\n\n            branch_data.keys.push(key);\n            let node_id = some_rng.gen();\n            branch_data.children.push(node_id);\n            checked_data.push((key, node_id));\n        }\n        assert_eq!(PAGE_SIZE, some_file.write(\u0026mut fake_data[..]).unwrap());\n        let mut new_buf: [u8; PAGE_SIZE] = [0; PAGE_SIZE];\n        some_file.seek(SeekFrom::Start(0)).unwrap();\n\n        some_file.read_exact(\u0026mut new_buf[..]).unwrap();\n        let some_page2 = NodePage::\u003cKeyT, KeyT\u003e::cast_generic(node_size, \u0026mut new_buf[..]);\n        some_page2.header.size = size;\n        some_page2.header.next = next;\n        let branch_data2: BranchData\u003c_\u003e;\n        match some_page2.data {\n            PageData::B(branch) =\u003e {\n                assert_eq!(node_size as usize + 1, branch.children.len());\n                assert_eq!(node_size as usize, branch.keys.len());\n                branch_data2 = branch;\n            }\n            PageData::L(_) =\u003e panic!(\"not expect to return leaf variant\"),\n        };\n        assert_eq!(false, some_page2.header.is_leaf);\n        assert_eq!(level, some_page2.header.level);\n\n        assert!(\n            checked_data\n                .iter()\n                .zip(branch_data2.keys.iter())\n                .all(|(a, b)| a.0 == *b),\n            \"Keys slices are not equal\"\n        );\n        assert!(\n            checked_data\n                .iter()\n                .zip(branch_data2.children.iter())\n                .all(|(a, b)| a.1 == *b),\n            \"Children slices are not equal\"\n        );\n    }\n\n    #[test]\n    fn test_cast_leaf() {\n        let mut some_rng: Box\u003cdyn RngCore\u003e = Box::new(thread_rng());\n        let node_size = 7;\n        let size = 7;\n        let next = 7;\n        let level = 10;\n        let mut some_file = tempfile().unwrap();\n        let mut fake_data: [u8; PAGE_SIZE] = [0; PAGE_SIZE];\n        let mut some_page: NodePage\u003cKeyT, KeyT\u003e =\n            NodePage::cast_leaf_from_blank(node_size, \u0026mut fake_data[..]);\n        some_page.header.size = size;\n        some_page.header.next = next;\n        some_page.header.level = level;\n        let mut leaf_data: LeafData\u003c_, _\u003e;\n        match some_page.data {\n            PageData::L(leaf) =\u003e {\n                assert_eq!(node_size as usize, leaf.data.capacity());\n                leaf_data = leaf;\n            }\n            PageData::B { .. } =\u003e panic!(\"not expect to return branch variant\"),\n        };\n\n        let mut checked_data = Vec::new(); // clone for further check\n        for _ in 0..node_size as usize {\n            let key = KeyT {\n                main: some_rng.gen(),\n                sub: some_rng.gen(),\n            };\n            let val = Val { key, val: key };\n            leaf_data.data.push(val);\n            checked_data.push(val);\n        }\n        assert_eq!(PAGE_SIZE, some_file.write(\u0026mut fake_data[..]).unwrap());\n        some_file.flush().unwrap();\n        let mut new_buf: [u8; PAGE_SIZE] = [0; PAGE_SIZE];\n        some_file.seek(SeekFrom::Start(0)).unwrap();\n\n        some_file.read_exact(\u0026mut new_buf[..]).unwrap();\n        let some_page2 = NodePage::\u003cKeyT, KeyT\u003e::cast_generic(node_size, \u0026mut new_buf[..]);\n        some_page2.header.size = size;\n        some_page2.header.next = next;\n        let leaf_data2: LeafData\u003c_, _\u003e;\n        match some_page2.data {\n            PageData::L(leaf) =\u003e {\n                assert_eq!(node_size as usize, leaf.data.len());\n                leaf_data2 = leaf;\n            }\n            PageData::B { .. } =\u003e panic!(\"not expect to return branch variant\"),\n        };\n        assert_eq!(true, some_page2.header.is_leaf);\n        assert_eq!(level, some_page2.header.level);\n\n        assert!(\n            checked_data\n                .iter()\n                .zip(leaf_data2.data.iter())\n                .all(|(a, b)| *a == *b),\n            \"Arrays are not equal\"\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","cc.rs"],"content":"/* use crate::lazy::Lazy;\nuse parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};\n#[cfg(feature = \"testing\")]\nuse std::cell::RefCell;\nuse std::sync::atomic::{\n    AtomicBool, AtomicUsize,\n    Ordering::{Acquire, Release, SeqCst},\n};\n\nuse super::*;\n\n#[cfg(feature = \"testing\")]\nthread_local! {\n    pub static COUNT: RefCell\u003cu32\u003e = RefCell::new(0);\n}\n\nconst RW_REQUIRED_BIT: usize = 1 \u003c\u003c 31;\n\n#[derive(Default)]\npub(crate) struct ConcurrencyControl {\n    active: AtomicUsize,\n    upgrade_complete: AtomicBool,\n    rw: RwLock\u003c()\u003e,\n}\n\nstatic CONCURRENCY_CONTROL: Lazy\u003cConcurrencyControl, fn() -\u003e ConcurrencyControl\u003e =\n    Lazy::new(init_cc);\n\nfn init_cc() -\u003e ConcurrencyControl {\n    ConcurrencyControl::default()\n}\n\n#[derive(Debug)]\n#[must_use]\npub(crate) enum Protector\u003c'a\u003e {\n    Write(RwLockWriteGuard\u003c'a, ()\u003e),\n    Read(RwLockReadGuard\u003c'a, ()\u003e),\n    None(\u0026'a AtomicUsize),\n}\n\nimpl\u003c'a\u003e Drop for Protector\u003c'a\u003e {\n    fn drop(\u0026mut self) {\n        println!(\"dropping\");\n        if let Protector::None(active) = self {\n            active.fetch_sub(1, Release);\n        }\n        #[cfg(feature = \"testing\")]\n        COUNT.with(|c| {\n            let mut c = c.borrow_mut();\n            *c -= 1;\n            assert_eq!(*c, 0);\n        });\n    }\n}\n\npub(crate) fn read\u003c'a\u003e() -\u003e Protector\u003c'a\u003e {\n    CONCURRENCY_CONTROL.read()\n}\n\npub(crate) fn write\u003c'a\u003e() -\u003e Protector\u003c'a\u003e {\n    CONCURRENCY_CONTROL.write()\n}\n\nimpl ConcurrencyControl {\n    fn enable(\u0026self) {\n        if self.active.fetch_or(RW_REQUIRED_BIT, SeqCst) \u003c RW_REQUIRED_BIT {\n            // we are the first to set this bit\n            while self.active.load(Acquire) != RW_REQUIRED_BIT {\n                // `hint::spin_loop` requires Rust 1.49.\n                #[allow(deprecated)]\n                std::sync::atomic::spin_loop_hint()\n            }\n            self.upgrade_complete.store(true, Release);\n        }\n    }\n\n    fn read(\u0026self) -\u003e Protector\u003c'_\u003e {\n        #[cfg(feature = \"testing\")]\n        COUNT.with(|c| {\n            let mut c = c.borrow_mut();\n            *c += 1;\n            assert_eq!(*c, 1);\n        });\n\n        let active = self.active.fetch_add(1, Release);\n\n        if active \u003e= RW_REQUIRED_BIT {\n            self.active.fetch_sub(1, Release);\n            Protector::Read(self.rw.read())\n        } else {\n            Protector::None(\u0026self.active)\n        }\n    }\n\n    fn write(\u0026self) -\u003e Protector\u003c'_\u003e {\n        #[cfg(feature = \"testing\")]\n        COUNT.with(|c| {\n            let mut c = c.borrow_mut();\n            *c += 1;\n            assert_eq!(*c, 1);\n        });\n        self.enable();\n        while !self.upgrade_complete.load(Acquire) {\n            // `hint::spin_loop` requires Rust 1.49.\n            #[allow(deprecated)]\n            std::sync::atomic::spin_loop_hint()\n        }\n        Protector::Write(self.rw.write())\n    }\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::*;\n    use parking_lot::Mutex;\n\n    #[test]\n    fn test_something() {\n        println!(\"here\");\n        let _cc = read();\n        println!(\"here\");\n        let st = Mutex::new(1);\n    }\n} */\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","error.rs"],"content":"use serde_derive::{Deserialize, Serialize};\nuse std::fmt::{self, Display};\n\n/// Result returning Error\npub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n\n/// toyDB errors. All except Internal are considered user-facing.\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub enum Error {\n    Abort,\n    Config(String),\n    Internal(String),\n    Parse(String),\n    ReadOnly,\n    Serialization,\n    Value(String),\n}\n\nimpl std::error::Error for Error {}\n\nimpl Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            Error::Config(s) | Error::Internal(s) | Error::Parse(s) | Error::Value(s) =\u003e {\n                write!(f, \"{}\", s)\n            }\n            Error::Abort =\u003e write!(f, \"Operation aborted\"),\n            Error::Serialization =\u003e write!(f, \"Serialization failure, retry transaction\"),\n            Error::ReadOnly =\u003e write!(f, \"Read-only transaction\"),\n        }\n    }\n}\n\nimpl From\u003cstd::array::TryFromSliceError\u003e for Error {\n    fn from(err: std::array::TryFromSliceError) -\u003e Self {\n        Error::Internal(err.to_string())\n    }\n}\n\nimpl From\u003cstd::io::Error\u003e for Error {\n    fn from(err: std::io::Error) -\u003e Self {\n        Error::Internal(err.to_string())\n    }\n}\n\nimpl From\u003cstd::net::AddrParseError\u003e for Error {\n    fn from(err: std::net::AddrParseError) -\u003e Self {\n        Error::Internal(err.to_string())\n    }\n}\n\nimpl From\u003cstd::num::ParseFloatError\u003e for Error {\n    fn from(err: std::num::ParseFloatError) -\u003e Self {\n        Error::Parse(err.to_string())\n    }\n}\n\nimpl From\u003cstd::num::ParseIntError\u003e for Error {\n    fn from(err: std::num::ParseIntError) -\u003e Self {\n        Error::Parse(err.to_string())\n    }\n}\n\nimpl From\u003cstd::string::FromUtf8Error\u003e for Error {\n    fn from(err: std::string::FromUtf8Error) -\u003e Self {\n        Error::Internal(err.to_string())\n    }\n}\n\nimpl\u003cT\u003e From\u003cstd::sync::PoisonError\u003cT\u003e\u003e for Error {\n    fn from(err: std::sync::PoisonError\u003cT\u003e) -\u003e Self {\n        Error::Internal(err.to_string())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","join","grace.rs"],"content":"#[allow(dead_code)]\nuse core::fmt::Formatter;\nuse std::collections::HashMap;\nuse std::fmt::Debug;\nuse std::rc::Rc;\nuse twox_hash::xxh3::hash64_with_seed;\n\nstruct HashJoiner {\n    outer_queue: Rc\u003cdyn PartitionedQueue\u003e,\n    inner_queue: Rc\u003cdyn PartitionedQueue\u003e,\n    p_index: usize,\n    batch_size: usize,\n    built: bool,\n    htable: HashMap\u003cVec\u003cu8\u003e, Vec\u003cRow\u003e\u003e,\n    left_key_offset: usize,\n    right_key_offset: usize,\n    // unfinished_batch: Option\u003cVec\u003cRow\u003e\u003e,\n}\nimpl HashJoiner {\n    pub fn new(\n        outer_queue: Rc\u003cdyn PartitionedQueue\u003e,\n        inner_queue: Rc\u003cdyn PartitionedQueue\u003e,\n        p_index: usize,\n        batch_size: usize,\n        left_key_offset: usize,\n        right_key_offset: usize,\n    ) -\u003e Self {\n        HashJoiner {\n            outer_queue,\n            inner_queue,\n            p_index,\n            batch_size,\n            left_key_offset,\n            right_key_offset,\n            built: false,\n            htable: HashMap::new(),\n        }\n    }\n}\n\n// TODO: add fallback to merge join, if partition contain duplicate joined rows count\n// that takes more than inmem partition\nstruct GraceHashJoiner\u003cF\u003e\nwhere\n    F: Fn() -\u003e Rc\u003cdyn PartitionedQueue\u003e,\n{\n    config: Config,\n    stack: Vec\u003cPartitionLevel\u003e,\n    undone_joining_partition: Option\u003cHashJoiner\u003e,\n    queue_allocator: F,\n}\nstruct PartitionLevel {\n    level: usize,\n    map: HashMap\u003cusize, PInfo\u003e,\n    outer_queue: Rc\u003cdyn PartitionedQueue\u003e,\n    inner_queue: Rc\u003cdyn PartitionedQueue\u003e,\n}\n\npub trait PartitionedQueue {\n    fn enqueue(\u0026self, partition_idx: usize, data: Vec\u003cRow\u003e);\n    fn dequeue(\u0026self, partition_idx: usize, size: usize) -\u003e Option\u003cBatch\u003e;\n    fn id(\u0026self) -\u003e usize;\n}\n\nstruct PInfo {\n    parent_size: usize,\n    memsize: usize,\n}\npub struct Batch {\n    inner: Vec\u003cRow\u003e,\n}\nimpl Debug for Batch {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result\u003c(), std::fmt::Error\u003e {\n        let st = self\n            .inner\n            .iter()\n            .map(|row| row.string_data(8))\n            .collect::\u003cVec\u003cString\u003e\u003e()\n            .join(\",\");\n\n        f.write_str(\"{\")?;\n        f.write_str(\u0026st)?;\n        f.write_str(\"}\")?;\n        Ok(())\n    }\n}\nimpl Debug for Row {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result\u003c(), std::fmt::Error\u003e {\n        f.write_str(\u0026self.string_data(8))\n    }\n}\nimpl Batch {\n    pub fn new(r: Vec\u003cRow\u003e) -\u003e Self {\n        Batch { inner: r }\n    }\n    pub fn data(\u0026self) -\u003e \u0026Vec\u003cRow\u003e {\n        \u0026self.inner\n    }\n}\n\n#[derive(Clone)]\npub struct Row {\n    pub inner: Vec\u003cu8\u003e,\n}\nimpl Row {\n    fn new(inner: Vec\u003cu8\u003e) -\u003e Self {\n        Row { inner }\n    }\n    pub fn string_data(\u0026self, key_offset: usize) -\u003e String {\n        String::from_utf8(self.inner[key_offset..].to_vec()).unwrap()\n    }\n}\n\nimpl HashJoiner {\n    /* fn left_joined_key\u003c'a\u003e(self, r: \u0026'a Row) -\u003e \u0026'a [u8] {\n        \u0026r.inner[..self.left_key_offset]\n    } */\n    fn joined_key\u003c'a\u003e(key_offset: usize, r: \u0026'a Row) -\u003e \u0026'a [u8] {\n        \u0026r.inner[..key_offset]\n    }\n    fn joined_data\u003c'a\u003e(key_offset: usize, r: \u0026'a Row) -\u003e \u0026'a [u8] {\n        \u0026r.inner[key_offset..]\n    }\n\n    fn _build(\u0026mut self) {\n        let htable = \u0026mut self.htable;\n\n        while let Some(batch) = self.inner_queue.dequeue(self.p_index, self.batch_size) {\n            for item in batch.inner {\n                let key = Self::joined_key(self.right_key_offset, \u0026item);\n                match htable.get_mut(key) {\n                    Some(datas) =\u003e {\n                        datas.push(item);\n                    }\n                    None =\u003e {\n                        htable.insert(key.to_vec(), vec![item]);\n                    }\n                }\n            }\n        }\n        self.built = true;\n    }\n\n    fn next(\u0026mut self) -\u003e Option\u003cBatch\u003e {\n        if !self.built {\n            self._build();\n        }\n\n        let mut ret = Vec::new();\n\n        while let Some(outer_batch) = self.outer_queue.dequeue(self.p_index, self.batch_size) {\n            for (idx, item) in outer_batch.inner.iter().enumerate() {\n                let joined_key = Self::joined_key(self.left_key_offset, \u0026item);\n                match self\n                    .htable\n                    .get(Self::joined_key(self.left_key_offset, \u0026item))\n                {\n                    None =\u003e {\n                        continue;\n                    }\n                    Some(inner_matches) =\u003e {\n                        for inner_match in inner_matches {\n                            let mut joined_row = item.clone();\n                            let inner_data = Self::joined_data(self.right_key_offset, \u0026inner_match);\n                            joined_row.inner.extend(inner_data);\n                            ret.push(joined_row);\n                        }\n                        // TODO need to check batch_size\n                        // return all here for now\n                        // if ret.len() == self.batch_size {\n                        // self.unfinished_batch = Some(ret);\n                        // return Some(Batch::new(ret));\n                        // }\n                    }\n                }\n            }\n        }\n        if ret.len() \u003e 0 {\n            return Some(Batch::new(ret));\n        }\n        return None;\n    }\n}\n\n#[derive(Copy, Clone)]\nstruct Config {\n    bucket_size: usize,\n    max_size_per_partition: usize,\n    batch_size: usize,\n    left_key_offset: usize,\n    right_key_offset: usize,\n}\n\nimpl\u003cF\u003e GraceHashJoiner\u003cF\u003e\nwhere\n    F: Fn() -\u003e Rc\u003cdyn PartitionedQueue\u003e,\n{\n    fn partition_batch(b: Batch, partition_infos: \u0026mut PartitionLevel, c: Config, is_inner: bool) {\n        let mut hash_result: Vec\u003cVec\u003cRow\u003e\u003e = Vec::new();\n        for _ in 0..c.bucket_size {\n            hash_result.push(Vec::new())\n        }\n        let queuer = match is_inner {\n            true =\u003e \u0026partition_infos.inner_queue,\n            false =\u003e \u0026partition_infos.outer_queue,\n        };\n\n        let key_offset = match is_inner {\n            true =\u003e c.right_key_offset,\n            false =\u003e c.left_key_offset,\n        };\n\n        let this_level = partition_infos.level;\n\n        for item in b.inner {\n            let h = Self::hash(\n                Self::get_key(key_offset, \u0026item),\n                c.bucket_size as u64,\n                this_level as u64,\n            );\n            hash_result[h].push(item);\n        }\n\n        for (partition_idx, same_buckets) in hash_result.into_iter().enumerate() {\n            let bucket_length = same_buckets.len();\n\n            queuer.enqueue(partition_idx, same_buckets);\n\n            // only care about inner input\n            if is_inner {\n                match partition_infos.map.get_mut(\u0026partition_idx) {\n                    None =\u003e {\n                        partition_infos.map.insert(\n                            partition_idx,\n                            PInfo {\n                                memsize: bucket_length,\n                                parent_size: 0,\n                            },\n                        );\n                    }\n                    Some(info) =\u003e {\n                        info.memsize += bucket_length;\n                    }\n                };\n            }\n        }\n    }\n\n    fn _find_next_inmem_sized_partition(\n        \u0026mut self,\n        max_size_per_partition: usize,\n    ) -\u003e Option\u003c(\n        usize,\n        PInfo,\n        Rc\u003cdyn PartitionedQueue\u003e,\n        Rc\u003cdyn PartitionedQueue\u003e,\n    )\u003e {\n        let mut found_index = None;\n        let partition_infos = self.stack.last_mut().unwrap();\n        for (index, item) in partition_infos.map.iter_mut() {\n            if item.memsize \u003c= max_size_per_partition {\n                found_index = Some(*index);\n                break;\n            }\n        }\n        match found_index {\n            None =\u003e None,\n            Some(index) =\u003e Some((\n                index,\n                partition_infos.map.remove(\u0026index).unwrap(),\n                partition_infos.outer_queue.clone(),\n                partition_infos.inner_queue.clone(),\n            )),\n        }\n    }\n\n    fn _new_hash_joiner(\n        \u0026self,\n        p_index: usize,\n        outer_queue: Rc\u003cdyn PartitionedQueue\u003e,\n        inner_queue: Rc\u003cdyn PartitionedQueue\u003e,\n    ) -\u003e HashJoiner {\n        let st = HashJoiner {\n            batch_size: self.config.batch_size,\n            htable: HashMap::new(),\n            outer_queue,\n            inner_queue,\n            built: false,\n            p_index,\n            left_key_offset: self.config.left_key_offset,\n            right_key_offset: self.config.right_key_offset,\n        };\n        return st;\n    }\n\n    fn next(\u0026mut self) -\u003e Option\u003cBatch\u003e {\n        if let Some(inmem_joiner) = \u0026mut self.undone_joining_partition {\n            match inmem_joiner.next() {\n                None =\u003e {\n                    self.undone_joining_partition = None;\n                }\n                Some(batch_result) =\u003e {\n                    return Some(batch_result);\n                }\n            };\n        };\n\n        'recursiveloop: while self.stack.len() \u003e 0 {\n            while let Some((p_index, _, outer_queue, inner_queue)) =\n                self._find_next_inmem_sized_partition(self.config.max_size_per_partition)\n            {\n                let mut inmem_joiner = self._new_hash_joiner(p_index, outer_queue, inner_queue);\n                match inmem_joiner.next() {\n                    None =\u003e {\n                        self.undone_joining_partition = None;\n                        continue;\n                    }\n                    Some(batch_result) =\u003e {\n                        self.undone_joining_partition = Some(inmem_joiner);\n                        return Some(batch_result);\n                    }\n                }\n            }\n\n            let cur_partitions = self.stack.last_mut().unwrap();\n\n            // recursive partition\n            if cur_partitions.map.len() \u003e 0 {\n                // let st = cur_partitions.last_mut();\n                if let Some(next_recursive_p) =\n                    Self::recursive_partition(\u0026self.queue_allocator, self.config, cur_partitions)\n                {\n                    self.stack.push(next_recursive_p);\n                    continue 'recursiveloop;\n                }\n            }\n            self.stack.pop();\n        }\n        None\n\n        // Find next partition that we can process without having to\n        // recursively repartition.\n    }\n    fn recursive_partition(\n        queue_allocator: \u0026F,\n        config: Config,\n        current_partition: \u0026mut PartitionLevel,\n    ) -\u003e Option\u003cPartitionLevel\u003e {\n        // let cur_partitions = self.stack.last_mut().unwrap();\n        let mut ret = None;\n        let mut item_remove = -1;\n        for (parent_p_index, _) in current_partition.map.iter_mut() {\n            let child_partitions = HashMap::new();\n\n            let new_outer_queue = queue_allocator();\n            let new_inner_queue = queue_allocator();\n            let mut new_level = PartitionLevel {\n                map: child_partitions,\n                inner_queue: new_inner_queue,\n                outer_queue: new_outer_queue,\n                level: current_partition.level + 1,\n            };\n            while let Some(batch) = current_partition\n                .outer_queue\n                .dequeue(*parent_p_index, config.batch_size)\n            {\n                Self::partition_batch(batch, \u0026mut new_level, config, false);\n            }\n            while let Some(batch) = current_partition\n                .inner_queue\n                .dequeue(*parent_p_index, config.batch_size)\n            {\n                Self::partition_batch(batch, \u0026mut new_level, config, true);\n            }\n\n            ret = Some(new_level);\n            item_remove = *parent_p_index as i64;\n        }\n        if item_remove != -1 {\n            current_partition.map.remove(\u0026(item_remove as usize));\n        }\n        ret\n    }\n    // we track if there exists a bucket with length \u003e max-size per partition\n    fn new(\n        c: Config,\n        mut left: impl Iterator\u003cItem = Batch\u003e,\n        mut right: impl Iterator\u003cItem = Batch\u003e,\n        queue_allocator: F,\n    ) -\u003e Self {\n        let outer_queue = queue_allocator();\n        let inner_queue = queue_allocator();\n        let mut joiner = GraceHashJoiner {\n            config: c,\n            stack: Vec::new(),\n            undone_joining_partition: None,\n            queue_allocator,\n        };\n\n        let mut map = HashMap::new();\n        let mut first_level_partitions = PartitionLevel {\n            map,\n            outer_queue,\n            inner_queue,\n            level: 0,\n        };\n        'until_drain_all: loop {\n            match left.next() {\n                Some(left_batch) =\u003e {\n                    Self::partition_batch(\n                        // \u0026outer_queue,\n                        left_batch,\n                        \u0026mut first_level_partitions,\n                        joiner.config,\n                        false,\n                    );\n                    match right.next() {\n                        Some(right_batch) =\u003e {\n                            Self::partition_batch(\n                                // \u0026inner_queue,\n                                right_batch,\n                                \u0026mut first_level_partitions,\n                                joiner.config,\n                                true,\n                            );\n                        }\n                        None =\u003e {}\n                    };\n                }\n                None =\u003e {\n                    match right.next() {\n                        Some(right_batch) =\u003e {\n                            Self::partition_batch(\n                                // \u0026inner_queue,\n                                right_batch,\n                                \u0026mut first_level_partitions,\n                                joiner.config,\n                                true,\n                            );\n                        }\n                        None =\u003e break 'until_drain_all,\n                    };\n                }\n            };\n        }\n\n        joiner.stack.push(first_level_partitions);\n        return joiner;\n    }\n\n    fn hash(bytes: \u0026[u8], bucket_size: u64, seed: u64) -\u003e usize {\n        let ret = hash64_with_seed(bytes, seed);\n        return (ret % bucket_size) as usize;\n    }\n    fn get_key\u003c'a\u003e(key_offset: usize, r: \u0026'a Row) -\u003e \u0026'a [u8] {\n        \u0026r.inner[..key_offset]\n    }\n}\n\n#[cfg(test)]\npub mod tests {\n    use super::{Config, GraceHashJoiner, HashJoiner, PartitionedQueue, Row};\n    use crate::join::grace::Batch;\n    use crate::join::queue::{Inmem, MemoryAllocator};\n    use core::cell::RefCell;\n    use itertools::Itertools;\n    use std::cmp::Ordering::{self, Equal};\n    use std::rc::Rc;\n    use zerocopy::{AsBytes, FromBytes};\n\n    fn make_i64s_row(item: (i64, \u0026[u8])) -\u003e Row {\n        let mut vec = Vec::new();\n        vec.extend(item.0.to_le_bytes());\n        vec.extend(item.1);\n        Row::new(vec)\n    }\n\n    macro_rules! make_rows {\n        // Base case:\n        ($a:expr,$b:expr) =\u003e {{\n            vec![($a, $b)]\n        }};\n        ($a:expr,$b:expr,$($rest:expr),*) =\u003e {{\n            [vec![($a,$b)],make_rows!($($rest),*)].concat()\n        }};\n    }\n\n    struct RowType(i64, Vec\u003cu8\u003e);\n    #[test]\n    fn test_grace_h_joiner() {\n        struct TestCase {\n            outer: Vec\u003c(i64, \u0026'static str)\u003e,\n            inner: Vec\u003c(i64, \u0026'static str)\u003e,\n            expect: Vec\u003c(i64, \u0026'static str)\u003e,\n        }\n        // we expect the inner to be hashed, so we can't guarantee order of the rows returned\n        let tcases = vec![\n            TestCase {\n                outer: make_rows!(1, \"a1\", 2, \"b1\", 1, \"c1\"),\n                inner: make_rows!(1, \"a2\", 2, \"b2\"),\n                expect: make_rows!(1, \"a1a2\", 2, \"b1b2\", 1, \"c1a2\"),\n            },\n            TestCase {\n                outer: make_rows!(1, \"a1\", 2, \"b1\", 1, \"c1\"),\n                inner: make_rows!(1, \"a2\", 2, \"b2\", 1, \"a3\", 3, \"c2\"),\n                expect: make_rows!(1, \"a1a2\", 2, \"b1b2\", 1, \"c1a2\", 1, \"a1a3\", 1, \"c1a3\"),\n            },\n            TestCase {\n                outer: make_rows!(1, \"a1\", 2, \"b1\", 1, \"c1\"),\n                inner: make_rows!(1, \"a2\", 2, \"b2\", 1, \"a3\", 3, \"c2\", 3, \"c2\", 2, \"b2\"),\n                expect: make_rows!(\n                    1, \"a1a2\", 2, \"b1b2\", 1, \"c1a2\", 1, \"a1a3\", 1, \"c1a3\", 2, \"b1b2\"\n                ),\n            },\n        ];\n        for item in \u0026tcases {\n            let batch_size = 2;\n            let left_key_offset = 8; // first 8 bytes represents join key\n            let right_key_offset = 8;\n\n            let mut outer_batches = Vec::new();\n            for chunk in \u0026item.outer.iter().chunks(batch_size) {\n                let mut rows = Vec::new();\n                for item in chunk {\n                    rows.push(make_i64s_row((item.0, item.1.as_bytes())));\n                }\n                outer_batches.push(Batch::new(rows));\n            }\n            let mut inner_batches = Vec::new();\n            for chunk in \u0026item.inner.iter().chunks(batch_size) {\n                let mut rows = Vec::new();\n                for item in chunk {\n                    rows.push(make_i64s_row((item.0, item.1.as_bytes())));\n                }\n                inner_batches.push(Batch::new(rows));\n            }\n            let alloc = RefCell::new(MemoryAllocator::new());\n\n            let config = Config {\n                bucket_size: 2,\n                max_size_per_partition: 2,\n                batch_size: 2,\n                left_key_offset,\n                right_key_offset,\n            };\n            let mut joiner = GraceHashJoiner::new(\n                config,\n                outer_batches.into_iter(),\n                inner_batches.into_iter(),\n                || -\u003e Rc\u003cdyn PartitionedQueue\u003e { alloc.borrow_mut().alloc() },\n            );\n            let mut ret: Vec\u003c(i64, Vec\u003cu8\u003e)\u003e = Vec::new();\n            // joined result should be 1,1|1,1|1,1|1,1\n            while let Some(b) = joiner.next() {\n                for row in b.data() {\n                    let joined_key = FromBytes::read_from(\u0026row.inner[..8]).unwrap();\n                    let other_data = row.inner[8..].to_vec();\n                    // let other_data = FromBytes::read_from(\u0026row.inner[8..]).unwrap();\n                    ret.push((joined_key, other_data));\n                }\n            }\n            // let expect = [[1, 1], [1, 1], [1, 1], [1, 1]];\n            ret.sort_by(|a, b| cmp_row(a, b));\n            let mut expect: Vec\u003c(i64, Vec\u003cu8\u003e)\u003e = item\n                .expect\n                .iter()\n                .map(|item| (item.0, item.1.as_bytes().to_vec()))\n                .collect();\n            expect.sort_by(|a, b| cmp_row(a, b));\n\n            assert_eq!(expect.len(), ret.len(), \"wrong number of rows returned\");\n            let equal = expect.iter().zip(ret.iter()).all(|(expect, real)| {\n                compare_row(expect.1.as_bytes().iter(), real.1.as_bytes().iter())\n            });\n            assert!(equal);\n        }\n    }\n    fn cmp_row\u003cA\u003e(a: \u0026(A, Vec\u003cu8\u003e), b: \u0026(A, Vec\u003cu8\u003e)) -\u003e Ordering\n    where\n        A: Ord,\n    {\n        if a.0 != b.0 {\n            return a.0.cmp(\u0026b.0);\n        }\n        assert_eq!(a.1.len(), b.1.len());\n        for i in 0..a.1.len() {\n            if a.1[i] != b.1[i] {\n                return a.1[i].cmp(\u0026b.1[i]);\n            }\n        }\n        Equal\n    }\n\n    #[test]\n    fn test_inmem_joiner() {\n        struct TestCase {\n            outer: Vec\u003ci64\u003e,\n            inner: Vec\u003ci64\u003e,\n            expect: Vec\u003ci64\u003e,\n        }\n        let tcases = vec![\n            TestCase {\n                outer: vec![1, 1, 1, 1],\n                inner: vec![1, 2, 2, 2],\n                expect: vec![1, 1, 1, 1],\n            },\n            TestCase {\n                outer: vec![1, 2, 1, 2],\n                inner: vec![2, 1],\n                expect: vec![1, 2, 1, 2],\n            },\n        ];\n        for item in \u0026tcases {\n            let p_index = 1;\n            let batch_size = 2;\n            let left_key_offset = 8; // first 8 bytes represents join key\n            let right_key_offset = 8;\n\n            let mut outer_rows = Vec::new();\n            for i in \u0026item.outer {\n                outer_rows.push(make_i64s_row((*i, \u0026i.to_le_bytes()[..])));\n            }\n            let mut inner_rows = Vec::new();\n            for i in \u0026item.inner {\n                inner_rows.push(make_i64s_row((*i, \u0026i.to_le_bytes()[..])));\n            }\n\n            let in_queue = Inmem::new(1);\n            let out_queue = Inmem::new(2);\n            in_queue.enqueue(1, inner_rows);\n            out_queue.enqueue(1, outer_rows);\n            let mut joiner = HashJoiner::new(\n                Rc::new(out_queue),\n                Rc::new(in_queue),\n                p_index,\n                batch_size,\n                left_key_offset,\n                right_key_offset,\n            );\n            let mut ret: Vec\u003ci64\u003e = Vec::new();\n            // joined result should be 1,1|1,1|1,1|1,1\n            while let Some(b) = joiner.next() {\n                for row in b.data() {\n                    let joined_key = FromBytes::read_from(\u0026row.inner[..8]).unwrap();\n                    ret.push(joined_key);\n                    // ret.push((joined_key, row.inner[8..].to_vec()));\n                }\n            }\n            // let expect = [[1, 1], [1, 1], [1, 1], [1, 1]];\n\n            assert_eq!(\n                item.expect.len(),\n                ret.len(),\n                \"wrong number of rows returned\"\n            );\n            let equal = item\n                .expect\n                .iter()\n                .zip(ret.iter())\n                .all(|(real, expect)| real == expect);\n            assert!(equal);\n        }\n    }\n\n    fn compare_row\u003c'a\u003e(\n        left: impl Iterator\u003cItem = \u0026'a u8\u003e,\n        right: impl Iterator\u003cItem = \u0026'a u8\u003e,\n    ) -\u003e bool {\n        left.zip(right).all(|(a, b)| a == b)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","join","mod.rs"],"content":"mod grace;\nmod queue;\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","join","queue.rs"],"content":"use crate::join::grace::Batch;\nuse crate::join::grace::PartitionedQueue;\nuse crate::join::grace::Row;\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::collections::VecDeque;\nuse std::rc::Rc;\n\npub struct Inmem {\n    inner: RefCell\u003cHashMap\u003cusize, VecDeque\u003cRow\u003e\u003e\u003e,\n    id: usize,\n}\npub struct MemoryAllocator {\n    queues: Vec\u003cInmem\u003e,\n    cur_id: usize,\n}\nimpl MemoryAllocator {\n    pub fn new() -\u003e Self {\n        MemoryAllocator {\n            queues: vec![],\n            cur_id: 0,\n        }\n    }\n\n    pub fn alloc(\u0026mut self) -\u003e Rc\u003cInmem\u003e {\n        let cur_id = self.cur_id;\n        self.cur_id += 1;\n        let new = Inmem::new(cur_id);\n        let rc = Rc::new(new);\n        return rc;\n    }\n}\nimpl Inmem {\n    pub fn new(id: usize) -\u003e Self {\n        Inmem {\n            inner: RefCell::new(HashMap::new()),\n            id,\n        }\n    }\n}\n\nimpl PartitionedQueue for Inmem {\n    fn id(\u0026self) -\u003e usize {\n        self.id\n    }\n    fn enqueue(\u0026self, partition_idx: usize, data: Vec\u003cRow\u003e) {\n        let mut inner = self.inner.borrow_mut();\n        match inner.get_mut(\u0026partition_idx) {\n            None =\u003e {\n                let mut new_dequeue = VecDeque::new();\n                new_dequeue.extend(data);\n                inner.insert(partition_idx, new_dequeue);\n            }\n            Some(exist) =\u003e {\n                exist.extend(data);\n            }\n        }\n    }\n\n    fn dequeue(\u0026self, partition_idx: usize, size: usize) -\u003e Option\u003cBatch\u003e {\n        let mut inner = self.inner.borrow_mut();\n        match inner.get_mut(\u0026partition_idx) {\n            None =\u003e {\n                inner.remove(\u0026partition_idx);\n                None\n            }\n            Some(exist) =\u003e {\n                let mut ret = Vec::new();\n                while let Some(row) = exist.pop_front() {\n                    ret.push(row);\n                    if ret.len() == size {\n                        break;\n                    }\n                }\n                if ret.len() \u003e 0 {\n                    Some(Batch::new(ret))\n                } else {\n                    inner.remove(\u0026partition_idx);\n                    None\n                }\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","lib.rs"],"content":"pub mod bpm;\npub mod btree;\npub mod cc;\npub mod error;\npub mod join;\npub mod replacer;\n// pub mod sql;\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","main.rs"],"content":"use bustubrust::bpm::DiskManager;\nuse std::cell::UnsafeCell;\nuse std::sync::atomic::AtomicUsize;\nuse std::sync::{Arc, Barrier};\nuse std::thread::{sleep, spawn};\nuse std::time;\nuse std::{\n    os::unix::thread,\n    sync::atomic::{AtomicBool, AtomicI64, Ordering},\n};\n\n// use cc::read;\n\nstatic my_num: i64 = 0;\nstatic has_data: AtomicBool = AtomicBool::new(false);\nstatic NTHREADS: usize = 8;\n\nfn main() {\n    main2();\n}\n\n#[derive(Default)]\nstruct UsizePair {\n    atomic: AtomicUsize,\n    normal: UnsafeCell\u003cusize\u003e,\n}\n\nstatic NITERS: usize = 1000000;\n/* struct SendPtr\u003cT\u003e(*const T);\nunsafe impl\u003cT\u003e Sync for SendPtr\u003cT\u003e {}\nunsafe impl\u003cT\u003e Send for SendPtr\u003cT\u003e {} */\n\nunsafe impl Sync for UsizePair {}\nimpl UsizePair {\n    fn get(\u0026self) -\u003e (usize, usize) {\n        let atom = self.atomic.load(Ordering::Relaxed); //Ordering::Acquire\n\n        let norm = unsafe { *self.normal.get() };\n        (atom, norm)\n    }\n    pub fn set(\u0026self, v: usize) {\n        unsafe { *self.normal.get() = v };\n\n        self.atomic.store(v, Ordering::Relaxed); //Ordering::Release\n    }\n}\n\nfn main2() {\n    /* let shared2 = shared.clone();\n    let shared3 = shared.clone(); */\n\n    loop {\n        let barrier = Arc::new(Barrier::new(NTHREADS + 1));\n        let shared = Arc::new(UsizePair::default());\n        let mut children = vec![];\n\n        for _ in 0..NTHREADS {\n            let shared = shared.clone();\n            let barrier = barrier.clone();\n            children.push(spawn(move || {\n                barrier.wait();\n                let mut v = 0;\n                while v \u003c NITERS - 1 {\n                    let (atom, norm) = shared.get();\n                    if atom \u003e norm {\n                        println!(\"reordered !!!! {} \u003e {}\", atom, norm)\n                    }\n                    v = atom;\n                }\n            }));\n        }\n        barrier.wait();\n        for v in 1..NITERS {\n            shared.set(v);\n        }\n        for child in children {\n            child.join().unwrap();\n        }\n\n        // has_data.store(false, Ordering::SeqCst);\n        sleep(time::Duration::from_millis(50));\n        println!(\"retying\");\n    }\n}\n\nfn do_something() -\u003e i32 {\n    let a = 1;\n    a + 2\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","replacer.rs"],"content":"use crate::bpm::FrameID;\nuse crate::bpm::Replacer;\nuse lru::LruCache;\nuse std::cell::RefCell;\n\npub struct LRURepl {\n    internal: RefCell\u003cLruCache\u003cFrameID, ()\u003e\u003e,\n}\n\nimpl LRURepl {\n    pub fn new(cap: usize) -\u003e Self {\n        LRURepl {\n            internal: RefCell::new(LruCache::new(cap)),\n        }\n    }\n}\n\nimpl Replacer for LRURepl {\n    fn victim(\u0026self) -\u003e Option\u003cFrameID\u003e {\n        match self.internal.borrow_mut().pop_lru() {\n            Some((frame_id, _)) =\u003e Some(frame_id),\n            None =\u003e None,\n        }\n    }\n    fn size(\u0026self) -\u003e i64 {\n        self.internal.borrow().len() as i64\n    }\n    fn unpin(\u0026self, frame_id: FrameID) {\n        if !self.internal.borrow().contains(\u0026frame_id) {\n            self.internal.borrow_mut().put(frame_id, ());\n        }\n    }\n    fn pin(\u0026self, frame_id: FrameID) {\n        self.internal.borrow_mut().pop(\u0026frame_id);\n    }\n}\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_replacer() {\n        let r = LRURepl::new(7);\n        r.unpin(1);\n        r.unpin(2);\n        r.unpin(3);\n        r.unpin(4);\n        r.unpin(5);\n        r.unpin(6);\n        r.unpin(1);\n        assert_eq!(6, r.size());\n        let ret = r.victim();\n        assert_eq!(ret, Some(1));\n        let ret = r.victim();\n        assert_eq!(ret, Some(2));\n        let ret = r.victim();\n        assert_eq!(ret, Some(3));\n        r.pin(3);\n        r.pin(4);\n\n        assert_eq!(2, r.size());\n\n        r.unpin(4);\n\n        let ret = r.victim();\n        assert_eq!(ret, Some(5));\n        let ret = r.victim();\n        assert_eq!(ret, Some(6));\n        let ret = r.victim();\n        assert_eq!(ret, Some(4));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","sql","executor.rs"],"content":"use super::plan::Node;\nuse crate::error::{Error, Result};\nuse crate::sql::join::HashInnerJoin;\nuse crate::sql::tx::Transaction;\nuse crate::sql::Nothing;\nuse crate::sql::ResultSet;\nuse crate::sql::Row;\nuse serde_derive::{Deserialize, Serialize};\nuse std::hash::{Hash, Hasher};\n\npub trait Executor\u003cT: Transaction\u003e {\n    fn next(self: Box\u003cSelf\u003e, txn: \u0026mut T) -\u003e Result\u003cResultSet\u003e;\n}\n\nimpl\u003cT: Transaction + 'static\u003e dyn Executor\u003cT\u003e {\n    /// Builds an executor for a plan node, consuming it\n    pub fn build(node: Node) -\u003e Box\u003cdyn Executor\u003cT\u003e\u003e {\n        match node {\n            Node::HashJoin {\n                left,\n                left_field,\n                right,\n                right_field,\n                outer,\n            } =\u003e HashInnerJoin::new(\n                Self::build(*left),\n                left_field.0,\n                Self::build(*right),\n                right_field.0,\n                outer,\n            ),\n            Node::Nothing =\u003e Nothing::new(),\n        }\n    }\n}\n\n/* pub struct Tuple\u003c'a\u003e {\n    data: \u0026'a [u8],\n}\npub struct Schema {}\n\npub struct Rid {}\n\nimpl\u003c'a\u003e Tuple\u003c'a\u003e {\n    fn get_rid() -\u003e Rid {\n        Rid {}\n    }\n\n    fn get_data(\u0026self) -\u003e \u0026'a [u8] {\n        return self.data;\n    }\n} */\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub enum Value {\n    Null,\n    Boolean(bool),\n    Integer(i64),\n    Float(f64),\n    String(String),\n}\n\nimpl std::cmp::Eq for Value {}\n\n#[allow(clippy::derive_hash_xor_eq)]\nimpl Hash for Value {\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.datatype().hash(state);\n        match self {\n            Value::Null =\u003e self.hash(state),\n            Value::Boolean(v) =\u003e v.hash(state),\n            Value::Integer(v) =\u003e v.hash(state),\n            Value::Float(v) =\u003e v.to_be_bytes().hash(state),\n            Value::String(v) =\u003e v.hash(state),\n        }\n    }\n}\n\nimpl Value {\n    /// Returns the value's datatype, or None for null values\n    pub fn datatype(\u0026self) -\u003e Option\u003cDataType\u003e {\n        match self {\n            Self::Null =\u003e None,\n            Self::Boolean(_) =\u003e Some(DataType::Boolean),\n            Self::Integer(_) =\u003e Some(DataType::Integer),\n            Self::Float(_) =\u003e Some(DataType::Float),\n            Self::String(_) =\u003e Some(DataType::String),\n        }\n    }\n\n    /// Returns the inner boolean, or an error if not a boolean\n    pub fn boolean(self) -\u003e Result\u003cbool\u003e {\n        match self {\n            Self::Boolean(b) =\u003e Ok(b),\n            v =\u003e Err(Error::Value(format!(\"Not a boolean: {:?}\", v))),\n        }\n    }\n\n    /// Returns the inner float, or an error if not a float\n    pub fn float(self) -\u003e Result\u003cf64\u003e {\n        match self {\n            Self::Float(f) =\u003e Ok(f),\n            v =\u003e Err(Error::Value(format!(\"Not a float: {:?}\", v))),\n        }\n    }\n\n    /// Returns the inner integer, or an error if not an integer\n    pub fn integer(self) -\u003e Result\u003ci64\u003e {\n        match self {\n            Self::Integer(i) =\u003e Ok(i),\n            v =\u003e Err(Error::Value(format!(\"Not an integer: {:?}\", v))),\n        }\n    }\n\n    /// Returns the inner string, or an error if not a string\n    pub fn string(self) -\u003e Result\u003cString\u003e {\n        match self {\n            Self::String(s) =\u003e Ok(s),\n            v =\u003e Err(Error::Value(format!(\"Not a string: {:?}\", v))),\n        }\n    }\n}\n\nimpl std::fmt::Display for Value {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        f.write_str(\n            match self {\n                Self::Null =\u003e \"NULL\".to_string(),\n                Self::Boolean(b) if *b =\u003e \"TRUE\".to_string(),\n                Self::Boolean(_) =\u003e \"FALSE\".to_string(),\n                Self::Integer(i) =\u003e i.to_string(),\n                Self::Float(f) =\u003e f.to_string(),\n                Self::String(s) =\u003e s.clone(),\n            }\n            .as_ref(),\n        )\n    }\n}\n\n#[derive(Clone, Debug, Hash, PartialEq, Serialize, Deserialize)]\npub enum DataType {\n    Boolean,\n    Integer,\n    Float,\n    String,\n}\n\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Nothing {\n    fn next(self: Box\u003cSelf\u003e, _: \u0026mut T) -\u003e Result\u003cResultSet\u003e {\n        Ok(ResultSet::Query {\n            columns: Vec::new(),\n            rows: Box::new(std::iter::once(Ok(Row::new()))),\n        })\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","sql","join.rs"],"content":"use crate::bpm::{BufferPoolManager, Frame, Replacer};\nuse crate::error::{Error, Result};\nuse crate::replacer::LRURepl;\nuse crate::sql::executor::Executor;\nuse crate::sql::tx::Transaction;\nuse crate::sql::Value;\nuse crate::sql::{ColumnedBatch, ResultSet};\nuse iota::iota;\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::marker::PhantomData;\n\n// TODO: BufferPoolManager should have generic over LRURepl, but this module should not not about\n// that type parameter, maybe using associated types????\npub struct GraceHashJoin\u003cT: Transaction\u003e {\n    bpm: RefCell\u003cBufferPoolManager\u003cLRURepl\u003e\u003e,\n    left: Box\u003cdyn Executor\u003cT\u003e\u003e,\n    left_field: usize,\n    right: Box\u003cdyn Executor\u003cT\u003e\u003e,\n    right_field: usize,\n    state: PartitionState,\n    // TODO: for each input, implement an in-memory input container that makes call to\n    // bpm for enqueuing/dequeing the batch data on demand\n    //\n}\ntype PartitionState = i64;\niota! {\n    const INITIAL_PARTITIONING: PartitionState = 0 \u003c\u003c iota;\n        ,PROCESS_NEW_PARTITION\n        ,PROCESSING\n        ,FINISHED\n}\n\nimpl\u003cT: Transaction, F: Fn(Frame, Frame) -\u003e Box\u003cdyn Executor\u003cT\u003e\u003e\u003e Executor\u003cT\u003e\n    for GraceHashJoin\u003cT, F\u003e\n{\n    /// When the tables do not fit on main memory, the DBMS has to swap tables in and out essentially at random,\n    /// which leads to poor performance. The Grace Hash Join is an extension of the basic hash join that also hashes\n    /// the inner table into partitions that are written out to disk.\n    ///\n    ///  Phase #1  Build: First, scan both the outer and inner tables and populate a hash table using the hash\n    /// function h1 on the join attributes. The hash tables buckets are written out to disk as needed. If a single\n    /// bucket does not fit in memory, the DBMS can use recursive partitioning with different hash function\n    /// h2 (where h1 6= h2) to further divide the bucket. This can continue recursively until the buckets fit\n    /// into memory.\n    ///\n    ///  Phase #2  Probe: For each bucket level, retrieve the corresponding pages for both outer and inner\n    /// tables. Then, perform a nested loop join on on the tuples in those two pages. The pages will fit in\n    /// memory, so this join operation will be fast.\n    /// Referenec: https://15445.courses.cs.cmu.edu/fall2021/notes/10-joins.pdf\n    /// CockcroachDB: https://github.com/cockroachdb/cockroach/issues/43790\n    fn next(self: Box\u003cSelf\u003e, txn: \u0026mut T) -\u003e Result\u003cResultSet\u003e {\n        loop {\n            match self.state {\n                INITIAL_PARTITIONING =\u003e self.initial_partition(txn),\n                PROCESS_NEW_PARTITION =\u003e self.process_new_partition(txn),\n                PROCESSING =\u003e self.processing(txn),\n                FINISHED =\u003e {\n                    self.finish(txn);\n                    break;\n                }\n            };\n        }\n        /* let bpm = self.bpm.borrow();\n        self.left.next(txn);\n        bpm.new_page(); */\n        Err(Error::Abort)\n    }\n}\nstruct FramedScanner {\n    f: Frame,\n}\nimpl FramedScanner {\n    fn new(f: Frame) -\u003e Self {\n        FramedScanner { f }\n    }\n}\n\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for FramedScanner {\n    fn next(self: Box\u003cSelf\u003e, txn: \u0026mut T) -\u003e Result\u003cResultSet\u003e {}\n}\n\nimpl\u003cT: 'static + Transaction\u003e GraceHashJoin\u003cT\u003e {\n    fn new(\n        bpm: BufferPoolManager\u003cLRURepl\u003e,\n        left: Box\u003cdyn Executor\u003cT\u003e\u003e, // original left source\n        left_field: usize,\n        right: Box\u003cdyn Executor\u003cT\u003e\u003e, // original right source\n        right_field: usize,\n    ) -\u003e Self {\n        GraceHashJoin {\n            bpm: RefCell::new(bpm),\n            left,\n            right,\n            left_field,\n            right_field,\n            state: INITIAL_PARTITIONING,\n        }\n    }\n    fn in_mem_op_constructor(f1: Frame, f2: Frame) -\u003e Box\u003cdyn Executor\u003cT\u003e\u003e {\n        HashInnerJoin::new(\n            Box::new(FramedScanner::new(f1)),\n            0,\n            Box::new(FramedScanner::new(f2)),\n            0,\n            false,\n        )\n    }\n\n    fn initial_partition(self: Box\u003cSelf\u003e, txn: \u0026mut T) {\n        let left_batch = self.left.next(txn);\n        let right_batch = self.right.next(txn);\n    }\n    fn process_new_partition(self: Box\u003cSelf\u003e, txn: \u0026mut T) {}\n    fn processing(self: Box\u003cSelf\u003e, txn: \u0026mut T) {}\n    fn finish(self: Box\u003cSelf\u003e, txn: \u0026mut T) {}\n\n    fn partition_batch(self: Box\u003cSelf\u003e, ret: ColumnedBatch, idx: usize, parent_mem_size: i64) {\n        if ret.len() == 0 {\n            return;\n        }\n    }\n\n    // result stores info about at which partition, which tuples in the input batch belongs to\n    fn _distribute_batch(self: Box\u003cSelf\u003e, b: ColumnedBatch) -\u003e Vec\u003cVec\u003ci64\u003e\u003e {\n        let total_tuple = b.len();\n    }\n\n    fn xxhash3(val: \u0026[u8]) -\u003e u64 {\n        xxhash_rust::xxh3::xxh3_64(val)\n    }\n}\n\npub struct HashInnerJoin\u003cT: Transaction\u003e {\n    left: Box\u003cdyn Executor\u003cT\u003e\u003e,\n    left_field: usize, // index of the joined field inside the tuple of left table\n    right: Box\u003cdyn Executor\u003cT\u003e\u003e,\n    right_field: usize, // index of the joined field inside the tuple of the right table\n    outer: bool,\n}\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for HashInnerJoin\u003cT\u003e {\n    fn next(self: Box\u003cSelf\u003e, txn: \u0026mut T) -\u003e Result\u003cResultSet\u003e {\n        if let ResultSet::Query {\n            rows: outer_rows,\n            columns: mut outer_columns,\n        } = self.left.next(txn)?\n        {\n            let (l, r) = (self.left_field, self.right_field);\n            if let ResultSet::Query {\n                rows: right_rows,\n                columns: right_columns,\n            } = self.right.next(txn)?\n            {\n                let inner_table: HashMap\u003cValue, Vec\u003cValue\u003e\u003e = right_rows\n                    .map(|r_tuple| match r_tuple {\n                        Ok(values) =\u003e {\n                            if values.len() \u003c= r {\n                                return Err(Error::Internal(\n                                    \"right index out of bound\".to_string(),\n                                ));\n                            }\n                            let joined_key = values[r].clone();\n                            return Ok((joined_key, values));\n                        }\n                        Err(err) =\u003e Err(err),\n                    })\n                    .collect::\u003cResult\u003c_\u003e\u003e()?;\n                outer_columns.extend(right_columns);\n                // iterate outer rows, probe inner table, if match omit, else do nothing\n                // this is like an inner join\n                let joined_rows = outer_rows.filter_map(move |tuple_result| match tuple_result {\n                    Ok(mut tuple) =\u003e {\n                        if tuple.len() \u003c= l {\n                            return Some(Err(Error::Value(\"left index out of bound\".to_string())));\n                        }\n\n                        let joined_field = tuple[l].clone();\n                        match inner_table.get(\u0026joined_field) {\n                            Some(hit) =\u003e {\n                                //TODO: consider late vs early materialization\n                                tuple.extend(hit.clone());\n                                return Some(Ok(tuple));\n                            }\n                            None =\u003e return None,\n                        };\n                    }\n                    Err(err) =\u003e Some(Err(err)),\n                });\n                return Ok(ResultSet::Query {\n                    columns: outer_columns,\n                    rows: Box::new(joined_rows),\n                });\n            }\n        };\n        Err(Error::Internal(\"unimplemented\".into()))\n    }\n}\n\nimpl\u003cT: Transaction\u003e HashInnerJoin\u003cT\u003e {\n    pub fn new(\n        left: Box\u003cdyn Executor\u003cT\u003e\u003e,\n        left_field: usize,\n        right: Box\u003cdyn Executor\u003cT\u003e\u003e,\n        right_field: usize,\n        outer: bool,\n    ) -\u003e Box\u003cSelf\u003e {\n        if outer {\n            panic!(\"unimplemented\");\n        }\n        Box::new(HashInnerJoin {\n            left,\n            left_field,\n            right,\n            right_field,\n            outer,\n        })\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","sql","mod.rs"],"content":"mod executor;\nmod join;\nmod plan;\nmod tx;\n\nuse crate::error::Result;\nuse crate::sql::executor::Value;\nuse crate::sql::plan::Node;\nuse derivative::Derivative;\nuse serde_derive::{Deserialize, Serialize};\n\n#[derive(Derivative, Serialize, Deserialize)]\n#[derivative(Debug, PartialEq)]\npub enum ResultSet {\n    // Transaction started\n    /* Begin {\n        id: u64,\n        mode: Mode,\n    },\n    // Transaction committed\n    Commit {\n        id: u64,\n    },\n    // Transaction rolled back\n    Rollback {\n        id: u64,\n    },\n    // Rows created\n    Create {\n        count: u64,\n    },\n    // Rows deleted\n    Delete {\n        count: u64,\n    },\n    // Rows updated\n    Update {\n        count: u64,\n    },\n    // Table created\n    CreateTable {\n        name: String,\n    },\n    // Table dropped\n    DropTable {\n        name: String,\n    }, */\n    // Query result\n    Query {\n        columns: ColumnLabels,\n        #[derivative(Debug = \"ignore\")]\n        #[derivative(PartialEq = \"ignore\")]\n        #[serde(skip, default = \"ResultSet::empty_rows\")]\n        rows: Rows,\n    },\n    ColumnedBatch(ColumnedBatch),\n    // Explain result\n    Explain(Node),\n}\n\n/// Column oriented batch\n#[derive(Deserialize, Serialize, PartialEq, Debug)]\npub struct ColumnedBatch {\n    length: usize,\n    capacity: usize,\n    columns: Columns,\n}\nimpl ColumnedBatch {\n    fn empty(self) -\u003e bool {\n        self.length == 0\n    }\n\n    fn len(self) -\u003e usize {\n        self.length\n    }\n\n    fn capacity(self) -\u003e usize {\n        self.capacity\n    }\n\n    fn width(self) -\u003e usize {\n        self.columns.len()\n    }\n\n    fn get_column_ith_values(\u0026self, col_number: usize) -\u003e \u0026Column {\n        \u0026self.columns[col_number]\n    }\n}\n\n/// A row of values\npub type Column = Vec\u003cValue\u003e;\n\n/// A row iterator\npub type Columns = Vec\u003cColumn\u003e;\n\n/// A row of values\npub type Row = Vec\u003cValue\u003e;\n\n/// A row iterator\npub type Rows = Box\u003cdyn Iterator\u003cItem = Result\u003cRow\u003e\u003e + Send\u003e;\n\n/// A column (in a result set, see schema::Column for table columns)\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\npub struct ColumnLabel {\n    pub name: Option\u003cString\u003e,\n}\n\n/// A set of columns\npub type ColumnLabels = Vec\u003cColumnLabel\u003e;\n\nimpl ResultSet {\n    /// Creates an empty row iterator, for use by serde(default).\n    fn empty_rows() -\u003e Rows {\n        Box::new(std::iter::empty())\n    }\n}\n\npub struct Nothing;\n\nimpl Nothing {\n    pub fn new() -\u003e Box\u003cSelf\u003e {\n        Box::new(Self)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","sql","plan.rs"],"content":"use serde_derive::{Deserialize, Serialize};\n\n/// A plan node\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\npub enum Node {\n    HashJoin {\n        left: Box\u003cNode\u003e,\n        left_field: (usize, Option\u003c(Option\u003cString\u003e, String)\u003e),\n        right: Box\u003cNode\u003e,\n        right_field: (usize, Option\u003c(Option\u003cString\u003e, String)\u003e),\n        outer: bool,\n    },\n    Nothing,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","var","www","rust","bustubrust","src","sql","tx.rs"],"content":"pub trait Transaction {}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>